diff --git a/.gitignore b/.gitignore
index f288e8b..f5c6346 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,8 @@ aclocal.m4
 config.h
 include/config.h.in
 include/config.h.in.orig
+aconf.h.in
+aconf.h.in.orig
 config.log
 config.status
 configure
@@ -26,6 +28,7 @@ intltool-update
 *.xcworkspace
 xcuserdata
 m4/amversion.m4
+m4/as.m4
 m4/auxdir.m4
 m4/cond.m4
 m4/depend.m4
@@ -62,24 +65,6 @@ doc/output
 .deps
 .stamp*
 .dirstamp
-xpdf-qt/xpdf
-xpdf-qt/icons.qrc.depends
-xpdf-qt/moc_XpdfApp.cpp_parameters
-xpdf-qt/moc_XpdfViewer.cpp_parameters
-xpdf-qt/moc_XpdfWidget.cpp_parameters
-xpdf-qt/moc_XpdfApp.cpp
-xpdf-qt/moc_XpdfViewer.cpp
-xpdf-qt/qrc_icons.cpp
-xpdf-qt/moc_XpdfWidget.cpp
-xpdf/pdfdetach
-xpdf/pdffonts
-xpdf/pdfimages
-xpdf/pdfinfo
-xpdf/pdftohtml
-xpdf/pdftopng
-xpdf/pdftoppm
-xpdf/pdftops
-xpdf/pdftotext
 CMakeCache.txt 
 CMakeFiles/
 aconf.h
diff --git a/CMakeLists.txt b/CMakeLists.txt
deleted file mode 100644
index a99cd25..0000000
--- a/CMakeLists.txt
+++ /dev/null
@@ -1,41 +0,0 @@
-#========================================================================
-#
-# cmake-xpdf.txt
-#
-# CMake script for the Xpdf package.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-cmake_minimum_required(VERSION 2.8.8)
-
-project(xpdf)
-
-include(cmake-config.txt)
-
-add_subdirectory(goo)
-add_subdirectory(fofi)
-add_subdirectory(splash)
-add_subdirectory(xpdf)
-add_subdirectory(xpdf-qt)
-
-if (NOT HAVE_FREETYPE_H)
-  message(WARNING "Couldn't find FreeType -- will not build pdftoppm, pdftopng, pdftohtml, or xpdf.")
-endif ()
-
-if (NOT PNG_FOUND)
-  message(WARNING "Couldn't find libpng -- will not build pdftopng or pdftohtml.")
-endif ()
-
-if (NOT QT4_FOUND AND NOT Qt5Widgets_FOUND)
-  message(WARNING "Couldn't find Qt4 or Qt5 -- will not build xpdf.")
-endif ()
-
-if (NOT MULTITHREADED)
-  message(WARNING "Multithreading is disabled -- will not build xpdf.")
-endif ()
-
-if (NOT USE_EXCEPTIONS)
-  message(WARNING "C++ exceptions are disabled -- will not build xpdf.")
-endif ()
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 0000000..6224dd2
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,16 @@
+AUTOMAKE_OPTIONS = foreign
+ACLOCAL_AMFLAGS = -I m4
+
+SUBDIRS = doc fofi goo splash xpdf xpdf-qt
+
+EXTRA_DIST = \
+	COPYING \
+	COPYING3 \
+	ANNOUNCE \
+	CHANGES \
+	INSTALL \
+	README \
+	aconf2.h \
+	$(empty)
+
+DISTCLEANFILES = intltool-merge intltool-extract intltool-update
diff --git a/aconf.h.in b/aconf.h.in
deleted file mode 100644
index b526440..0000000
--- a/aconf.h.in
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * aconf.h
- *
- * This file is modified by cmake.
- *
- * Copyright 2002-2015 Glyph & Cog, LLC
- */
-
-#ifndef ACONF_H
-#define ACONF_H
-
-#include <aconf2.h>
-
-/*
- * Use A4 paper size instead of Letter for PostScript output.
- */
-#cmakedefine A4_PAPER
-
-/*
- * Do not allow text selection.
- */
-#cmakedefine NO_TEXT_SELECT
-
-/*
- * Include support for OPI comments.
- */
-#cmakedefine01 OPI_SUPPORT
-
-/*
- * Enable multithreading support.
- */
-#cmakedefine01 MULTITHREADED
-
-/*
- * Enable C++ exceptions.
- */
-#cmakedefine01 USE_EXCEPTIONS
-
-/*
- * Use fixed point (instead of floating point) arithmetic.
- */
-#cmakedefine01 USE_FIXEDPOINT
-
-/*
- * Enable support for CMYK output.
- */
-#cmakedefine01 SPLASH_CMYK
-
-/*
- * Enable support for DeviceN output.
- */
-#cmakedefine01 SPLASH_DEVICEN
-
-/*
- * Enable support for highlighted regions.
- */
-#cmakedefine HIGHLIGHTED_REGIONS
-
-/*
- * Full path for the system-wide xpdfrc file.
- */
-@SYSTEM_XPDFRC_DEFINE@
-
-/*
- * Various include files and functions.
- */
-#cmakedefine01 HAVE_MKSTEMP
-#cmakedefine01 HAVE_MKSTEMPS
-#cmakedefine HAVE_POPEN
-#cmakedefine01 HAVE_STD_SORT
-#cmakedefine01 HAVE_FSEEKO
-#cmakedefine01 HAVE_FSEEK64
-#cmakedefine01 HAVE_FSEEKI64
-#define _FILE_OFFSET_BITS 64
-#define _LARGE_FILES 1
-#define _LARGEFILE_SOURCE 1
-
-/*
- * This is defined if using FreeType 2.
- */
-#cmakedefine01 HAVE_FREETYPE_H
-
-/*
- * This is defined if using D-Type 4.
- */
-#cmakedefine01 HAVE_DTYPE4_H
-
-/*
- * This is defined if using libpaper.
- */
-#cmakedefine01 HAVE_PAPER_H
-
-/*
- * Defined if the Splash library is avaiable.
- */
-#cmakedefine01 HAVE_SPLASH
-
-/*
- * Defined if using lcms2.
- */
-#cmakedefine01 HAVE_LCMS
-
-/*
- * Defined for evaluation mode.
- */
-#cmakedefine01 EVAL_MODE
-
-/*
- * Defined when building the closed source XpdfReader binary.
- */
-#cmakedefine01 BUILDING_XPDFREADER
-
-#endif
diff --git a/aconf2.h b/aconf2.h
deleted file mode 100644
index 8bef688..0000000
--- a/aconf2.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * aconf2.h
- *
- * This gets included by aconf.h, and contains miscellaneous global
- * settings not directly controlled by autoconf.  This is a separate
- * file because otherwise the configure script will munge any
- * #define/#undef constructs.
- *
- * Copyright 2002-2003 Glyph & Cog, LLC
- */
-
-#ifndef ACONF2_H
-#define ACONF2_H
-
-/*
- * This controls the use of the interface/implementation pragmas.
- */
-#if defined(__GNUC__) && !defined(__clang__)
-#define USE_GCC_PRAGMAS
-#endif
-/* There is a bug in the version of gcc which ships with MacOS X 10.2 */
-#if defined(__APPLE__) && defined(__MACH__)
-#  include <AvailabilityMacros.h>
-#endif
-#ifdef MAC_OS_X_VERSION_MAX_ALLOWED
-#  if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2
-#    undef USE_GCC_PRAGMAS
-#  endif
-#endif
-
-#endif
diff --git a/cmake-config.txt b/cmake-config.txt
deleted file mode 100644
index 1fbd6e5..0000000
--- a/cmake-config.txt
+++ /dev/null
@@ -1,257 +0,0 @@
-#========================================================================
-#
-# cmake-config.txt
-#
-# CMake script to do misc cmake config and platform-specific config.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-include(CheckFunctionExists)
-include(CheckCXXSourceCompiles)
-include(GNUInstallDirs)
-
-enable_language(CXX)
-
-#--- set default C/C++ compiler flags for Unix
-#    and add a 'Profiling' build mode
-if (CMAKE_GENERATOR STREQUAL "Unix Makefiles")
-  if (CYGWIN)
-    set(PIC_FLAG "")
-  elseif (CMAKE_HOST_SYSTEM_NAME MATCHES "AIX")
-    set(PIC_FLAG "-qPIC")
-  else ()
-    set(PIC_FLAG "-fPIC")
-  endif ()
-  set(CMAKE_C_FLAGS_DEBUG "-g -O -Wall ${PIC_FLAG}")
-  set(CMAKE_CXX_FLAGS_DEBUG "-g -O -Wall ${PIC_FLAG}")
-  set(CMAKE_EXE_LINKER_FLAGS_DEBUG "-g -O -Wall ${PIC_FLAG}")
-  set(CMAKE_C_FLAGS_RELEASE "-O3 -Wall ${PIC_FLAG}")
-  set(CMAKE_CXX_FLAGS_RELEASE "-O3 -Wall ${PIC_FLAG}")
-  set(CMAKE_EXE_LINKER_FLAGS_RELEASE "-O2 -Wall ${PIC_FLAG}")
-  set(CMAKE_C_FLAGS_PROFILING "-g -pg -O -Wall ${PIC_FLAG}"
-      CACHE STRING "C compiler flags for profiling mode")
-  set(CMAKE_CXX_FLAGS_PROFILING "-g -pg -O -Wall ${PIC_FLAG}"
-      CACHE STRING "C++ compiler flags for profiling mode")
-  set(CMAKE_EXE_LINKER_FLAGS_PROFILING "-g -pg -O -Wall ${PIC_FLAG}"
-      CACHE STRING "linker flags for profiling mode")
-  mark_as_advanced(
-    CMAKE_C_FLAGS_PROFILING
-    CMAKE_CXX_FLAGS_PROFILING
-    CMAKE_EXE_LINKER_FLAGS_PROFILING)
-  set(CMAKE_BUILD_TYPE "${CMAKE_BUILD_TYPE}" CACHE STRING
-      "Choose build mode - options are: None Debug Release RelWithDebInfo MinSiz
-eRel Profiling")
-endif ()
-
-#--- set default C/C++ compiler flags for Windows
-if (WIN32)
-  foreach (var CMAKE_C_FLAGS_DEBUG CMAKE_CXX_FLAGS_DEBUG
-               CMAKE_C_FLAGS_RELEASE CMAKE_CXX_FLAGS_RELEASE
-               CMAKE_C_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_MINSIZEREL
-               CMAKE_C_FLAGS_RELWITHDEBINFO CMAKE_CXX_FLAGS_RELWITHDEBINFO)
-    # note: this converts /MD to /MT and /MDd to /MTd
-    string(REGEX REPLACE "/MD" "/MT" ${var} "${${var}}")
-  endforeach ()
-  set(CMAKE_EXE_LINKER_FLAGS_DEBUG "/NODEFAULTLIB:libcmt ${CMAKE_EXE_LINKER_FLAGS_DEBUG}")
-  set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "/NODEFAULTLIB:libcmt ${CMAKE_SHARED_LINKER_FLAGS_DEBUG}")
-  foreach (var CMAKE_C_FLAGS_DEBUG
-               CMAKE_C_FLAGS_RELEASE
-               CMAKE_C_FLAGS_MINSIZEREL
-               CMAKE_C_FLAGS_RELWITHDEBINFO)
-    set(${var} "${${var}} /D_CRT_SECURE_NO_WARNINGS /wd4290 /wd4996")
-  endforeach ()
-  foreach (var CMAKE_CXX_FLAGS_DEBUG
-               CMAKE_CXX_FLAGS_RELEASE
-               CMAKE_CXX_FLAGS_MINSIZEREL
-               CMAKE_CXX_FLAGS_RELWITHDEBINFO)
-    set(${var} "${${var}} /D_CRT_SECURE_NO_WARNINGS /wd4290 /wd4996 /EHsc")
-  endforeach ()
-endif ()
-
-#--- don't set an rpath
-set(CMAKE_SKIP_RPATH FALSE)
-
-#--- miscellaneous options
-option(A4_PAPER "use A4 (instead of Letter) paper size by default for PostScript output" OFF)
-option(NO_TEXT_SELECT "do not allow text selection" OFF)
-option(OPI_SUPPORT "include support for OPI comments" OFF)
-option(MULTITHREADED "include support for multithreading" ON)
-option(USE_EXCEPTIONS "use C++ exceptions" ON)
-option(USE_FIXEDPOINT "use fixed point (instead of floating point) arithmetic" OFF)
-option(SPLASH_CMYK "include support for CMYK rasterization" OFF)
-option(SYSTEM_XPDFRC "full path for system-wide xpdfrc file" "")
-if (SYSTEM_XPDFRC)
-  set(SYSTEM_XPDFRC_DEFINE "#define SYSTEM_XPDFRC \"${SYSTEM_XPDFRC}\"")
-else ()
-  set(SYSTEM_XPDFRC_DEFINE "/* #undef SYSTEM_XPDFRC */")
-endif ()
-if (WIN32)
-  option(XPDFWIDGET_PRINTING "include printing support in XpdfWidget" OFF)
-else ()
-  option(XPDFWIDGET_PRINTING "include printing support in XpdfWidget" ON)
-endif ()
-
-#--- check for various library functions
-check_function_exists(mkstemp HAVE_MKSTEMP)
-check_function_exists(mkstemps HAVE_MKSTEMPS)
-check_function_exists(popen HAVE_POPEN)
-check_cxx_source_compiles(
-    "#include <algorithm>
-    bool cmp(const int &x, const int &y) { return x < y; }
-    int a[100];
-    int main() { std::sort(a, a+100, &cmp); }"
-  HAVE_STD_SORT)
-
-#--- set up 64-bit file seeks
-check_function_exists(fseeko HAVE_FSEEKO)
-check_function_exists(fseek64 HAVE_FSEEK64)
-check_function_exists(_fseeki64 HAVE_FSEEKI64)
-
-#--- look for FreeType
-# This could use cmake's FindFreetype, except that it would require
-# a newer version of cmake -- because FreeType changed their include
-# paths around.  Older versions of FreeType require two separate
-# -I switches (typically ..../include and ..../include/freetype2);
-# while newer versions require just one (typically ..../include/freetype2)
-find_path(FREETYPE_INCLUDE_DIR_ft2build ft2build.h
-  HINTS
-  ${FREETYPE_DIR}
-  PATHS
-  /usr/local/include
-  /usr/local/X11R6/include
-  /usr/local/X11/include
-  /usr/freeware/include
-  PATH_SUFFIXES freetype2 include/freetype2 include
-)
-find_path(FREETYPE_INCLUDE_DIR_freetype freetype.h
-  HINTS
-  ${FREETYPE_DIR}
-  PATHS
-  /usr/local/include
-  /usr/local/X11R6/include
-  /usr/local/X11/include
-  /usr/freeware/include
-  PATH_SUFFIXES freetype2 include/freetype2 include
-)
-find_path(FREETYPE_INCLUDE_DIR_freetype_freetype freetype/freetype.h
-  HINTS
-  ${FREETYPE_DIR}
-  PATHS
-  /usr/local/include
-  /usr/local/X11R6/include
-  /usr/local/X11/include
-  /usr/freeware/include
-  PATH_SUFFIXES freetype2 include/freetype2 include
-)
-find_library(FREETYPE_LIBRARY
-  NAMES freetype libfreetype freetype2 freetype219
-  HINTS
-  ${FREETYPE_DIR}
-  PATH_SUFFIXES lib64 lib
-  PATHS
-  /usr/local
-  /usr/local/X11R6
-  /usr/local/X11
-  /usr/freeware
-)
-if (FREETYPE_INCLUDE_DIR_ft2build
-    AND FREETYPE_INCLUDE_DIR_freetype
-    AND (FREETYPE_INCLUDE_DIR_ft2build STREQUAL FREETYPE_INCLUDE_DIR_freetype)
-    AND FREETYPE_LIBRARY)
-  set(FREETYPE_INCLUDE_DIRS "${FREETYPE_INCLUDE_DIR_ft2build}")
-  set(HAVE_FREETYPE_H TRUE)
-  message(STATUS "Found FreeType (new-style includes): ${FREETYPE_LIBRARY}")
-elseif (FREETYPE_INCLUDE_DIR_ft2build
-        AND FREETYPE_INCLUDE_DIR_freetype_freetype
-        AND FREETYPE_LIBRARY)
-  set(FREETYPE_INCLUDE_DIRS
-      "${FREETYPE_INCLUDE_DIR_ft2build};${FREETYPE_INCLUDE_DIR_freetype_freetype}")
-  set(HAVE_FREETYPE_H TRUE)
-  message(STATUS "Found FreeType (old-style includes): ${FREETYPE_LIBRARY}")
-else ()
-  message(STATUS "FreeType not found")
-endif ()
-if (HAVE_FREETYPE_H)
-  set(HAVE_SPLASH TRUE)
-endif ()
-
-
-#--- look for zlib
-find_package(ZLIB)
-
-#--- look for libpng
-find_package(PNG)
-
-
-
-
-#--- look for Qt
-find_package(Qt5Widgets QUIET)
-if (Qt5Widgets_FOUND)
-  find_package(Qt5Network)
-  find_package(Qt5PrintSupport)
-else ()
-  find_package(Qt4)
-endif ()
-if(Qt5Widgets_FOUND)
-  message(STATUS "Qt5 found")
-  if (XPDFWIDGET_PRINTING)
-    set(QT_INCLUDES "${Qt5Widgets_INCLUDE_DIRS} ${Qt5Network_INCLUDE_DIRS} ${Qt5PrintSupport_INCLUDE_DIRS}")
-    set(QT_DEFINITIONS "${Qt5Widgets_DEFINITIONS} ${Qt5Network_DEFINITIONS} ${Qt5PrintSupport_DEFINITIONS}")
-    if (APPLE)
-      set(QT_LIBRARIES Qt5::Widgets Qt5::Network Qt5::PrintSupport "-framework ApplicationServices")
-    elseif (UNIX)
-      set(QT_LIBRARIES Qt5::Widgets Qt5::Network Qt5::PrintSupport cups)
-    else ()
-      set(QT_LIBRARIES Qt5::Widgets Qt5::Network Qt5::PrintSupport)
-    endif ()
-  else ()
-    set(QT_INCLUDES "${Qt5Widgets_INCLUDE_DIRS} ${Qt5Network_INCLUDE_DIRS}")
-    set(QT_DEFINITIONS "${Qt5Widgets_DEFINITIONS} ${Qt5Network_DEFINITIONS}")
-    set(QT_LIBRARIES Qt5::Widgets Qt5::Network)
-  endif ()
-  if (XPDFWIDGET_PRINTING)
-    if (APPLE)
-      set(EXTRA_QT_LIBRARIES "-framework ApplicationServices")
-    elseif (UNIX)
-      set(EXTRA_QT_LIBRARIES cups)
-    else ()
-      set(EXTRA_QT_LIBRARIES "")
-    endif ()
-  endif ()
-  # remove "-fPIE" here because we added "-fPIC" above
-  string(REPLACE "-fPIE" "" QT_CFLAGS "${Qt5Widgets_EXECUTABLE_COMPILE_FLAGS}")
-elseif(QT4_FOUND)
-  message(STATUS "Qt4 found")
-  if (XPDFWIDGET_PRINTING)
-    if (APPLE)
-      set(EXTRA_QT_LIBRARIES "-framework ApplicationServices")
-    elseif (UNIX)
-      set(EXTRA_QT_LIBRARIES cups)
-    else ()
-      set(EXTRA_QT_LIBRARIES "")
-    endif ()
-  endif ()
-else()
-  message(STATUS "No Qt library found")
-endif()
-
-#--- look for libpaper
-find_library(PAPER_LIBRARY
-             NAMES paper libpaper
-             PATH_SUFFIXES lib64 lib
-)
-if (PAPER_LIBRARY)
-  set(HAVE_PAPER_H TRUE)
-else ()
-  set(HAVE_PAPER_H FALSE)
-  set(PAPER_LIBRARY "")
-endif ()
-
-#--- look for pthreads
-find_package(Threads)
-
-#--- create aconf.h
-configure_file("aconf.h.in" "aconf.h")
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..7fc9dee
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,551 @@
+dnl configure.ac, used by autoconf
+dnl to create the configure script
+dnl @(#) Thorsten Otto, 26.04.2019
+dnl
+AC_PREREQ(2.52)
+
+AC_INIT(xpdf, 4.01.01, [https://www.xpdfreader.com/],,[https://www.xpdfreader.com/])
+AC_CONFIG_SRCDIR(xpdf/Gfx.cc)
+
+AC_CONFIG_MACRO_DIR([m4])
+AC_CONFIG_AUX_DIR(build-aux)
+
+###############################################################################
+#
+#       Autoheader stuff
+#
+###############################################################################
+
+AH_TOP([
+#ifndef ACONF_H
+#define ACONF_H
+
+])
+
+AH_BOTTOM([
+/*
+ * This gets included by aconf.h, and contains miscellaneous global
+ * settings not directly controlled by autoconf.  This is a separate
+ * file because otherwise the configure script will munge any
+ * #define/#undef constructs.
+ *
+ * Copyright 2002-2003 Glyph & Cog, LLC
+ */
+
+#endif /* ACONF_H */
+])
+
+AC_CANONICAL_HOST
+
+if test "$ECHO_E" = ""; then
+  ECHO_E="echo -e"
+fi
+AC_SUBST(ECHO_E)
+
+AC_CONFIG_HEADER(aconf.h)
+
+AM_INIT_AUTOMAKE
+AM_MAINTAINER_MODE([enable])
+
+m4_define([AC_ADD_CFLAG], [
+for flag in $2; do
+case " [$]$1 " in
+"* $flag *") ;;
+*) AC_MSG_CHECKING([whether the compiler understands] $flag)
+   saved_$1="[$]$1"
+   $1="[$]$1 $flag"
+   AC_TRY_COMPILE(, , result=yes, $1="$saved_$1"; result=no)
+   AC_MSG_RESULT([$result])
+   ;;
+esac
+done
+])
+
+###############################################################################
+#
+#       Shortcut for AC_ARG_ENABLE
+#
+###############################################################################
+
+m4_define(ac_option_ucase, [translit($1,-abcdefghijklmnopqrstuvwxyz,_ABCDEFGHIJKLMNOPQRSTUVWXYZ)])dnl
+m4_define(ac_option_lcase, [translit($1,-ABCDEFGHIJKLMNOPQRSTUVWXYZ,_abcdefghijklmnopqrstuvwxyz)])dnl
+
+# AH_OPTION(OPTION, DESC, DEFAULT, DEFINE)
+# ----------------------------------------
+AC_DEFUN([AC_OPTION], [
+AH_TEMPLATE([ac_option_ucase($1)], [$2])
+AC_ARG_ENABLE($1,
+[AC_HELP_STRING(--m4_case($3,,enable,no,enable,yes,disable,must-be-yes-or-no)-[]$1, [$2])],
+[case [$]enableval in
+yes|no)
+     enable_[]ac_option_lcase($1)=[$]enableval
+     ;;
+*)   AC_MSG_ERROR([must be yes or no: --enable-[]$1=[$]enableval]) ;;
+esac
+], [enable_[]ac_option_lcase($1)=m4_case($3,,no,$3)])
+if test "[$]enable_[]ac_option_lcase($1)" = "yes"; then
+     AC_DEFINE(ac_option_ucase(m4_case($4,,$1,$4)))
+fi
+])
+
+###############################################################################
+###############################################################################
+#
+#       End of function definitions.  Now start actually executing stuff.
+#
+###############################################################################
+###############################################################################
+
+# stuff for Makefiles
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+AC_PROG_RANLIB
+AC_CHECK_TOOL(STRIP, strip, :)
+
+# Support silent build rules, requires at least automake-1.11. Disable
+# by either passing --disable-silent-rules to configure or passing V=1
+# to make
+m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])])
+
+AC_PROG_CC
+AC_EXEEXT
+AC_C_CONST
+AC_PROG_CC_C_O
+AX_PROG_CC_FOR_BUILD
+PKG_PROG_PKG_CONFIG
+
+###############################################################################
+#
+# Early compiler setup.
+#
+###############################################################################
+
+TARGET_OS=unix
+case $host in
+  *-*-mingw*|*-*-msys*|*-*-MINGW*|*-*-MSYS*|*-*-cygwin*|*-*-CYGWIN*)
+     test "$CC" = "" && CC=gcc
+     test "$CXX" = "" && CXX="g++"
+     for arg in -mms-bitfields -mno-cygwin -mwin32 -mthreads; do
+        case $CC in
+        *$arg*) ;;
+        *) if $CC $arg -E - < /dev/null >/dev/null 2>&1; then
+             echo adding $arg to $CC
+             CC="$CC $arg"
+             CXX="$CXX $arg"
+           fi
+        esac
+     done
+     TARGET_OS=win32
+     LIBS="-lole32"
+     case $host in
+  	x86_64-*-*) RC_TARGET=pe-x86-64 ;;
+	*) RC_TARGET=pe-i386 ;;
+     esac
+     ;;
+  *-apple-darwin* )
+     test "$CC" = "" && CC=gcc
+     test "$CXX" = "" && CXX="g++"
+     for arg in -fno-writable-strings -mmacosx-version-min=10.6; do
+        case $CC in
+        *$arg*) ;;
+        *) if $CC $arg -E - < /dev/null >/dev/null 2>&1; then
+             echo adding $arg to $CC
+             CC="$CC $arg"
+             CXX="$CXX $arg"
+           fi
+        esac
+     done
+     ECHO_E="echo"
+     CFLAGS="$CFLAGS $CPROJECTFLAGS"
+     LDFLAGS="$LDFLAGS $LDPROJECTFLAGS"
+     TARGET_OS=mac
+     ;;
+  m68k*-*-mint* | *-atarist-* )
+     TARGET_OS=tos
+     ;;
+  *)
+     ;;
+esac
+AC_SUBST(RC_TARGET)
+
+if test "$cross_compiling" = no; then
+  # do not consider this as a native build only because we can exec build programs;
+  # it might just be a binfmt handler that makes this possible
+  case $build in *-*-linux*)
+     case $host in
+     *-*-linux*) ;;
+     *) cross_compiling=yes ;;
+     esac
+  esac
+fi
+
+AC_ARG_ENABLE(warnings,
+[AC_HELP_STRING(--enable-warnings, [enable compiler warnings])],
+[case $enableval in
+yes)
+     for arg in -Wall -W -Wstrict-prototypes -Wmissing-prototypes \
+           -Wmissing-declarations -Wwrite-strings \
+           -Wcast-qual -Wdeclaration-after-statement -Wundef -Wc++-compat -Wno-nonnull-compare
+     do
+         AC_ADD_CFLAG(CFLAGS, $arg)
+     done
+     for arg in -Wall -W -Wmissing-declarations -Wwrite-strings \
+           -Wcast-qual -Wundef -Wno-nonnull-compare
+     do
+         AC_ADD_CFLAG(CXXFLAGS, $arg)
+     done
+     ;;
+no)  ;;
+*)   AC_MSG_ERROR([must be yes or no: --enable-warnings=$enableval]) ;;
+esac
+])
+
+AC_ARG_ENABLE(fatal-warnings,
+[AC_HELP_STRING(--enable-fatal-warnings, [Turn compiler warnings into errors [default=disabled]])],
+[case $enableval in
+yes) enable_fatal_warnings=yes
+     ;;
+no)  enable_fatal_warnings=no
+     ;;
+*)   AC_MSG_ERROR([must be yes or no: --enable-fatal-warnings=$enableval]) ;;
+esac
+], [enable_fatal_warnings=no])
+
+AM_CONDITIONAL(OS_WIN32, test "$TARGET_OS" = "win32")
+AM_CONDITIONAL(OS_TOS, test "$TARGET_OS" = "tos")
+AM_CONDITIONAL(OS_UNIX, test "$TARGET_OS" = "unix")
+AM_CONDITIONAL(OS_MACOS, test "$TARGET_OS" = "mac")
+AM_CONDITIONAL(CROSS_COMPILING, test "$cross_compiling" != no)
+
+dnl ##### Switch over to C++.  This will make the checks below a little
+dnl ##### bit stricter (requiring function prototypes in include files).
+dnl ##### (99% of xpdf is written in C++.)
+AC_LANG_CPLUSPLUS
+
+AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h string.h strings.h unistd.h process.h sys/param.h endian.h io.h fcntl.h dlfcn.h pwd.h wchar.h])
+
+AC_CHECK_FUNCS([popen mktemp mkstemp mkstemps fseeko fseek64 _fseeki64])
+
+AC_CHECK_LIB(m, log)
+
+###############################################################################
+# miscellaneous options
+###############################################################################
+
+AH_TEMPLATE([A4_PAPER], [use A4 (instead of Letter) paper size by default for PostScript output])
+AC_OPTION(a4-paper, [use A4 (instead of Letter) paper size by default for PostScript output], no)
+AH_TEMPLATE([NO_TEXT_SELECT], [do not allow text selection])
+AC_OPTION(no-text-select, [do not allow text selection], no)
+AH_TEMPLATE([OPI_SUPPORT], [include support for OPI comments])
+AC_OPTION(opi, [include support for OPI comments], no, [OPI_SUPPORT])
+AH_TEMPLATE([MULTITHREADED], [include support for multithreading])
+AC_OPTION(multithreaded, [include support for multithreading], yes)
+if test "$enable_multithreaded" = yes; then
+	AX_PTHREAD
+fi
+AM_CONDITIONAL(MULTITHREADED, test "$enable_multithreaded" = yes)
+AH_TEMPLATE([USE_EXCEPTIONS], [use C++ exceptions])
+AC_OPTION(exceptions, [use C++ exceptions], yes, [USE_EXCEPTIONS])
+AM_CONDITIONAL(USE_EXCEPTIONS, test "$enable_exceptions" = yes)
+AH_TEMPLATE([USE_FIXEDPOINT], [use fixed point (instead of floating point) arithmetic])
+AC_OPTION(fixedpoint, [use fixed point (instead of floating point) arithmetic], yes, [USE_FIXEDPOINT])
+AH_TEMPLATE([SPLASH_CMYK], [include support for CMYK rasterization])
+AC_OPTION(cmyk, [include support for CMYK rasterization], yes, [SPLASH_CMYK])
+AH_TEMPLATE([SPLASH_DEVICEN], [Enable support for DeviceN output.])
+AC_OPTION(devicen, [Enable support for DeviceN output.], yes, [SPLASH_DEVICEN])
+AH_TEMPLATE([XPDFWIDGET_PRINTING], [include printing support in XpdfWidget])
+AC_OPTION(xpdfwidget-printing, [include printing support in XpdfWidget], yes)
+if test "$TARGET_OS" = "win32 -a ! -f "$srcdir/xpdf/WinPDFPrinter.cc -a "$enable_xpdfwidget_printing" = yes; then
+	AC_MSG_WARN([printing support not available on this platform])
+	enable_xpdfwidget_printing=no
+fi
+AM_CONDITIONAL(XPDFWIDGET_PRINTING, test "$enable_xpdfwidget_printing" = yes)
+
+
+# HighlightFile.cc missing from source package?
+AH_TEMPLATE([HIGHLIGHTED_REGIONS], [Enable support for highlighted regions.])
+#AC_OPTION(highlighted-regions, [Enable support for highlighted regions.], yes)
+AM_CONDITIONAL(HIGHLIGHTED_REGIONS, test "$enable_highlighted_regions" = yes)
+
+
+AH_TEMPLATE([APPDEFDIR], [directory name for application defaults])
+AC_ARG_WITH([appdef-dir],
+  AS_HELP_STRING([--with-appdef-dir],
+                 [set app-defaults directory]))
+if test "$with_appdef_dir" != "no" -a "$with_appdef_dir" != "yes"; then
+      AC_DEFINE_UNQUOTED(APPDEFDIR, "$with_appdef_dir")
+fi
+
+dnl ##### Path to xpdfrc.
+dnl This ugly kludge to get the sysconfdir path is needed because
+dnl autoconf does not actually set the prefix variable until later.
+if test "$sysconfdir" = '${prefix}/etc'; then
+  if test "x$prefix" = xNONE; then
+    system_xpdfrc="$ac_default_prefix/etc/xpdfrc"
+  else
+    system_xpdfrc="$prefix/etc/xpdfrc"
+  fi
+else
+  system_xpdfrc="$sysconfdir/xpdfrc"
+fi
+AC_DEFINE_UNQUOTED(SYSTEM_XPDFRC, "$system_xpdfrc", [directory for system wide xpdfrc])
+
+###############################################################################
+#
+# check for libpng
+#
+###############################################################################
+
+AH_TEMPLATE([HAVE_LIBPNG],
+	    [Define this if the Portable Network Graphics library is installed.
+	    It is basically required, but many things will more-or-less limp
+	    along without it.])
+
+PKG_CHECK_MODULES(PNG, libpng, have_libpng=yes, have_libpng=no)
+if test "$have_libpng" = yes; then
+  AC_DEFINE([HAVE_LIBPNG])
+fi
+AM_CONDITIONAL(HAVE_LIBPNG, test "$have_libpng" = yes)
+
+###############################################################################
+#
+#       Check for freetype
+#
+###############################################################################
+
+AH_TEMPLATE([HAVE_FREETYPE], [This is defined if using FreeType 2.])
+
+PKG_CHECK_MODULES(FREETYPE2, freetype2, have_freetype=yes, have_freetype=no)
+if test "$have_freetype" = yes; then
+  AC_DEFINE([HAVE_FREETYPE])
+  AC_DEFINE([HAVE_SPLASH], 1, [Defined if the Splash library is avaiable.])
+fi
+AM_CONDITIONAL(HAVE_FREETYPE, test "$have_freetype" = yes)
+AM_CONDITIONAL(HAVE_SPLASH, test "$have_freetype" = yes)
+dnl this can get wrong if PKG_CONFIG_PATH is not set
+if test "$TARGET_OS" = tos; then
+   FREETYPE2_LIBS="-lfreetype -lpng -lbz2 -lz"
+   FREETYPE2_CFLAGS=""
+fi
+
+###############################################################################
+#
+#       Check for lcms
+#
+###############################################################################
+
+# ColorManager.cc missing from source package?
+#PKG_CHECK_MODULES(LCMS, lcms2, have_lcms=yes, have_lcms=no)
+have_lcms=no
+AH_TEMPLATE([HAVE_LCMS], [Defined if using lcms2.])
+AM_CONDITIONAL(HAVE_LCMS, test "$have_lcms" = yes)
+
+###############################################################################
+#
+#       Check for qt5
+#
+###############################################################################
+
+have_qt4=no
+have_qt5=no
+qt5_libs="Qt5Widgets Qt5Network Qt5Gui Qt5Core"
+if test "$enable_xpdfwidget_printing" = yes; then
+	qt5_libs="$qt5_libs Qt5PrintSupport"
+fi
+PKG_CHECK_MODULES(QT, [$qt5_libs], have_qt5=yes, have_qt5=no)
+dnl this can get wrong if PKG_CONFIG_PATH is not set
+if test "$TARGET_OS" = tos; then
+  QT_LIBS=
+  QT_CFLAGS=
+  have_qt5=no
+fi
+# separate variable with defines and includes only,
+# which is also passed to moc
+QT_DEFS="$QT_CFLAGS"
+case $TARGET_OS in
+unix)
+	if test "$have_qt5" = yes; then
+		QT_CFLAGS="$QT_CFLAGS -fPIC -std=gnu++11"
+		if test "$enable_xpdfwidget_printing" = yes; then
+			QT_LIBS="$QT_LIBS -lcups"
+		fi
+	fi
+	;;
+mac)
+	if test "$have_qt5" = yes; then
+		if test "$enable_xpdfwidget_printing" = yes; then
+			QT_LIBS="$QT_LIBS -framework ApplicationServices"
+		fi
+	fi
+	;;
+win32)
+	;;
+esac
+if test "$have_qt5" = yes; then
+	if test "$enable_xpdfwidget_printing" = yes; then
+		QT_DEFS="$QT_DEFS -DXPDFWIDGET_PRINTING"
+	fi
+	MOC=moc-qt5
+	RCC=rcc-qt5
+fi
+AC_SUBST(QT_CFLAGS)
+AC_SUBST(QT_DEFS)
+AC_SUBST(QT_LIBS)
+AC_SUBST(MOC)
+AC_SUBST(RCC)
+AM_CONDITIONAL(HAVE_QT, test "$have_qt5" = yes -o "$have_qt4" = yes)
+
+###############################################################################
+#
+#       look for libpaper
+#
+###############################################################################
+
+AC_CHECK_LIB(paper, paperinit)
+AC_CHECK_HEADERS([paper.h])
+
+###############################################################################
+#
+#       Check for std::sort.
+#
+###############################################################################
+
+AH_TEMPLATE([HAVE_STD_SORT], [define if you have std::sort])
+AC_CACHE_CHECK([for std::sort],
+xpdf_cv_func_std_sort,
+[AC_LANG_PUSH([C++])
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([[#include <algorithm>
+struct functor {
+  bool operator()(const int &i0, const int &i1) { return i0 < i1; }
+};]],
+                  [[int a[100];
+std::sort(a, a+100, functor());]])],
+xpdf_cv_func_std_sort=yes, xpdf_cv_func_std_sort=no)
+AC_LANG_POP()])
+if test "$xpdf_cv_func_std_sort" = yes; then
+  AC_DEFINE(HAVE_STD_SORT)
+fi
+
+###############################################################################
+#
+###############################################################################
+
+AH_TEMPLATE([EVAL_MODE], [Defined for evaluation mode.])
+AH_TEMPLATE([BUILDING_XPDFREADER], [Defined when building the closed source XpdfReader binary.])
+
+###############################################################################
+#
+#       Print some warnings at the end.
+#
+###############################################################################
+
+warn_prefix_1="    Warning:"
+warn_prefix_2="       Note:"
+warn_prefix="$warn_prefix_1"
+
+warning=no
+warnsep='    #################################################################'
+
+warnpre() {
+  if test "$warning" = no ; then
+    echo '' ; echo "$warnsep" ; echo ''
+    warning=yes
+  fi
+}
+
+warn() {
+  warnpre
+  if test "$warning" = long ; then echo '' ; fi
+  warning=yes
+  rest="$@"
+  echo "$warn_prefix $rest"
+}
+
+warnL() {
+  was=$warning
+  warnpre
+  warning=yes
+  if test "$was" != no ; then echo '' ; fi
+  rest="$@"
+  echo "$warn_prefix $rest"
+}
+
+warn2() {
+  rest="$@"
+  echo "             $rest"
+  warning=long
+}
+
+note() {
+  warn_prefix="$warn_prefix_2"
+  warn $@
+  warn_prefix="$warn_prefix_1"
+}
+
+noteL() {
+  warn_prefix="$warn_prefix_2"
+  warnL $@
+  warn_prefix="$warn_prefix_1"
+}
+
+
+if test "$have_png" = no ; then
+  noteL 'The PNG library was not found.'
+  warn2 "will not build pdftopng or pdftohtml."
+fi
+
+if test "$have_freetype" = no ; then
+  noteL 'The freetype library was not found.'
+  warn2 "will not build pdftoppm, pdftopng, pdftohtml, or xpdf."
+fi
+
+if test "$have_qt4" = no -a "$have_qt5" = no; then
+  warnL 'Could not find Qt4 or Qt5.'
+  warn2 'Will not build xpdf.'
+fi
+
+if test "$enable_multithreaded" = no; then
+  warnL 'Multithreading is disabled.'
+  warn2 'Will not build xpdf.'
+fi
+
+if test "$enable_exceptions" = no; then
+  warnL 'C++ exceptions are disabled.'
+  warn2 'Will not build xpdf.'
+fi
+
+if test "$warn_static_shared" != ""; then
+  warnL "both --disable-static and --disable-shared given,"
+  warn2 "using static libraries"
+fi
+
+if test "$warning" != no; then
+  echo '' ; echo "$warnsep" ; echo ''
+fi
+
+
+###############################################################################
+#
+#       spit out Makefiles
+#
+###############################################################################
+
+AC_CONFIG_COMMANDS_PRE([
+if test "$GCC" = "yes" -a "$enable_fatal_warnings" = "yes"; then
+	CFLAGS="$CFLAGS -Werror"
+	CXXFLAGS="$CXXFLAGS -Werror"
+	OBJCFLAGS="$OBJCFLAGS -Werror"
+fi
+])
+
+AC_OUTPUT([
+	Makefile
+	doc/Makefile
+	fofi/Makefile
+	goo/Makefile
+	splash/Makefile
+	xpdf/Makefile
+	xpdf-qt/Makefile
+])
diff --git a/doc/Makefile.am b/doc/Makefile.am
new file mode 100644
index 0000000..8b185b9
--- /dev/null
+++ b/doc/Makefile.am
@@ -0,0 +1,34 @@
+man1dir = $(mandir)/man1
+man5dir = $(mandir)/man5
+
+man1_FILES = \
+	pdfdetach.1 \
+	pdffonts.1 \
+	pdfimages.1 \
+	pdfinfo.1 \
+	pdftops.1 \
+	pdftotext.1 \
+	$(empty)
+if HAVE_LIBPNG
+if HAVE_FREETYPE
+man1_FILES += pdftohtml.1 pdftopng.1
+endif
+endif
+if HAVE_FREETYPE
+man1_FILES += pdftoppm.1
+endif
+if HAVE_QT
+if HAVE_FREETYPE
+if MULTITHREADED
+if USE_EXCEPTIONS
+man1_FILES += xpdf.1
+endif
+endif
+endif
+endif
+
+man5_FILES = \
+	xpdfrc.5 \
+	$(empty)
+
+EXTRA_DIST = sample-xpdfrc
diff --git a/doc/pdfdetach.cat b/doc/pdfdetach.cat
deleted file mode 100644
index 30fc3ce..0000000
--- a/doc/pdfdetach.cat
+++ /dev/null
@@ -1,92 +0,0 @@
-pdfdetach(1)                General Commands Manual               pdfdetach(1)
-
-
-
-NAME
-       pdfdetach  -  Portable  Document  Format  (PDF)  document embedded file
-       extractor (version 4.01)
-
-SYNOPSIS
-       pdfdetach [options] [PDF-file]
-
-DESCRIPTION
-       Pdfdetach lists or extracts embedded files (attachments) from a  Porta-
-       ble Document Format (PDF) file.
-
-CONFIGURATION FILE
-       Pdfdetach  reads  a  configuration  file at startup.  It first tries to
-       find the user's private config file, ~/.xpdfrc.  If that doesn't exist,
-       it looks for a system-wide config file, typically /usr/local/etc/xpdfrc
-       (but this location can be changed when  pdfinfo  is  built).   See  the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Some  of  the following options can be set with configuration file com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -list  List  all of the embedded files in the PDF file.  File names are
-              converted to the text encoding specified by the "-enc" switch.
-
-       -save number
-              Save the specified embedded file.  By  default,  this  uses  the
-              file  name  associated with the embedded file (as printed by the
-              "-list" switch); the file name can  be  changed  with  the  "-o"
-              switch.
-
-       -saveall
-              Save  all of the embedded files.  This uses the file names asso-
-              ciated with the  embedded  files  (as  printed  by  the  "-list"
-              switch).   By default, the files are saved in the current direc-
-              tory; this can be changed with the "-o" switch.
-
-       -o path
-              Set the file name used when saving an  embedded  file  with  the
-              "-save" switch, or the directory used by "-saveall".
-
-       -enc encoding-name
-              Sets  the encoding to use for text output (embedded file names).
-              The encoding-name must be defined with  the  unicodeMap  command
-              (see xpdfrc(5)).  This defaults to "Latin1" (which is a built-in
-              encoding).  [config file: textEncoding]
-
-       -opw password
-              Specify the owner password for the  PDF  file.   Providing  this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The pdfinfo software and documentation are copyright 1996-2019 Glyph  &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1),   pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1),  pdf-
-       fonts(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                     pdfdetach(1)
diff --git a/doc/pdffonts.cat b/doc/pdffonts.cat
deleted file mode 100644
index a1dab79..0000000
--- a/doc/pdffonts.cat
+++ /dev/null
@@ -1,118 +0,0 @@
-pdffonts(1)                 General Commands Manual                pdffonts(1)
-
-
-
-NAME
-       pdffonts - Portable Document Format (PDF) font analyzer (version 4.01)
-
-SYNOPSIS
-       pdffonts [options] [PDF-file]
-
-DESCRIPTION
-       Pdffonts  lists the fonts used in a Portable Document Format (PDF) file
-       along with various information for each font.
-
-       The following information is listed for each font:
-
-       name   the font name, exactly as given in  the  PDF  file  (potentially
-              including a subset prefix)
-
-       type   the font type -- see below for details
-
-       emb    "yes" if the font is embedded in the PDF file
-
-       sub    "yes" if the font is a subset
-
-       uni    "yes"  if  there  is an explicit "ToUnicode" map in the PDF file
-              (the absence of a ToUnicode map doesn't  necessarily  mean  that
-              the text can't be converted to Unicode)
-
-       prob   "X"  if  this  font  is likely to be problematic when converting
-              text to Unicode
-
-       object ID
-              the font dictionary object ID (number and generation)
-
-       location
-              the font location (see the -loc and -locPS options).
-
-       PDF files can contain the following types of fonts:
-
-              Type 1
-              Type 1C -- aka Compact Font Format (CFF)
-              Type 1C (OT) -- OpenType with 8-bit CFF data
-              Type 3
-              TrueType
-              TrueType (OT) -- OpenType with 8-bit TrueType data
-              CID Type 0 -- 16-bit font with no specified type
-              CID Type 0C -- 16-bit PostScript CFF font
-              CID Type 0C (OT) -- OpenType with CID CFF data
-              CID TrueType -- 16-bit TrueType font
-              CID TrueType (OT) -- OpenType with CID TrueType data
-
-CONFIGURATION FILE
-       Pdffonts reads a configuration file at startup.  It first tries to find
-       the  user's  private config file, ~/.xpdfrc.  If that doesn't exist, it
-       looks for a system-wide config  file,  typically  /usr/local/etc/xpdfrc
-       (but  this  location  can  be changed when pdffonts is built).  See the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many of the following options can be set with configuration  file  com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to analyze.
-
-       -loc   Shows additional information on the location of  the  font  that
-              will  be  used  when  the  PDF  file  is  rasterized (with xpdf,
-              pdftoppm, etc.).
-
-       -locPS Shows additional information on the location of  the  font  that
-              will  be used when the PDF file is converted to PostScript (with
-              pdftops).
-
-       -l number
-              Specifies the last page to analyze.
-
-       -opw password
-              Specify the owner password for the  PDF  file.   Providing  this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The pdffonts software and documentation are copyright 1996-2019 Glyph &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1),  pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1), pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                      pdffonts(1)
diff --git a/doc/pdfimages.cat b/doc/pdfimages.cat
deleted file mode 100644
index 0830f1d..0000000
--- a/doc/pdfimages.cat
+++ /dev/null
@@ -1,98 +0,0 @@
-pdfimages(1)                General Commands Manual               pdfimages(1)
-
-
-
-NAME
-       pdfimages  -  Portable  Document  Format (PDF) image extractor (version
-       4.01)
-
-SYNOPSIS
-       pdfimages [options] PDF-file image-root
-
-DESCRIPTION
-       Pdfimages saves images from a Portable Document Format  (PDF)  file  as
-       Portable  Pixmap  (PPM), Portable Graymap (PGM), Portable Bitmap (PBM),
-       or JPEG files.
-
-       Pdfimages reads the PDF file, scans one or more  pages,  PDF-file,  and
-       writes  one  PPM,  PGM,  PBM,  or JPEG file for each image, image-root-
-       nnnn.xxx, where nnnn is the image number and  xxx  is  the  image  type
-       (.ppm, .pgm, .pbm, .jpg).
-
-       NB:  pdfimages  extracts  the raw image data from the PDF file, without
-       performing any additional transforms.  Any  rotation,  clipping,  color
-       inversion, etc. done by the PDF content stream is ignored.
-
-CONFIGURATION FILE
-       Pdfimages  reads  a  configuration  file at startup.  It first tries to
-       find the user's private config file, ~/.xpdfrc.  If that doesn't exist,
-       it looks for a system-wide config file, typically /usr/local/etc/xpdfrc
-       (but this location can be changed when pdfimages is  built).   See  the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many  of  the following options can be set with configuration file com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to scan.
-
-       -l number
-              Specifies the last page to scan.
-
-       -j     Normally, all images are written as PBM (for monochrome images),
-              PGM (for grayscale images), or PPM  (for  color  images)  files.
-              With  this option, images in DCT format are saved as JPEG files.
-              All non-DCT images are saved in  PBM/PGM/PPM  format  as  usual.
-              (Inline images are always saved in PBM/PGM/PPM format.)
-
-       -raw   Write all images in PDF-native formats.  Most of the formats are
-              not standard image formats, so this option is  primarily  useful
-              as input to a tool that generates PDF files.  (Inline images are
-              always saved in PBM/PGM/PPM format.)
-
-       -list  Write a one-line summary to stdout for each image.  The  summary
-              provides  the  image file name, the page number, the image width
-              and height, the horizontal  and  vertical  resolution  (DPI)  as
-              drawn,  the  color space type, and the number of bits per compo-
-              nent (BPC).
-
-       -opw password
-              Specify the owner password for the  PDF  file.   Providing  this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The  pdfimages software and documentation are copyright 1998-2019 Glyph
-       & Cog, LLC.
-
-SEE ALSO
-       xpdf(1),  pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1),   pdf-
-       fonts(1), pdfdetach(1), pdftoppm(1), pdftopng(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                     pdfimages(1)
diff --git a/doc/pdfinfo.cat b/doc/pdfinfo.cat
deleted file mode 100644
index 6fce042..0000000
--- a/doc/pdfinfo.cat
+++ /dev/null
@@ -1,117 +0,0 @@
-pdfinfo(1)                  General Commands Manual                 pdfinfo(1)
-
-
-
-NAME
-       pdfinfo - Portable Document Format (PDF) document information extractor
-       (version 4.01)
-
-SYNOPSIS
-       pdfinfo [options] [PDF-file]
-
-DESCRIPTION
-       Pdfinfo prints the contents of the 'Info' dictionary (plus  some  other
-       useful information) from a Portable Document Format (PDF) file.
-
-       The 'Info' dictionary contains the following values:
-
-              title
-              subject
-              keywords
-              author
-              creator
-              producer
-              creation date
-              modification date
-
-       In addition, the following information is printed:
-
-              tagged (yes/no)
-              form (AcroForm / static XFA / dynamic XFA / none)
-              page count
-              encrypted flag (yes/no)
-              print and copy permissions (if encrypted)
-              page size and rotation
-              file size
-              linearized (yes/no)
-              PDF version
-              metadata (only if requested)
-
-CONFIGURATION FILE
-       Pdfinfo  reads a configuration file at startup.  It first tries to find
-       the user's private config file, ~/.xpdfrc.  If that doesn't  exist,  it
-       looks  for  a  system-wide config file, typically /usr/local/etc/xpdfrc
-       (but this location can be changed when  pdfinfo  is  built).   See  the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many  of  the following options can be set with configuration file com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies  the  first  page  to  examine.  If multiple pages are
-              requested using the "-f" and "-l"  options,  the  size  of  each
-              requested  page  (and,  optionally,  the bounding boxes for each
-              requested page) are printed.  Otherwise, only page one is  exam-
-              ined.
-
-       -l number
-              Specifies the last page to examine.
-
-       -box   Prints the page box bounding boxes: MediaBox, CropBox, BleedBox,
-              TrimBox, and ArtBox.
-
-       -meta  Prints document-level metadata.  (This is the "Metadata"  stream
-              from the PDF file's Catalog object.)
-
-       -rawdates
-              Prints  the  raw (undecoded) date strings, directly from the PDF
-              file.
-
-       -enc encoding-name
-              Sets the encoding to use for  text  output.   The  encoding-name
-              must  be  defined  with  the unicodeMap command (see xpdfrc(5)).
-              This defaults to "Latin1" (which is a built-in encoding).  [con-
-              fig file: textEncoding]
-
-       -opw password
-              Specify  the  owner  password  for the PDF file.  Providing this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The  pdfinfo software and documentation are copyright 1996-2019 Glyph &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1), pdftops(1), pdftotext(1),  pdftohtml(1),  pdffonts(1),  pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                       pdfinfo(1)
diff --git a/doc/pdftohtml.cat b/doc/pdftohtml.cat
deleted file mode 100644
index d29a01e..0000000
--- a/doc/pdftohtml.cat
+++ /dev/null
@@ -1,110 +0,0 @@
-pdftohtml(1)                General Commands Manual               pdftohtml(1)
-
-
-
-NAME
-       pdftohtml  -  Portable Document Format (PDF) to HTML converter (version
-       4.01)
-
-SYNOPSIS
-       pdftohtml [options] PDF-file HTML-dir
-
-DESCRIPTION
-       Pdftohtml converts Portable Document Format (PDF) files to HTML.
-
-       Pdftohtml reads the PDF file, PDF-file, and places  an  HTML  file  for
-       each page, along with auxiliary images in the directory, HTML-dir.  The
-       HTML directory will be created; if it already  exists,  pdftohtml  will
-       report an error.
-
-CONFIGURATION FILE
-       Pdftohtml  reads  a  configuration  file at startup.  It first tries to
-       find the user's private config file, ~/.xpdfrc.  If that doesn't exist,
-       it looks for a system-wide config file, typically /usr/local/etc/xpdfrc
-       (but this location can be changed when pdftohtml is  built).   See  the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many  of  the following options can be set with configuration file com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to convert.
-
-       -l number
-              Specifies the last page to convert.
-
-       -z number
-              Specifies  the  initial  zoom  level.  The default is 1.0, which
-              means 72dpi, i.e., 1 point in the PDF file will be  1  pixel  in
-              the  HTML.   Using  '-z 1.5', for example, will make the initial
-              view 50% larger.
-
-       -r number
-              Specifies the resolution, in DPI, for background  images.   This
-              controls the pixel size of the background image files.  The ini-
-              tial zoom level is controlled by the '-z' option.  Specifying  a
-              larger '-r' value will allow the viewer to zoom in farther with-
-              out upscaling artifacts in the background.
-
-       -skipinvisible
-              Don't draw invisible text.  By default, invisible text (commonly
-              used in OCR'ed PDF files) is drawn as transparent (alpha=0) HTML
-              text.  This option tells pdftohtml  to  discard  invisible  text
-              entirely.
-
-       -allinvisible
-              Treat  all  text as invisible.  By default, regular (non-invisi-
-              ble) text is not drawn in the background image, and  is  instead
-              drawn  with  HTML on top of the image.  This option tells pdfto-
-              html to include the regular text in the  background  image,  and
-              then draw it as transparent (alpha=0) HTML text.
-
-       -opw password
-              Specify  the  owner  password  for the PDF file.  Providing this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-BUGS
-       Some  PDF  files contain fonts whose encodings have been mangled beyond
-       recognition.  There is no way (short of OCR) to extract text from these
-       files.
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The  pdftohtml software and documentation are copyright 1996-2019 Glyph
-       & Cog, LLC.
-
-SEE ALSO
-       xpdf(1),  pdftops(1),  pdftotext(1),  pdfinfo(1),  pdffonts(1),  pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                     pdftohtml(1)
diff --git a/doc/pdftopng.cat b/doc/pdftopng.cat
deleted file mode 100644
index 7e6de46..0000000
--- a/doc/pdftopng.cat
+++ /dev/null
@@ -1,100 +0,0 @@
-pdftopng(1)                 General Commands Manual                pdftopng(1)
-
-
-
-NAME
-       pdftopng  - Portable Document Format (PDF) to Portable Network Graphics
-       (PNG) converter (version 4.01)
-
-SYNOPSIS
-       pdftopng [options] PDF-file PNG-root
-
-DESCRIPTION
-       Pdftopng converts  Portable  Document  Format  (PDF)  files  to  color,
-       grayscale, or monochrome image files in Portable Network Graphics (PNG)
-       format.
-
-       Pdftopng reads the PDF file, PDF-file, and writes one PNG file for each
-       page,  PNG-root-nnnnnn.png,  where  nnnnnn is the page number.  If PNG-
-       root is '-', the image is sent to stdout (this is probably only  useful
-       when converting a single page).
-
-CONFIGURATION FILE
-       Pdftopng reads a configuration file at startup.  It first tries to find
-       the user's private config file, ~/.xpdfrc.  If that doesn't  exist,  it
-       looks  for  a  system-wide config file, typically /usr/local/etc/xpdfrc
-       (but this location can be changed when pdftopng  is  built).   See  the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many  of  the following options can be set with configuration file com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to convert.
-
-       -l number
-              Specifies the last page to convert.
-
-       -r number
-              Specifies the resolution, in DPI.  The default is 150 DPI.
-
-       -mono  Generate a monochrome image (instead of a color image).
-
-       -gray  Generate a grayscale image (instead of a color image).
-
-       -alpha Generate  an alpha channel in the PNG file.  This is only useful
-              with PDF files that have been  constructed  with  a  transparent
-              background.  The -alpha flag cannot be used with -mono.
-
-       -freetype yes | no
-              Enable  or  disable  FreeType  (a TrueType / Type 1 font raster-
-              izer).  This defaults to "yes".  [config file: enableFreeType]
-
-       -aa yes | no
-              Enable or disable font anti-aliasing.  This defaults  to  "yes".
-              [config file: antialias]
-
-       -aaVector yes | no
-              Enable or disable vector anti-aliasing.  This defaults to "yes".
-              [config file: vectorAntialias]
-
-       -opw password
-              Specify the owner password for the  PDF  file.   Providing  this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The pdftopng software and documentation are copyright 1996-2019 Glyph &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1),  pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1),   pdf-
-       fonts(1), pdfdetach(1), pdftoppm(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                      pdftopng(1)
diff --git a/doc/pdftoppm.cat b/doc/pdftoppm.cat
deleted file mode 100644
index cad6636..0000000
--- a/doc/pdftoppm.cat
+++ /dev/null
@@ -1,99 +0,0 @@
-pdftoppm(1)                 General Commands Manual                pdftoppm(1)
-
-
-
-NAME
-       pdftoppm - Portable Document Format (PDF) to Portable Pixmap (PPM) con-
-       verter (version 4.01)
-
-SYNOPSIS
-       pdftoppm [options] PDF-file PPM-root
-
-DESCRIPTION
-       Pdftoppm converts Portable Document Format (PDF) files to  color  image
-       files  in Portable Pixmap (PPM) format, grayscale image files in Porta-
-       ble Graymap (PGM) format, or monochrome image files in Portable  Bitmap
-       (PBM) format.
-
-       Pdftoppm reads the PDF file, PDF-file, and writes one PPM file for each
-       page, PPM-root-nnnnnn.ppm, where nnnnnn is the page  number.   If  PPM-
-       root  is '-', the image is sent to stdout (this is probably only useful
-       when converting a single page).
-
-CONFIGURATION FILE
-       Pdftoppm reads a configuration file at startup.  It first tries to find
-       the  user's  private config file, ~/.xpdfrc.  If that doesn't exist, it
-       looks for a system-wide config  file,  typically  /usr/local/etc/xpdfrc
-       (but  this  location  can  be changed when pdftoppm is built).  See the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many of the following options can be set with configuration  file  com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to convert.
-
-       -l number
-              Specifies the last page to convert.
-
-       -r number
-              Specifies the resolution, in DPI.  The default is 150 DPI.
-
-       -mono  Generate a monochrome PBM file (instead of an RGB PPM file).
-
-       -gray  Generate a grayscale PGM file (instead of an RGB PPM file).
-
-       -cmyk  Generate a CMYK PAM file (instead of an RGB PPM file).
-
-       -freetype yes | no
-              Enable or disable FreeType (a TrueType /  Type  1  font  raster-
-              izer).  This defaults to "yes".  [config file: enableFreeType]
-
-       -aa yes | no
-              Enable  or  disable font anti-aliasing.  This defaults to "yes".
-              [config file: antialias]
-
-       -aaVector yes | no
-              Enable or disable vector anti-aliasing.  This defaults to "yes".
-              [config file: vectorAntialias]
-
-       -opw password
-              Specify  the  owner  password  for the PDF file.  Providing this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The pdftoppm software and documentation are copyright 1996-2019 Glyph &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1),   pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1),  pdf-
-       fonts(1), pdfdetach(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                      pdftoppm(1)
diff --git a/doc/pdftops.cat b/doc/pdftops.cat
deleted file mode 100644
index 5669e05..0000000
--- a/doc/pdftops.cat
+++ /dev/null
@@ -1,214 +0,0 @@
-pdftops(1)                  General Commands Manual                 pdftops(1)
-
-
-
-NAME
-       pdftops  - Portable Document Format (PDF) to PostScript converter (ver-
-       sion 4.01)
-
-SYNOPSIS
-       pdftops [options] [PDF-file [PS-file]]
-
-DESCRIPTION
-       Pdftops converts Portable Document Format (PDF) files to PostScript  so
-       they can be printed.
-
-       Pdftops reads the PDF file, PDF-file, and writes a PostScript file, PS-
-       file.  If PS-file  is  not  specified,  pdftops  converts  file.pdf  to
-       file.ps  (or  file.eps  with  the -eps option).  If PS-file is '-', the
-       PostScript is sent to stdout.
-
-CONFIGURATION FILE
-       Pdftops reads a configuration file at startup.  It first tries to  find
-       the  user's  private config file, ~/.xpdfrc.  If that doesn't exist, it
-       looks for a system-wide config  file,  typically  /usr/local/etc/xpdfrc
-       (but  this  location  can  be  changed when pdftops is built).  See the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many of the following options can be set with configuration  file  com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to print.
-
-       -l number
-              Specifies the last page to print.
-
-       -level1
-              Generate Level 1 PostScript.   The  resulting  PostScript  files
-              will  be significantly larger (if they contain images), but will
-              print on Level 1 printers.  This also  converts  all  images  to
-              black  and  white.   No  more  than  one of the PostScript level
-              options  (-level1,  -level1sep,  -level2,  -level2sep,  -level3,
-              -level3Sep) may be given.  [config file: psLevel]
-
-       -level1sep
-              Generate Level 1 separable PostScript.  All colors are converted
-              to CMYK.  Images are written with separate stream data  for  the
-              four components.  [config file: psLevel]
-
-       -level2
-              Generate  Level 2 PostScript.  Level 2 supports color images and
-              image compression.  This is the default setting.  [config  file:
-              psLevel]
-
-       -level2gray
-              Generate  grayscale  Level  2 PostScript.  All colors, including
-              images, are converted to grayscale.  [config file: psLevel]
-
-       -level2sep
-              Generate Level 2 separable PostScript.  All colors are converted
-              to  CMYK.   The  PostScript  separation convention operators are
-              used to handle custom (spot) colors.  [config file: psLevel]
-
-       -level3
-              Generate Level 3 PostScript.  This enables all Level 2  features
-              plus  CID  font  embedding and masked image generation.  [config
-              file: psLevel]
-
-       -level3gray
-              Generate grayscale Level 3 PostScript.   All  colors,  including
-              images, are converted to grayscale.  [config file: psLevel]
-
-       -level3Sep
-              Generate  Level 3 separable PostScript.  The separation handling
-              is the same as for -level2Sep.  [config file: psLevel]
-
-       -eps   Generate an Encapsulated PostScript (EPS)  file.   An  EPS  file
-              contains a single image, so if you use this option with a multi-
-              page PDF file, you must use -f and -l to specify a single  page.
-              No more than one of the mode options (-eps, -form) may be given.
-
-       -form  Generate  a  PostScript  form  which can be imported by software
-              that understands forms.  A form contains a single  page,  so  if
-              you  use this option with a multi-page PDF file, you must use -f
-              and -l to specify a single page.  The -level1 option  cannot  be
-              used with -form.
-
-       -opi   Generate  OPI  comments  for all images and forms which have OPI
-              information.  (This option is only available if pdftops was com-
-              piled with OPI support.)  [config file: psOPI]
-
-       -noembt1
-              By  default, any Type 1 fonts which are embedded in the PDF file
-              are copied into the PostScript file.  This option causes pdftops
-              to  substitute  base  fonts  instead.  Embedded fonts make Post-
-              Script files larger, but may be necessary for  readable  output.
-              [config file: psEmbedType1Fonts]
-
-       -noembtt
-              By  default,  any  TrueType  fonts which are embedded in the PDF
-              file are copied into the PostScript file.   This  option  causes
-              pdftops  to  substitute base fonts instead.  Embedded fonts make
-              PostScript files larger, but may be necessary for readable  out-
-              put.   Also,  some  PostScript interpreters do not have TrueType
-              rasterizers.  [config file: psEmbedTrueTypeFonts]
-
-       -noembcidps
-              By default, any CID PostScript fonts which are embedded  in  the
-              PDF  file are copied into the PostScript file.  This option dis-
-              ables that embedding.  No attempt is made to substitute for non-
-              embedded   CID  PostScript  fonts.   [config  file:  psEmbedCID-
-              PostScriptFonts]
-
-       -noembcidtt
-              By default, any CID TrueType fonts which are embedded in the PDF
-              file  are copied into the PostScript file.  This option disables
-              that embedding.  No attempt is made to substitute for non-embed-
-              ded CID TrueType fonts.  [config file: psEmbedCIDTrueTypeFonts]
-
-       -preload
-              Convert  PDF  forms  to  PS  procedures, and preload image data.
-              This uses more memory in the PostScript interpreter, but  gener-
-              ates  significantly  smaller PS files in situations where, e.g.,
-              the same image is drawn on every page of a long document.
-
-       -paper size
-              Set the paper size to one of "letter", "legal", "A4",  or  "A3".
-              This  can  also be set to "match", which will set the paper size
-              to match the size specified in  the  PDF  file.   [config  file:
-              psPaperSize]
-
-       -paperw size
-              Set the paper width, in points.  [config file: psPaperSize]
-
-       -paperh size
-              Set the paper height, in points.  [config file: psPaperSize]
-
-       -nocrop
-              By  default,  output  is cropped to the CropBox specified in the
-              PDF file.  This option disables cropping.  [config file: psCrop]
-
-       -expand
-              Expand PDF pages smaller than the paper to fill the  paper.   By
-              default,  these  pages are not scaled.  [config file: psExpandS-
-              maller]
-
-       -noshrink
-              Don't scale PDF pages which  are  larger  than  the  paper.   By
-              default, pages larger than the paper are shrunk to fit.  [config
-              file: psShrinkLarger]
-
-       -nocenter
-              By default, PDF pages smaller than the paper (after any scaling)
-              are  centered  on  the  paper.   This  option  causes them to be
-              aligned to the lower-left corner of the paper instead.   [config
-              file: psCenter]
-
-       -pagecrop
-              Treat  the CropBox as the PDF page size.  By default, the Media-
-              Box is used as the page size.  [config file: psUseCropBoxAsPage]
-
-       -userunit
-              Honor  the  UserUnit  settings  on  PDF  pages  when   computing
-              page/paper size.  By default, pdftops ignores UserUnit.
-
-       -duplex
-              Set  the  Duplex  pagedevice entry in the PostScript file.  This
-              tells duplex-capable  printers  to  enable  duplexing.   [config
-              file: psDuplex]
-
-       -opw password
-              Specify  the  owner  password  for the PDF file.  Providing this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The  pdftops software and documentation are copyright 1996-2019 Glyph &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1), pdftotext(1), pdftohtml(1),  pdfinfo(1),  pdffonts(1),  pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                       pdftops(1)
diff --git a/doc/pdftotext.cat b/doc/pdftotext.cat
deleted file mode 100644
index 2de518c..0000000
--- a/doc/pdftotext.cat
+++ /dev/null
@@ -1,151 +0,0 @@
-pdftotext(1)                General Commands Manual               pdftotext(1)
-
-
-
-NAME
-       pdftotext  -  Portable Document Format (PDF) to text converter (version
-       4.01)
-
-SYNOPSIS
-       pdftotext [options] [PDF-file [text-file]]
-
-DESCRIPTION
-       Pdftotext converts Portable Document Format (PDF) files to plain text.
-
-       Pdftotext reads the PDF file, PDF-file, and writes a text  file,  text-
-       file.   If  text-file  is not specified, pdftotext converts file.pdf to
-       file.txt.  If text-file is '-', the text is sent to stdout.
-
-CONFIGURATION FILE
-       Pdftotext reads a configuration file at startup.   It  first  tries  to
-       find the user's private config file, ~/.xpdfrc.  If that doesn't exist,
-       it looks for a system-wide config file, typically /usr/local/etc/xpdfrc
-       (but  this  location  can be changed when pdftotext is built).  See the
-       xpdfrc(5) man page for details.
-
-OPTIONS
-       Many of the following options can be set with configuration  file  com-
-       mands.  These are listed in square brackets with the description of the
-       corresponding command line option.
-
-       -f number
-              Specifies the first page to convert.
-
-       -l number
-              Specifies the last page to convert.
-
-       -layout
-              Maintain (as best as possible) the original physical  layout  of
-              the  text.   The  default is to 'undo' physical layout (columns,
-              hyphenation, etc.) and output the text in reading order.  If the
-              -fixed  option is given, character spacing within each line will
-              be determined by the specified character pitch.
-
-       -simple
-              Similar to -layout, but optimized for simple  one-column  pages.
-              This  mode  will do a better job of maintaining horizontal spac-
-              ing, but it will only work properly  with  a  single  column  of
-              text.
-
-       -table Table mode is similar to physical layout mode, but optimized for
-              tabular data, with the goal of keeping rows and columns  aligned
-              (at  the  expense of inserting extra whitespace).  If the -fixed
-              option is given, character spacing  within  each  line  will  be
-              determined by the specified character pitch.
-
-       -lineprinter
-              Line  printer  mode  uses  a  strict  fixed-character-pitch  and
-              -height layout.  That is, the page is broken into  a  grid,  and
-              characters  are  placed  into that grid.  If the grid spacing is
-              too small for the actual characters, the result is extra  white-
-              space.   If the grid spacing is too large, the result is missing
-              whitespace.  The grid spacing can be specified using the  -fixed
-              and  -linespacing  options.  If one or both are not given on the
-              command line, pdftotext  will  attempt  to  compute  appropriate
-              value(s).
-
-       -raw   Keep the text in content stream order.  Depending on how the PDF
-              file was generated, this may or may not be useful.
-
-       -fixed number
-              Specify the character pitch (character width),  in  points,  for
-              physical  layout,  table, or line printer mode.  This is ignored
-              in all other modes.
-
-       -linespacing number
-              Specify the line spacing, in  points,  for  line  printer  mode.
-              This is ignored in all other modes.
-
-       -clip  Text which is hidden because of clipping is removed before doing
-              layout, and then added back in.  This can be helpful for  tables
-              where clipped (invisible) text would overlap the next column.
-
-       -nodiag
-              Diagonal text, i.e., text that is not close to one of the 0, 90,
-              180, or 270 degree axes, is discarded.  This is useful  to  skip
-              watermarks drawn on top of body text, etc.
-
-       -enc encoding-name
-              Sets  the  encoding  to  use for text output.  The encoding-name
-              must be defined with the  unicodeMap  command  (see  xpdfrc(5)).
-              The  encoding name is case-sensitive.  This defaults to "Latin1"
-              (which is a built-in encoding).  [config file: textEncoding]
-
-       -eol unix | dos | mac
-              Sets the end-of-line convention to use for text output.  [config
-              file: textEOL]
-
-       -nopgbrk
-              Don't  insert  page breaks (form feed characters) between pages.
-              [config file: textPageBreaks]
-
-       -bom   Insert a Unicode byte order marker (BOM) at  the  start  of  the
-              text output.
-
-       -opw password
-              Specify  the  owner  password  for the PDF file.  Providing this
-              will bypass all security restrictions.
-
-       -upw password
-              Specify the user password for the PDF file.
-
-       -q     Don't print any messages or errors.  [config file: errQuiet]
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-BUGS
-       Some  PDF  files contain fonts whose encodings have been mangled beyond
-       recognition.  There is no way (short of OCR) to extract text from these
-       files.
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The  pdftotext software and documentation are copyright 1996-2019 Glyph
-       & Cog, LLC.
-
-SEE ALSO
-       xpdf(1),  pdftops(1),  pdftohtml(1),  pdfinfo(1),  pdffonts(1),  pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                     pdftotext(1)
diff --git a/doc/xpdf.cat b/doc/xpdf.cat
deleted file mode 100644
index b3c6ce7..0000000
--- a/doc/xpdf.cat
+++ /dev/null
@@ -1,735 +0,0 @@
-xpdf(1)                     General Commands Manual                    xpdf(1)
-
-
-
-NAME
-       xpdf - Portable Document Format (PDF) file viewer (version 4.01)
-
-SYNOPSIS
-       xpdf [options] [PDF-file [:page | +dest]] ...
-
-       xpdf [options] -remote remote-name [command ...]
-
-DESCRIPTION
-       Xpdf  is a viewer for Portable Document Format (PDF) files.  (These are
-       also sometimes also called 'Acrobat' files, from the  name  of  Adobe's
-       PDF  software.)   Xpdf  uses the Qt GUI toolkit and runs on Unix, OS X,
-       and Windows.
-
-       To run xpdf, type:
-
-              xpdf file.pdf
-
-       where file.pdf is your PDF file.  The file name can be  followed  by  a
-       page number to be displayed, prefixed with a colon:
-
-              xpdf file.pdf :18
-
-       or  by a named destination, prefixed with '+' (this is only useful with
-       PDF files that provide named destination targets):
-
-              xpdf file.pdf +destinationA
-
-       If you specify multiple files, they will each be opened in  a  separate
-       tab:
-
-              xpdf file1.pdf file2.pdf :18 file3.pdf
-
-       You can also start xpdf without opening any files:
-
-              xpdf
-
-CONFIGURATION FILE
-       Xpdf reads a configuration file at startup.  It first tries to find the
-       user's private config file, ~/.xpdfrc.  If that doesn't exist, it looks
-       for  a  system-wide  config  file, typically /usr/local/etc/xpdfrc (but
-       this location can be changed when xpdf is built).   See  the  xpdfrc(5)
-       man page for details.
-
-OPTIONS
-       The  following  command  line  options are available.  All command line
-       options must come before any PDF files to be opened.
-
-       Many of the options can be set with configuration file commands.  These
-       are listed in square brackets with the description of the corresponding
-       command line option.
-
-       -geometry geometry
-              Set the initial window geometry.
-
-       -title title
-              Set the window title.  By default,  the  title  will  be  "xpdf:
-              foo.pdf".
-
-       -rv    Set  reverse video mode.  This reverses the colors of everything
-              except images.  It may not always produce great results for  PDF
-              files  which  do  weird things with color.  This also causes the
-              paper color to default to black.
-
-       -papercolor color
-              Set the "paper color", i.e., the background of the page display.
-              The  color  can be #RRGGBB (hexadecimal) or a named color.  This
-              option will not work well with PDF files  that  do  things  like
-              filling in white behind the text.  [config file: paperColor]
-
-       -mattecolor color
-              Set the matte color, i.e., the color used for background outside
-              the actual page area.  The color can be #RRGGBB (hexadecimal) or
-              a named color.  [config file: matteColor]
-
-       -fsmattecolor color
-              Set  the  matte  color  for  full-screen mode.  The color can be
-              #RRGGBB  (hexadecimal)  or  a  named   color.    [config   file:
-              fullScreenMatteColor]
-
-       -z zoom
-              Set the initial zoom factor.  A number specifies a zoom percent-
-              age, where 100 means 72 dpi.  You may also  specify  'page',  to
-              fit  the  page  to  the window size, or 'width', to fit the page
-              width to the window width.  [config file: initialZoom]
-
-       -aa yes | no
-              Enable or disable font anti-aliasing.  This defaults  to  "yes".
-              [config file: antialias]
-
-       -aaVector yes | no
-              Enable or disable vector anti-aliasing.  This defaults to "yes".
-              [config file: vectorAntialias]
-
-       -enc encoding-name
-              Sets the encoding to use for  text  output.   The  encoding-name
-              must  be  defined  with  the unicodeMap command (see xpdfrc(5)).
-              This defaults to "Latin1" (which is a built-in encoding).  [con-
-              fig file: textEncoding]
-
-       -pw password
-              Specify  the  password for the PDF file.  This can be either the
-              owner password (which will bypass all security restrictions)  or
-              the user password.
-
-       -fullscreen
-              Open xpdf in full-screen mode, useful for presentations.
-
-       -remote remote-name
-              Start  Xpdf  in  remote server mode.  See the REMOVE SERVER MODE
-              section.
-
-       -display display
-              Set the X display (only available with X11).
-
-       -cmd   Print commands  as  they're  executed  (useful  for  debugging).
-              [config file: printCommands]
-
-       -cfg config-file
-              Read config-file in place of ~/.xpdfrc or the system-wide config
-              file.
-
-       -v     Print copyright and version information.
-
-       -h     Print usage information.  (-help and --help are equivalent.)
-
-CONTROLS
-   Tool bar
-       'page' entry box
-              Move to a specific page number.  Click in the  box  to  activate
-              it, type the page number, then hit return.
-
-       left/right arrow buttons
-              Go backward or forward along the history path.
-
-       zoom out/in buttons
-              Zoom out or in (i.e., change magnification) incrementally.
-
-       zoom popup menu
-              Change  the  zoom  factor  (see the description of the -z option
-              above).
-
-       fit width button
-              Change the zoom factor to fit  the  page  width  to  the  window
-              width.
-
-       fit page button
-              Change the zoom factor to fit the page to the window size.
-
-       working/error indicator
-              This  icon is animated while Xpdf is rendering a page.  It turns
-              red when an error or warning has been issued.   Clicking  on  it
-              opens the error dialog.
-
-       'find' box
-              Find  a  text  string.   Click in the box to activate it, type a
-              search string, then hit return.
-
-       find next button
-              Find the next occurrence of the search string.
-
-       find previous button
-              Find the previous occurrence of the search string.
-
-       find settings button
-              Display the current find settings: case sensitive (on/off), find
-              whole words (on/off).
-
-   Menu bar
-       The  menu  bar  is  above the tool bar.  The menu items should be self-
-       explanatory.
-
-   Tab list
-       The tab list is on the left, just below the tool  bar.   It  lists  all
-       open tabs.
-
-   Outline/layers/attachments pane
-       This  pane is on the left, below the tab list.  The popup allows you to
-       select from outline, layers, or attachments.
-
-       The outline is a tree-like structure of bookmarks  that  allows  moving
-       within the PDF file.  Not all PDF files have outlines.
-
-       Layers  (a.k.a.  optional content) allow parts of the PDF content to be
-       shown or hidden.  Not all PDF files have layers.
-
-       Attachments are other files embedded within the PDF file.  There  is  a
-       'save'  button  for each attached file.  Not all PDF files have attach-
-       ments.
-
-   Text selection
-       Dragging the mouse with the left button held  down  will  highlight  an
-       arbitrary  rectangle.   Selected  text  can  be copied to the clipboard
-       (with the edit/copy menu item).  On X11, selected text will  be  avail-
-       able in the X selection buffer.
-
-   Links
-       When  the mouse is over a hyperlink, the link target will be shown in a
-       popup near the bottom of the window.
-
-       Clicking on a hyperlink will jump to the link's destination.  A link to
-       another  PDF  document  will  make xpdf load that document.  A 'launch'
-       link to an executable program will display a dialog, and if  you  click
-       'ok',  execute the program.  URL links are opened in a system-dependent
-       way.  (On UNIX, Qt uses the $BROWSER environment variable.)
-
-   Mouse bindings
-       The left mouse button is used to select text (see above).
-
-       Clicking on a link with the middle button opens the link in a new tab.
-
-       Dragging the mouse with the middle button held down pans the window.
-
-       The right  mouse  button  opens  a  popup  menu  (see  popupMenuCmd  in
-       xpdfrc(5)).
-
-   Key bindings
-       This  section  lists the default key bindings.  Bindings can be changed
-       using the config file (see xpdfrc(5)).
-
-       control-o
-              Open a new PDF file via a file requester.
-
-       control-r
-              Reload the current PDF file.  Note that  Xpdf  will  reload  the
-              file  automatically  (on  a  page  change  or  redraw) if it has
-              changed since it was last loaded.
-
-       control-f
-              Find a text string.  This sets keyboard focus to the 'find' box.
-
-       control-G
-              Find next occurrence.
-
-       control-C
-              Copy selected text to the clipboard.
-
-       control-P
-              Print.
-
-       control-0 (control-zero)
-              Set the zoom factor to 125%.
-
-       control-+ (control-plus)
-              Zoom in (increment the zoom factor by 1).
-
-       control-- (control-minus)
-              Zoom out (decrement the zoom factor by 1).
-
-       control-s
-              Save PDF via a file requester.
-
-       control-t
-              Open a new tab.
-
-       control-n
-              Open a new window.
-
-       control-w
-              Close the current tab.  Closes the window if this was  the  last
-              open  tab.  Quits the application if this was the last open win-
-              dow.
-
-       control-q
-              Quit.
-
-       control-<tab>
-              Next tab.
-
-       control-shift-<tab>
-              Previous tab.
-
-       control-?
-              Help.
-
-       alt-<left-arrow>
-              Go backward along the history path.
-
-       alt-<right-arrow>
-              Go forward along the history path.
-
-       home   Go to the top left of current page.
-
-       control-<home>
-              Go to the first page.
-
-       end    Go to the bottom right of current page.
-
-       control-<end>
-              Go to the last page.
-
-       <space> or <PageDown>
-              Scroll down on the current page; if already at bottom,  move  to
-              next page.
-
-       control-<PageDown> or control-<down-arrow>
-              Go  to the next page.  If <ScrollLock> is active, this maintains
-              the relative position on the page.
-
-       <PageUp>
-              Scroll up on the current page; if already at top, move to previ-
-              ous page.
-
-       control-<PageUp> or control-<up-arrow>
-              Go  to the previous page.  If <ScrollLock> is active, this main-
-              tains the relative position on the page.
-
-       <esc>  Exit full-screen mode.
-
-       arrows Scroll the current page.
-
-       g      Set keyboard focus to the page number entry box.
-
-       z      Set the zoom factor to 'page' (fit page to window).
-
-       w      Set the zoom factor to 'width' (fit page width to window).
-
-Full-screen mode
-       Xpdf can be placed into full-screen mode via  the  -fullscreen  command
-       line  option,  the  'full  screen'  menu  item,  or  a  binding  to the
-       fullScreenMode or toggleFullScreenMode command.
-
-       Entering full-screen mode automatically switches  to  single-page  view
-       mode and to the fit-page zoom factor.
-
-       Full-screen  mode  can  be exited via the default <esc> key binding, or
-       via a binding to the windowMode or toggleFullScreenModecommand.
-
-COMMANDS
-       Xpdf's key and mouse bindings are user-configurable, using the bind and
-       unbind  commands  in the config file (see xpdfrc(5)).  The bind command
-       allows you to bind a key or mouse button to a sequence of one  or  more
-       commands.
-
-       The following commands are supported:
-
-       about  Open the 'about' dialog.
-
-       blockSelectMode
-              Set block selection mode.  In this mode, the selection is a sim-
-              ple rectangle.  Any part of the page can be selected, regardless
-              of the content on the page.
-
-       checkOpenFile(file)
-              Check that file is open in the current tab, and open it if not.
-
-       checkOpenFileAtDest(file,dest)
-              Check  that file is open in the current tab, and open it if not.
-              In either case go to the specified named destination.
-
-       checkOpenFileAtPage(file,page)
-              Check that file is open in the current tab, and open it if  not.
-              In either case go to the specified page.
-
-       closeSidebar
-              Close the sidebar.
-
-       closeSidebarMoveResizeWin
-              Close the sidebar, resizing the window so that the document size
-              doesn't change, and moving the window so that the document stays
-              in the same place on the screen.
-
-       closeSidebarResizeWin
-              Close the sidebar, resizing the window so that the document size
-              doesn't change.
-
-       closeTabOrQuit
-              Close the tab.  If this was the last open tab, close the window.
-              If this was the last window open, quit.
-
-       closeWindowOrQuit
-              Close the window.  If this was the last open window, quit.
-
-       continuousMode
-              Switch to continuous view mode.
-
-       copy   Copy selected text to the clipboard.
-
-       endPan End a pan operation.
-
-       endSelection
-              End a selection.
-
-       find   Set keyboard focus to the 'find' box.
-
-       findFirst
-              Find the first occurrence of the search string.
-
-       findNext
-              Find the next occurrence of the search string.
-
-       findPrevious
-              Find the previous occurrence of the search string.
-
-       focusToDocWin
-              Set keyboard focus to the main document window.
-
-       focusToPageNum
-              Set keyboard focus to the page number text box.
-
-       followLink
-              Follow  a  hyperlink  (does  nothing  if the mouse is not over a
-              link).
-
-       followLinkInNewTab
-              Follow a hyperlink, opening PDF files in a new tab (does nothing
-              if  the  mouse is not over a link).  For links to non-PDF files,
-              this command is identical to followLink.
-
-       followLinkInNewTabNoSel
-              Same as followLinkInNewTab, but does nothing if there is a  non-
-              empty selection.  (This is useful as a mouse button binding.)
-
-       followLinkInNewWin
-              Follow  a  hyperlink,  opening  PDF  files in a new window (does
-              nothing if the mouse is not over a link).  For links to  non-PDF
-              files, this command is identical to followLink.
-
-       followLinkInNewWinNoSel
-              Same  as followLinkInNewWin, but does nothing if there is a non-
-              empty selection.  (This is useful as a mouse button binding.)
-
-       followLinkNoSel
-              Same as followLink, but does nothing if  there  is  a  non-empty
-              selection.  (This is useful as a mouse button binding.)
-
-       fullScreenMode
-              Go to full-screen mode.
-
-       goBackward
-              Move backward along the history path.
-
-       goForward
-              Move forward along the history path.
-
-       gotoDest(dest)
-              Go to a named destination.
-
-       gotoLastPage
-              Go to the last page in the PDF file.
-
-       gotoPage(page)
-              Go to the specified page.
-
-       help   Open the help URL.
-
-       horizontalContinuousMode
-              Switch to horizontal continuous view mode.
-
-       linearSelectMode
-              Set  linear selection mode.  In this mode, the selection follows
-              text.  Non-text regions cannot be selected.
-
-       loadTabState
-              Load the tab state file (which was written via the  saveTabState
-              command),  and  restore  the tabs listed in that file.  The path
-              for the tab state file is specified with the  tabStateFile  set-
-              ting (see xpdfrc(5)).
-
-       newTab Open an empty new tab.
-
-       newWindow
-              Open an empty new window.
-
-       nextPage
-              Go to the next page.
-
-       nextPageNoScroll
-              Go to the next page, with the current relative scroll position.
-
-       nextTab
-              Switch to the next tab.
-
-       open   Open a PDF file in this tab, using the open dialog.
-
-       openErrorWindow
-              Open the error window.
-
-       openFile(file)
-              Open the specified file in the current tab.
-
-       openFileAtDest(file,dest)
-              Open  the  specified  file  in  the current tab at the specified
-              named destination.
-
-       openFileAtPage(file,page)
-              Open the specified file in the  current  tab  at  the  specified
-              page.
-
-       openSidebar
-              Open the sidebar.
-
-       openSidebarMoveResizeWin
-              Open  the sidebar, resizing the window so that the document size
-              doesn't change, and moving the window so that the document stays
-              in the same place on the screen.
-
-       openSidebarResizeWin
-              Open  the sidebar, resizing the window so that the document size
-              doesn't change.
-
-       pageDown
-              Scroll down by one screenful.
-
-       pageUp Scroll up by one screenful.
-
-       postPopupMenu
-              Display the popup menu.
-
-       prevPage
-              Go to the previous page.
-
-       prevPageNoScroll
-              Go to the previous page, with the current relative scroll  posi-
-              tion.
-
-       prevTab
-              Switch to the previous tab.
-
-       print  Open the 'print' dialog.
-
-       quit   Quit from xpdf.
-
-       reload Reload the current PDF file.
-
-       rotateCCW
-              Rotate the page 90 degrees counterclockwise.
-
-       rotateCW
-              Rotate the page 90 degrees clockwise.
-
-       run(external-command-string)
-              Run  an  external command.  The following escapes are allowed in
-              the command string:
-
-                  %f => PDF file name (or an empty string if no
-                        file is open)
-                  %b => PDF file base name, i.e., file name minus
-                        the extension (or an empty string if no
-                        file is open)
-                  %u => link URL (or an empty string if not over
-                        a URL link)
-                  %p => current page number (or an empty string if
-                        no file is open)
-                  %x => selection upper-left x coordinate
-                        (or 0 if there is no selection)
-                  %y => selection upper-left y coordinate
-                        (or 0 if there is no selection)
-                  %X => selection lower-right x coordinate
-                        (or 0 if there is no selection)
-                  %Y => selection lower-right y coordinate
-                        (or 0 if there is no selection)
-                  %i => page containing the mouse pointer
-                  %j => x coordinate of the mouse pointer
-                  %k => y coordinate of the mouse pointer
-                  %% => %
-
-              The external command string will often contain  spaces,  so  the
-              whole command must be quoted in the xpdfrc file:
-
-                  bind x "run(ls -l)"
-
-              The command string may not be run through a shell.  It is recom-
-              mended to keep the command simple, so that it doesn't depend  on
-              specific  shell functionality.  For complex things, you can have
-              the command string run a shell script.
-
-       saveAs Save PDF via a file requester.
-
-       saveImage
-              Open the 'save image' dialog.
-
-       saveTabState
-              Save a list of all tabs open in this window  to  the  tab  state
-              file.  For each tab, this writes the PDF file name and page num-
-              ber (on separate lines).  This file can be loaded later with the
-              loadTabState command.  The path for the tab state file is speci-
-              fied with the tabStateFile setting (see xpdfrc(5)).
-
-       scrollDown(n)
-              Scroll down by n pixels.
-
-       scrollDownNextPage(n)
-              Scroll down by n pixels, moving to the next page if appropriate.
-
-       scrollLeft(n)
-              Scroll left by n pixels.
-
-       scrollOutlineDown(n)
-              Scroll the outline down by n increments.
-
-       scrollOutlineUp(n)
-              Scroll the outline up by n increments.
-
-       scrollRight(n)
-              Scroll right by n pixels.
-
-       scrollToBottomEdge
-              Scroll to the bottom edge of the last displayed  page,  with  no
-              horizontal movement.
-
-       scrollToBottomRight
-              Scroll to the bottom-right corner of the last displayed page.
-
-       scrollToLeftEdge
-              Scroll  to  the  left edge of the current page, with no vertical
-              movement.
-
-       scrollToRightEdge
-              Scroll to the right edge of the current page, with  no  vertical
-              movement.
-
-       scrollToTopEdge
-              Scroll to the top edge of the first displayed page, with no hor-
-              izontal movement.
-
-       scrollToTopLeft
-              Scroll to the top-left corner of the first displayed page.
-
-       scrollUp(n)
-              Scroll up by n pixels.
-
-       scrollUpPrevPage(n)
-              Scroll up by n pixels, moving to the previous page if  appropri-
-              ate.
-
-       setSelection(pg,ulx,uly,lrx,lry)
-              Set  the selection to the specified coordinates on the specified
-              page.
-
-       sideBySideContinuousMode
-              Switch to side-by-side continuous view mode.
-
-       sideBySideSingleMode
-              Switch to side-by-side two-page view mode.
-
-       singlePageMode
-              Switch to single-page view mode.
-
-       startPan
-              Start a pan operation at the current mouse position, which  will
-              scroll the document as the mouse moves.
-
-       startSelection
-              Start  a  selection at the current mouse position, which will be
-              extended as the mouse moves.
-
-       toggleContinuousMode
-              Toggle between continuous and single page view modes.
-
-       toggleFullScreenMode
-              Toggle between full-screen and window modes.
-
-       toggleSelectMode
-              Toggle between block and linear selection mode.
-
-       toggleSidebar
-              Toggle the sidebar between open and closed.
-
-       toggleSidebarMoveResizeWin
-              Toggle the sidebar between open and closed, resizing the  window
-              so  that the document size doesn't change, and moving the window
-              so that the document stays in the same place on the screen.
-
-       toggleSidebarResizeWin
-              Toggle the sidebar between open and closed, resizing the  window
-              so that the document size doesn't change.
-
-       windowMode
-              Go to window (non-full-screen) mode.
-
-       zoomFitPage
-              Set the zoom factor to fit-page.
-
-       zoomFitWidth
-              Set the zoom factor to fit-width.
-
-       zoomIn Zoom in - go to the next higher zoom factor.
-
-       zoomOut
-              Zoom out - go the next lower zoom factor.
-
-       zoomPercent(z)
-              Set the zoom factor to z%.
-
-       zoomToSelection
-              Zoom to the current selection.
-
-REMOTE SERVER MODE
-       Starting  xpdf  with  the  "-remote"  switch puts it into remote server
-       mode.  All remaining command line options are commands  (see  the  COM-
-       MANDS section).  Subsequent invocations of "xpdf -remote" with the same
-       remote server name will send commands to the  already-running  instance
-       of  xpdf.  The "checkOpenFile" commands are useful here for things like
-       changing pages.  For example:
-
-                  # Start up xpdf, and open something.pdf.
-                  xpdf -remote foo 'openFile(something.pdf)'
-
-                  # Switch to page 7 in the  already-open  something.pdf.   If
-              the user
-                  #  has closed xpdf in the meantime, this will restart it and
-              reopen
-                  # the file.
-                  xpdf -remote foo 'checkOpenFileAtPage(something.pdf, 7)'
-
-EXIT CODES
-       The Xpdf tools use the following exit codes:
-
-       0      No error.
-
-       1      Error opening a PDF file.
-
-       2      Error opening an output file.
-
-       3      Error related to PDF permissions.
-
-       99     Other error.
-
-AUTHOR
-       The xpdf software and documentation are  copyright  1996-2019  Glyph  &
-       Cog, LLC.
-
-SEE ALSO
-       pdftops(1), pdftotext(1), pdftohtml(1), pdfinfo(1), pdffonts(1), pdfde-
-       tach(1), pdftoppm(1), pdftopng(1), pdfimages(1), xpdfrc(5)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                          xpdf(1)
diff --git a/doc/xpdfrc.cat b/doc/xpdfrc.cat
deleted file mode 100644
index d1e6e07..0000000
--- a/doc/xpdfrc.cat
+++ /dev/null
@@ -1,719 +0,0 @@
-xpdfrc(5)                     File Formats Manual                    xpdfrc(5)
-
-
-
-NAME
-       xpdfrc - configuration file for Xpdf tools (version 4.01)
-
-DESCRIPTION
-       All  of the Xpdf tools read a single configuration file.  If you have a
-       .xpdfrc file in your home directory, it will  be  read.   Otherwise,  a
-       system-wide configuration file will be read from /usr/local/etc/xpdfrc,
-       if it exists.  (This  is  its  default  location;  depending  on  build
-       options,  it  may  be  placed elsewhere.)  On Win32 systems, the xpdfrc
-       file should be placed in the same directory as the executables.
-
-       The xpdfrc file consists of a series of configuration options, one  per
-       line.   Blank  lines  and  lines  starting  with  a  '#' (comments) are
-       ignored.
-
-       Arguments may be quoted, using  "double-quote"  characters,  e.g.,  for
-       file names that contain spaces.
-
-       The  following  sections  list all of the configuration options, sorted
-       into functional groups.  There is an examples section at the end.
-
-INCLUDE FILES
-       include config-file
-              Includes the specified config  file.   The  effect  of  this  is
-              equivalent  to  inserting  the  contents of config-file directly
-              into the parent config file in place  of  the  include  command.
-              Config files can be nested arbitrarily deeply.
-
-GENERAL FONT CONFIGURATION
-       fontFile PDF-font-name font-file
-              Maps  a  PDF font, PDF-font-name, to a font for display or Post-
-              Script output.  The  font  file,  font-file,  can  be  any  type
-              allowed  in  a  PDF file.  This command can be used for 8-bit or
-              16-bit (CID) fonts.
-
-       fontDir dir
-              Specifies a search directory for font files.  There can be  mul-
-              tiple fontDir commands; all of the specified directories will be
-              searched in order.  The font files can be Type 1 (.pfa or  .pfb)
-              or TrueType (.ttf or .ttc); other files in the directory will be
-              ignored.  The font file name (not including the extension)  must
-              exactly  match  the  PDF font name.  This search is performed if
-              the font name doesn't match any of the fonts declared  with  the
-              fontFile command.  There are no default fontDir directories.
-
-       fontFileCC registry-ordering font-file
-              Maps  the  registry-ordering  character collection to a font for
-              display or PostScript output.  This mapping is used if the  font
-              name  doesn't match any of the fonts declared with the fontFile,
-              fontDir, psResidentFont16, or psResidentFontCC commands.
-
-POSTSCRIPT FONT CONFIGURATION
-       psFontPassthrough yes | no
-              If set to "yes", pass 8-bit font names through to the PostScript
-              output  without  substitution.   Fonts which are not embedded in
-              the PDF file are expected to be available on the printer.   This
-              defaults to "no".
-
-       psResidentFont PDF-font-name PS-font-name
-              When the 8-bit font PDF-font-name is used (without embedding) in
-              a PDF file,  it  will  be  translated  to  the  PostScript  font
-              PS-font-name,  which  is  assumed to be resident in the printer.
-              Typically, PDF-font-name and  PS-font-name  are  the  same.   By
-              default, only the Base-14 fonts are assumed to be resident.
-
-       psResidentFont16 PDF-font-name wMode PS-font-name encoding
-              When the 16-bit (CID) font PDF-font-name with writing mode wMode
-              is used (without embedding) in a PDF file, it will be translated
-              to the PostScript font PS-font-name, which is assumed to be res-
-              ident in the printer.  The writing mode must be either  'H'  for
-              horizontal or 'V' for vertical.  The resident font is assumed to
-              use the specified encoding (which must have  been  defined  with
-              the unicodeMap command).
-
-       psResidentFontCC registry-ordering wMode PS-font-name encoding
-              When  a  16-bit (CID) font using the registry-ordering character
-              collection and wMode writing mode is used (without embedding) in
-              a  PDF  file,  the PostScript font, PS-font-name, is substituted
-              for it.  The substituted font is assumed to be resident  in  the
-              printer.   The writing mode must be either 'H' for horizontal or
-              'V' for vertical.  The resident font is assumed to use the spec-
-              ified encoding (which must have been defined with the unicodeMap
-              command).
-
-       psEmbedType1Fonts yes | no
-              If set to "no", prevents embedding of Type 1 fonts in  generated
-              PostScript.  This defaults to "yes".
-
-       psEmbedTrueTypeFonts yes | no
-              If  set  to "no", prevents embedding of TrueType fonts in gener-
-              ated PostScript.  This defaults to "yes".
-
-       psEmbedCIDTrueTypeFonts yes | no
-              If set to "no", prevents embedding of CID TrueType fonts in gen-
-              erated PostScript.  For Level 3 PostScript, this generates a CID
-              font, for lower levels it generates a  non-CID  composite  font.
-              This defaults to "yes".
-
-       psEmbedCIDPostScriptFonts yes | no
-              If  set  to  "no", prevents embedding of CID PostScript fonts in
-              generated PostScript.  For Level 3 PostScript, this generates  a
-              CID  font,  for  lower  levels  it generates a non-CID composite
-              font.  This defaults to "yes".
-
-POSTSCRIPT CONTROL
-       psPaperSize width(pts) height(pts)
-              Sets the paper size for PostScript output.  The width and height
-              parameters  give  the paper size in PostScript points (1 point =
-              1/72 inch).
-
-       psPaperSize letter | legal | A4 | A3 | match
-              Sets the paper size for PostScript output to  a  standard  size.
-              The  default  paper size is set when xpdf and pdftops are built,
-              typically to "letter" or "A4".  This can also be set to "match",
-              which will set the paper size to match the size specified in the
-              PDF file.
-
-       psImageableArea llx lly urx ury
-              Sets the imageable area for PostScript output.  The  four  inte-
-              gers  are the coordinates of the lower-left and upper-right cor-
-              ners of the imageable region, specified in points (with the ori-
-              gin being the lower-left corner of the paper).  This defaults to
-              the full paper size;  the  psPaperSize  option  will  reset  the
-              imageable area coordinates.
-
-       psCrop yes | no
-              If  set  to  "yes",  PostScript output is cropped to the CropBox
-              specified in the PDF file; otherwise no cropping is done.   This
-              defaults to "yes".
-
-       psUseCropBoxAsPage yes | no
-              If  set  to  "yes",  PostScript output treats the CropBox as the
-              page size.  By default, this is "no", and the MediaBox  is  used
-              as the page size.
-
-       psExpandSmaller yes | no
-              If set to "yes", PDF pages smaller than the PostScript imageable
-              area are expanded to fill the  imageable  area.   Otherwise,  no
-              scaling is done on smaller pages.  This defaults to "no".
-
-       psShrinkLarger yes | no
-              If  set  to  yes, PDF pages larger than the PostScript imageable
-              area are shrunk to fit the imageable area.  Otherwise, no  scal-
-              ing is done on larger pages.  This defaults to "yes".
-
-       psCenter yes | no
-              If  set  to yes, PDF pages smaller than the PostScript imageable
-              area (after any scaling) are centered  in  the  imageable  area.
-              Otherwise,  they  are  aligned  at  the lower-left corner of the
-              imageable area.  This defaults to "yes".
-
-       psDuplex yes | no
-              If set to "yes", the generated PostScript will set the  "Duplex"
-              pagedevice  entry.  This tells duplex-capable printers to enable
-              duplexing.  This defaults to "no".
-
-       psLevel level1 | level1sep | level2 | level2gray | level2sep | level3 |
-       level3gray | level3Sep
-              Sets  the  PostScript  level  to  generate.   This  defaults  to
-              "level2".
-
-       psPreload yes | no
-              If set to "yes", PDF forms are converted to PS  procedures,  and
-              image  data  is  preloaded.   This uses more memory in the Post-
-              Script interpreter, but generates significantly smaller PS files
-              in situations where, e.g., the same image is drawn on every page
-              of a long document.  This defaults to "no".
-
-       psOPI yes | no
-              If set to "yes",  generates  PostScript  OPI  comments  for  all
-              images  and  forms  which  have OPI information.  This option is
-              only available if the Xpdf tools were compiled with OPI support.
-              This defaults to "no".
-
-       psASCIIHex yes | no
-              If  set to "yes", the ASCIIHexEncode filter will be used instead
-              of ASCII85Encode for binary data.  This defaults to "no".
-
-       psLZW yes | no
-              If set to "yes", the LZWEncode filter will be used for  lossless
-              compression in PostScript output; if set to "no", the RunLength-
-              Encode filter will be used instead.  LZW generates  better  com-
-              pression  (smaller  PS  files), but may not be supported by some
-              printers.  This defaults to "yes".
-
-       psUncompressPreloadedImages yes | no
-              If set to "yes", all preloaded images in PS  files  will  uncom-
-              pressed.  If set to "no", the original compressed images will be
-              used when possible.  The "yes" setting is useful to work  around
-              certain buggy PostScript interpreters.  This defaults to "no".
-
-       psMinLineWidth float
-              Set  the  minimum  line width, in points, for PostScript output.
-              The default value is 0 (no minimum).
-
-       psRasterResolution float
-              Set the resolution (in dpi) for rasterized pages  in  PostScript
-              output.   (Pdftops will rasterize pages which use transparency.)
-              This defaults to 300.
-
-       psRasterMono yes | no
-              If set to "yes", rasterized pages in PS files will be monochrome
-              (8-bit gray) instead of color.  This defaults to "no".
-
-       psRasterSliceSize pixels
-              When  rasterizing pages, pdftops splits the page into horizontal
-              "slices", to limit memory usage.  This option sets  the  maximum
-              slice size, in pixels.  This defaults to 20000000 (20 million).
-
-       psAlwaysRasterize yes | no
-              If set to "yes", all PostScript output will be rasterized.  This
-              defaults to "no".
-
-       psNeverRasterize yes | no
-              Pdftops rasterizes an pages that use transparency (because Post-
-              Script  doesn't  support  transparency).  If psNeverRasterize is
-              set to "yes", rasterization is disabled:  pages  will  never  be
-              rasterized, even if they contain transparency.  This will likely
-              result in incorrect output for PDF files that use  transparency,
-              and  a  warning  message  to  that effect will be printed.  This
-              defaults to "no".
-
-       fontDir dir
-              See the description above, in the DISPLAY FONTS section.
-
-TEXT CONTROL AND CHARACTER MAPPING
-       textEncoding encoding-name
-              Sets the encoding to use for text output.  (This can be overrid-
-              den  with  the  "-enc"  switch on the command line.)  The encod-
-              ing-name must  be  defined  with  the  unicodeMap  command  (see
-              above).  This defaults to "Latin1".
-
-       textEOL unix | dos | mac
-              Sets  the  end-of-line  convention  to use for text output.  The
-              options are:
-
-                  unix = LF
-                  dos  = CR+LF
-                  mac  = CR
-
-              (This can be overridden with the "-eol" switch  on  the  command
-              line.)   The  default  value  is  based on the OS where xpdf and
-              pdftotext were built.
-
-       textPageBreaks yes | no
-              If set to "yes", text extraction will insert page  breaks  (form
-              feed characters) between pages.  This defaults to "yes".
-
-       textKeepTinyChars yes | no
-              If  set  to "yes", text extraction will keep all characters.  If
-              set to "no", text extraction will discard tiny (smaller  than  3
-              point)  characters  after  the  first  50000  per page, avoiding
-              extremely slow run times for PDF files that use special fonts to
-              do shading or cross-hatching.  This defaults to "yes".
-
-       nameToUnicode map-file
-              Specifies  a  file with the mapping from character names to Uni-
-              code.  This is used to handle PDF fonts that have  valid  encod-
-              ings  but no ToUnicode entry.  Each line of a nameToUnicode file
-              looks like this:
-
-                   hex-string name
-
-              The hex-string is the Unicode (UCS-2) character index, and  name
-              is  the  corresponding  character  name.  Multiple nameToUnicode
-              files can be used; if a character name is given more than  once,
-              the  code in the last specified file is used.  There is a built-
-              in default nameToUnicode table  with  all  of  Adobe's  standard
-              character names.
-
-       cidToUnicode registry-ordering map-file
-              Specifies the file with the mapping from character collection to
-              Unicode.  Each line of a cidToUnicode file represents one  char-
-              acter:
-
-                   hex-string
-
-              The  hex-string is the Unicode (UCS-2) index for that character.
-              The first line maps CID 0, the second line  CID  1,  etc.   File
-              size  is  determined  by size of the character collection.  Only
-              one file is allowed per character collection; the last specified
-              file is used.  There are no built-in cidToUnicode mappings.
-
-       unicodeToUnicode font-name-substring map-file
-              This  is used to work around PDF fonts which have incorrect Uni-
-              code information.  It specifies a file which maps from the given
-              (incorrect)  Unicode  indexes  to the correct ones.  The mapping
-              will be used for any font  whose  name  contains  font-name-sub-
-              string.   Each  line  of  a unicodeToUnicode file represents one
-              Unicode character:
-
-                  in-hex out-hex1 out-hex2 ...
-
-              The in-hex field is an input (incorrect) Unicode index, and  the
-              rest  of  the  fields  are  one or more output (correct) Unicode
-              indexes.  Each occurrence of in-hex will  be  converted  to  the
-              specified output sequence.
-
-       unicodeRemapping remap-file
-              Remap Unicode characters when doing text extraction.  This spec-
-              ifies a file that maps from a particular Unicode index  to  zero
-              or  more  replacement  Unicode  indexes.  Each line of the remap
-              file represents one Unicode character:
-
-                  in-hex out-hex1 out-hex2 ...
-
-              Any Unicode characters not listed will be left unchanged.   This
-              function  is  typically  used  to remap things like non-breaking
-              spaces, soft hyphens, ligatures, etc.
-
-       unicodeMap encoding-name map-file
-              Specifies the file with mapping from Unicode  to  encoding-name.
-              These encodings are used for text output (see below).  Each line
-              of a unicodeMap file represents a range of one or  more  Unicode
-              characters  which  maps linearly to a range in the output encod-
-              ing:
-
-                   in-start-hex in-end-hex out-start-hex
-
-              Entries for single characters can be abbreviated to:
-
-                   in-hex out-hex
-
-              The in-start-hex and in-end-hex fields  (or  the  single  in-hex
-              field)  specify  the Unicode range.  The out-start-hex field (or
-              the out-hex field) specifies the start of  the  output  encoding
-              range.   The  length  of  the  out-start-hex (or out-hex) string
-              determines the length of the output characters (e.g., UTF-8 uses
-              different  numbers of bytes to represent characters in different
-              ranges).  Entries must be given  in  increasing  Unicode  order.
-              Only  one  file is allowed per encoding; the last specified file
-              is used.  The Latin1, ASCII7, Symbol, ZapfDingbats,  UTF-8,  and
-              UCS-2 encodings are predefined.
-
-       cMapDir registry-ordering dir
-              Specifies  a  search  directory,  dir,  for  CMaps  for the reg-
-              istry-ordering character  collection.   There  can  be  multiple
-              directories  for  a particular collection.  There are no default
-              CMap directories.
-
-       toUnicodeDir dir
-              Specifies a search directory, dir, for ToUnicode  CMaps.   There
-              can  be  multiple  ToUnicode  directories.  There are no default
-              ToUnicode directories.
-
-       mapNumericCharNames yes | no
-              If set to "yes", the Xpdf tools  will  attempt  to  map  various
-              numeric character names sometimes used in font subsets.  In some
-              cases this leads to usable text, and in other cases it leads  to
-              gibberish -- there is no way for Xpdf to tell.  This defaults to
-              "yes".
-
-       mapUnknownCharNames yes | no
-              If set to "yes", and mapNumericCharNames is  set  to  "no",  the
-              Xpdf  tools  will  apply  a simple pass-through mapping (Unicode
-              index = character code) for all unrecognized glyph names.   (For
-              CID  fonts, setting mapNumericCharNames to "no" is unnecessary.)
-              In some cases, this leads to usable text, and in other cases  it
-              leads  to  gibberish  -- there is no way for Xpdf to tell.  This
-              defaults to "no".
-
-       mapExtTrueTypeFontsViaUnicode yes | no
-              When rasterizing text using an external TrueType font, there are
-              two  options  for  handling character codes.  If mapExtTrueType-
-              FontsViaUnicode is set to "yes", Xpdf will use the  font  encod-
-              ing/ToUnicode  info  to map character codes to Unicode, and then
-              use the font's Unicode cmap to map Unicode to GIDs.  If  mapExt-
-              TrueTypeFontsViaUnicode  is  set  to  "no", Xpdf will assume the
-              character codes are GIDs (i.e., use an identity mapping).   This
-              defaults to "yes".
-
-       dropFont font-name
-              Drop  all  text drawn in the specified font.  To drop text drawn
-              in unnamed fonts, use:
-
-                  dropFont ""
-
-              There can be any number of dropFont commands.
-
-RASTERIZER SETTINGS
-       enableFreeType yes | no
-              Enables or disables use of FreeType (a TrueType /  Type  1  font
-              rasterizer).  This is only relevant if the Xpdf tools were built
-              with  FreeType  support.   ("enableFreeType"  replaces  the  old
-              "freetypeControl" option.)  This option defaults to "yes".
-
-       disableFreeTypeHinting yes | no
-              If  this  is  set to "yes", FreeType hinting will be forced off.
-              This option defaults to "no".
-
-       antialias yes | no
-              Enables or disables font anti-aliasing in  the  PDF  rasterizer.
-              This option affects all font rasterizers.  ("antialias" replaces
-              the anti-aliasing control provided by the old "t1libControl" and
-              "freetypeControl" options.)  This default to "yes".
-
-       vectorAntialias yes | no
-              Enables  or disables anti-aliasing of vector graphics in the PDF
-              rasterizer.  This defaults to "yes".
-
-       antialiasPrinting yes | no
-              If  this  is  "yes",  bitmaps  sent  to  the  printer  will   be
-              antialiased  (according to the "antialias" and "vectorAntialias"
-              settings).  If  this  is  "no",  printed  bitmaps  will  not  be
-              antialiased.  This defaults to "no".
-
-       strokeAdjust yes | no | cad
-              Sets  the  stroke  adjustment  mode.   If set to "no", no stroke
-              adjustment will be done.  If set to "yes", normal stroke adjust-
-              ment  will  be done: horizontal and vertical lines will be moved
-              by up to half a pixel to make  them  look  cleaner  when  vector
-              anti-aliasing is enabled.  If set to "cad", a slightly different
-              stroke adjustment algorithm will be used to ensure that lines of
-              the same original width will always have the same adjusted width
-              (at the expense of allowing gaps and overlaps  between  adjacent
-              lines).  This defaults to "yes".
-
-       forceAccurateTiling yes | no
-              If  this is set to "yes", the TilingType is forced to 2 (no dis-
-              tortion) for all tiling patterns, regardless of the  setting  in
-              the pattern dictionary.  This defaults to "no".
-
-       screenType dispersed | clustered | stochasticClustered
-              Sets  the halftone screen type, which will be used when generat-
-              ing a monochrome (1-bit) bitmap.  The  three  options  are  dis-
-              persed-dot  dithering, clustered-dot dithering (with a round dot
-              and  45-degree  screen  angle),  and  stochastic   clustered-dot
-              dithering.   By default, "stochasticClustered" is used for reso-
-              lutions of 300 dpi and higher, and "dispersed" is used for reso-
-              lutions lower then 300 dpi.
-
-       screenSize integer
-              Sets  the size of the (square) halftone screen threshold matrix.
-              By default, this is 4 for dispersed-dot dithering, 10 for  clus-
-              tered-dot   dithering,  and  100  for  stochastic  clustered-dot
-              dithering.
-
-       screenDotRadius integer
-              Sets the halftone screen dot radius.  This  is  only  used  when
-              screenType  is set to stochasticClustered, and it defaults to 2.
-              In clustered-dot mode, the dot radius  is  half  of  the  screen
-              size.  Dispersed-dot dithering doesn't have a dot radius.
-
-       screenGamma float
-              Sets the halftone screen gamma correction parameter.  Gamma val-
-              ues greater than 1 make the output brighter; gamma  values  less
-              than 1 make it darker.  The default value is 1.
-
-       screenBlackThreshold float
-              When  halftoning,  all values below this threshold are forced to
-              solid black.  This parameter is a floating point value between 0
-              (black) and 1 (white).  The default value is 0.
-
-       screenWhiteThreshold float
-              When  halftoning,  all values above this threshold are forced to
-              solid white.  This parameter is a floating point value between 0
-              (black) and 1 (white).  The default value is 1.
-
-       minLineWidth float
-              Set  the minimum line width, in device pixels.  This affects the
-              rasterizer only, not the PostScript converter  (except  when  it
-              uses  rasterization  to handle transparency).  The default value
-              is 0 (no minimum).
-
-       enablePathSimplification yes | no
-              If set to "yes", simplify paths  by  removing  points  where  it
-              won't  make  a significant difference to the shape.  The default
-              value is "no".
-
-       overprintPreview yes | no
-              If set to "yes", generate overprint preview output, honoring the
-              OP/op/OPM  settings  in the PDF file.  Ignored for non-CMYK out-
-              put.  The default value is "no".
-
-VIEWER SETTINGS
-       These settings only apply to the Xpdf GUI PDF viewer.
-
-       initialZoom percentage | page | width
-              Sets the initial zoom factor.  A number specifies  a  zoom  per-
-              centage,  where  100 means 72 dpi.  You may also specify 'page',
-              to fit the page to the window size, or 'width', to fit the  page
-              width to the window width.
-
-       defaultFitZoom percentage
-              If xpdf is started with fit-page or fit-width zoom and no window
-              geometry, it will calculate a desired window size based  on  the
-              PDF  page  size and this defaultFitZoom value.  I.e., the window
-              size will be chosen such that exactly one page will fit  in  the
-              window  at  this  zoom factor (which must be a percentage).  The
-              default value is based on the screen resolution.
-
-       initialSidebarState yes | no
-              If set to "yes", xpdf opens with  the  sidebar  (tabs,  outline,
-              etc.)   visible.   If  set  to "no", xpdf opens with the sidebar
-              collapsed.  The default is "yes".
-
-       paperColor color
-              Set the "paper color", i.e., the background of the page display.
-              The  color  can be #RRGGBB (hexadecimal) or a named color.  This
-              option will not work well with PDF files  that  do  things  like
-              filling in white behind the text.
-
-       matteColor color
-              Set the matte color, i.e., the color used for background outside
-              the actual page area.  The color can be #RRGGBB (hexadecimal) or
-              a named color.
-
-       fullScreenMatteColor color
-              Set  the  matte  color  for  full-screen mode.  The color can be
-              #RRGGBB (hexadecimal) or a named color.
-
-       popupMenuCmd title command ...
-              Add a command to the popup menu.  Title is the text to  be  dis-
-              played  in  the  menu.  Command is an Xpdf command (see the COM-
-              MANDS section of the xpdf(1) man page  for  details).   Multiple
-              commands are separated by whitespace.
-
-       maxTileWidth pixels
-              Set the maximum width of tiles to be used by xpdf when rasteriz-
-              ing pages.  This defaults to 1500.
-
-       maxTileHeight pixels
-              Set the maximum height of tiles to be used by xpdf when  raster-
-              izing pages.  This defaults to 1500.
-
-       tileCacheSize tiles
-              Set  the  maximum number of tiles to be cached by xpdf when ras-
-              terizing pages.  This defaults to 10.
-
-       workerThreads numThreads
-              Set the number of worker threads to be used by xpdf when raster-
-              izing pages.  This defaults to 1.
-
-       launchCommand command
-              Sets  the  command  executed  when  you click on a "launch"-type
-              link.  The intent is for the  command  to  be  a  program/script
-              which  determines the file type and runs the appropriate viewer.
-              The command line will consist of the file to be  launched,  fol-
-              lowed  by  any  parameters  specified with the link.  Do not use
-              "%s" in "command".  By default, this is  unset,  and  Xpdf  will
-              simply try to execute the file (after prompting the user).
-
-       movieCommand command
-              Sets  the command executed when you click on a movie annotation.
-              The string "%s" will be replaced with the movie file name.  This
-              has no default value.
-
-       defaultPrinter printer
-              Sets the default printer used in the viewer's print dialog.
-
-       bind modifiers-key context command ...
-              Add  a  key  or  mouse button binding.  Modifiers can be zero or
-              more of:
-
-                  shift-
-                  ctrl-
-                  alt-
-
-              Key can be a regular ASCII character, or any one of:
-
-                  space
-                  tab
-                  return
-                  enter
-                  backspace
-                  esc
-                  insert
-                  delete
-                  home
-                  end
-                  pgup
-                  pgdn
-                  left / right / up / down        (arrow keys)
-                  f1 .. f35                       (function keys)
-                  mousePress1 .. mousePress7      (mouse buttons)
-                  mouseRelease1 .. mouseRelease7  (mouse buttons)
-                  mouseClick1 .. mouseClick7      (mouse buttons)
-
-              Context is either "any" or a comma-separated combination of:
-
-                  fullScreen / window       (full screen mode on/off)
-                  continuous / singlePage   (continuous mode on/off)
-                  overLink / offLink        (mouse over link or not)
-                  scrLockOn / scrLockOff    (scroll lock on/off)
-
-              The context string can include only one  of  each  pair  in  the
-              above list.
-
-              Command  is  an  Xpdf  command  (see the COMMANDS section of the
-              xpdf(1) man page for details).  Multiple commands are  separated
-              by whitespace.
-
-              The  bind  command replaces any existing binding, but only if it
-              was defined for the exact same modifiers, key, and context.  All
-              tokens (modifiers, key, context, commands) are case-sensitive.
-
-              Example key bindings:
-
-                  # bind ctrl-a in any context to the nextPage
-                  # command
-                  bind ctrl-a any nextPage
-
-                  # bind uppercase B, when in continuous mode
-                  # with scroll lock on, to the reload command
-                  # followed by the prevPage command
-                  bind B continuous,scrLockOn reload prevPage
-
-              See the xpdf(1) man page for more examples.
-
-       unbind modifiers-key context
-              Removes  a  key binding established with the bind command.  This
-              is most useful to remove default key bindings before  establish-
-              ing  new  ones  (e.g.,  if  the default key binding is given for
-              "any" context, and you want to create new key bindings for  mul-
-              tiple contexts).
-
-       tabStateFile path
-              Sets the file used by the loadTabState and saveTabState commands
-              (see the xpdf(1) man page for more information).
-
-MISCELLANEOUS SETTINGS
-       drawAnnotations yes | no
-              If set to "no", annotations will not be drawn or  printed.   The
-              default value is "yes".
-
-       drawFormFields yes | no
-              If  set  to "no", form fields will not be drawn or printed.  The
-              default value is "yes".
-
-       enableXFA yes | no
-              If set to "yes", an XFA form (if present) will  be  rendered  in
-              place  of  an AcroForm.  If "no", an XFA form will never be ren-
-              dered.  This defaults to "yes".
-
-       printCommands yes | no
-              If set to "yes", drawing commands are printed  as  they're  exe-
-              cuted (useful for debugging).  This defaults to "no".
-
-       errQuiet yes | no
-              If  set to "yes", this suppresses all error and warning messages
-              from all of the Xpdf tools.  This defaults to "no".
-
-EXAMPLES
-       The following is a sample xpdfrc file.
-
-       # from the Thai support package
-       nameToUnicode /usr/local/share/xpdf/Thai.nameToUnicode
-
-       # from the Japanese support package
-       cidToUnicode Adobe-Japan1 /usr/local/share/xpdf/Adobe-Japan1.cidToUnicode
-       unicodeMap   JISX0208     /usr/local/share/xpdf/JISX0208.unicodeMap
-       cMapDir      Adobe-Japan1 /usr/local/share/xpdf/cmap/Adobe-Japan1
-
-       # use the Base-14 Type 1 fonts from ghostscript
-       fontFile Times-Roman           /usr/local/share/ghostscript/fonts/n021003l.pfb
-       fontFile Times-Italic          /usr/local/share/ghostscript/fonts/n021023l.pfb
-       fontFile Times-Bold            /usr/local/share/ghostscript/fonts/n021004l.pfb
-       fontFile Times-BoldItalic      /usr/local/share/ghostscript/fonts/n021024l.pfb
-       fontFile Helvetica             /usr/local/share/ghostscript/fonts/n019003l.pfb
-       fontFile Helvetica-Oblique     /usr/local/share/ghostscript/fonts/n019023l.pfb
-       fontFile Helvetica-Bold        /usr/local/share/ghostscript/fonts/n019004l.pfb
-       fontFile Helvetica-BoldOblique /usr/local/share/ghostscript/fonts/n019024l.pfb
-       fontFile Courier               /usr/local/share/ghostscript/fonts/n022003l.pfb
-       fontFile Courier-Oblique       /usr/local/share/ghostscript/fonts/n022023l.pfb
-       fontFile Courier-Bold          /usr/local/share/ghostscript/fonts/n022004l.pfb
-       fontFile Courier-BoldOblique   /usr/local/share/ghostscript/fonts/n022024l.pfb
-       fontFile Symbol                /usr/local/share/ghostscript/fonts/s050000l.pfb
-       fontFile ZapfDingbats          /usr/local/share/ghostscript/fonts/d050000l.pfb
-
-       # use the Bakoma Type 1 fonts
-       # (this assumes they happen to be installed in /usr/local/fonts/bakoma)
-       fontDir /usr/local/fonts/bakoma
-
-       # set some PostScript options
-       psPaperSize          letter
-       psDuplex             no
-       psLevel              level2
-       psEmbedType1Fonts    yes
-       psEmbedTrueTypeFonts yes
-
-       # assume that the PostScript printer has the Univers and
-       # Univers-Bold fonts
-       psResidentFont Univers      Univers
-       psResidentFont Univers-Bold Univers-Bold
-
-       # set the text output options
-       textEncoding UTF-8
-       textEOL      unix
-
-       # misc options
-       enableFreeType  yes
-       launchCommand   viewer-script
-
-
-FILES
-       /usr/local/etc/xpdfrc
-              This is the default location for the  system-wide  configuration
-              file.  Depending on build options, it may be placed elsewhere.
-
-       $HOME/.xpdfrc
-              This is the user's configuration file.  If it exists, it will be
-              read in place of the system-wide file.
-
-AUTHOR
-       The Xpdf software and documentation are  copyright  1996-2019  Glyph  &
-       Cog, LLC.
-
-SEE ALSO
-       xpdf(1),   pdftops(1),  pdftotext(1),  pdftohtml(1),  pdfinfo(1),  pdf-
-       fonts(1), pdfdetach(1), pdftoppm(1), pdftopng(1), pdfimages(1)
-       http://www.xpdfreader.com/
-
-
-
-                                  18 Feb 2019                        xpdfrc(5)
diff --git a/fofi/CMakeLists.txt b/fofi/CMakeLists.txt
deleted file mode 100644
index 076cfaf..0000000
--- a/fofi/CMakeLists.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-#========================================================================
-#
-# fofi/CMakeLists.txt
-#
-# CMake script for the fofi library.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-include_directories("${PROJECT_SOURCE_DIR}")
-include_directories("${PROJECT_BINARY_DIR}")
-include_directories("${PROJECT_SOURCE_DIR}/goo")
-
-add_library(fofi_objs OBJECT
-  FoFiBase.cc
-  FoFiEncodings.cc
-  FoFiIdentifier.cc
-  FoFiTrueType.cc
-  FoFiType1.cc
-  FoFiType1C.cc
-)
-
-add_library(fofi
-  $<TARGET_OBJECTS:fofi_objs>
-)
diff --git a/fofi/FoFiBase.cc b/fofi/FoFiBase.cc
index 07cc3fc..a01131a 100644
--- a/fofi/FoFiBase.cc
+++ b/fofi/FoFiBase.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <limits.h>
 #include "gmem.h"
diff --git a/fofi/FoFiBase.h b/fofi/FoFiBase.h
index c9f93eb..ffa14cf 100644
--- a/fofi/FoFiBase.h
+++ b/fofi/FoFiBase.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 //------------------------------------------------------------------------
diff --git a/fofi/FoFiEncodings.cc b/fofi/FoFiEncodings.cc
index 6b3debb..01ae5ac 100644
--- a/fofi/FoFiEncodings.cc
+++ b/fofi/FoFiEncodings.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include "gmempp.h"
 #include "FoFiEncodings.h"
diff --git a/fofi/FoFiEncodings.h b/fofi/FoFiEncodings.h
index dd85458..6094387 100644
--- a/fofi/FoFiEncodings.h
+++ b/fofi/FoFiEncodings.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 //------------------------------------------------------------------------
diff --git a/fofi/FoFiIdentifier.cc b/fofi/FoFiIdentifier.cc
index 333fe07..e2d073b 100644
--- a/fofi/FoFiIdentifier.cc
+++ b/fofi/FoFiIdentifier.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <string.h>
 #include <limits.h>
diff --git a/fofi/FoFiIdentifier.h b/fofi/FoFiIdentifier.h
index b0307a0..497be44 100644
--- a/fofi/FoFiIdentifier.h
+++ b/fofi/FoFiIdentifier.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 class GList;
 
 //------------------------------------------------------------------------
diff --git a/fofi/FoFiTrueType.cc b/fofi/FoFiTrueType.cc
index 3709a1f..ef4c15c 100644
--- a/fofi/FoFiTrueType.cc
+++ b/fofi/FoFiTrueType.cc
@@ -8,13 +8,9 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 #include <algorithm>
 #endif
 #include "gtypes.h"
@@ -120,7 +116,7 @@ struct TrueTypeLoca {
 #define os2Tag  0x4f532f32
 #define postTag 0x706f7374
 
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 
 struct cmpTrueTypeLocaOffsetFunctor {
   bool operator()(const TrueTypeLoca &loca1, const TrueTypeLoca &loca2) {
@@ -143,7 +139,7 @@ struct cmpTrueTypeTableTagFunctor {
   }
 };
 
-#else // HAVE_STD_SORT
+#else /* HAVE_STD_SORT */
 
 static int cmpTrueTypeLocaOffset(const void *p1, const void *p2) {
   TrueTypeLoca *loca1 = (TrueTypeLoca *)p1;
@@ -169,7 +165,7 @@ static int cmpTrueTypeTableTag(const void *p1, const void *p2) {
   return (int)tab1->tag - (int)tab2->tag;
 }
 
-#endif // HAVE_STD_SORT
+#endif /* HAVE_STD_SORT */
 
 //------------------------------------------------------------------------
 
@@ -1202,7 +1198,7 @@ GBool FoFiTrueType::writeTTF(FoFiOutputFunc outputFunc,
   // the same pos value remain in the same order)
   glyfLen = 0; // make gcc happy
   if (unsortedLoca) {
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
     std::sort(locaTable, locaTable + nGlyphs + 1,
 	      cmpTrueTypeLocaOffsetFunctor());
 #else
@@ -1213,7 +1209,7 @@ GBool FoFiTrueType::writeTTF(FoFiOutputFunc outputFunc,
       locaTable[i].len = locaTable[i+1].origOffset - locaTable[i].origOffset;
     }
     locaTable[nGlyphs].len = 0;
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
     std::sort(locaTable, locaTable + nGlyphs + 1, cmpTrueTypeLocaIdxFunctor());
 #else
     qsort(locaTable, nGlyphs + 1, sizeof(TrueTypeLoca),
@@ -1508,7 +1504,7 @@ GBool FoFiTrueType::writeTTF(FoFiOutputFunc outputFunc,
     newTables[j].len = sizeof(os2Tab);
     ++j;
   }
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
   std::sort(newTables, newTables + nNewTables, cmpTrueTypeTableTagFunctor());
 #else
   qsort(newTables, nNewTables, sizeof(TrueTypeTable),
@@ -1820,7 +1816,7 @@ void FoFiTrueType::cvtSfnts(FoFiOutputFunc outputFunc,
       locaTable[i].origOffset = glyfTableLen;
     }
   }
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
   std::sort(locaTable, locaTable + nGlyphs + 1,
 	    cmpTrueTypeLocaOffsetFunctor());
 #else
@@ -1831,7 +1827,7 @@ void FoFiTrueType::cvtSfnts(FoFiOutputFunc outputFunc,
     locaTable[i].len = locaTable[i+1].origOffset - locaTable[i].origOffset;
   }
   locaTable[nGlyphs].len = 0;
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
   std::sort(locaTable, locaTable + nGlyphs + 1, cmpTrueTypeLocaIdxFunctor());
 #else
   qsort(locaTable, nGlyphs + 1, sizeof(TrueTypeLoca),
@@ -2113,8 +2109,10 @@ Guint FoFiTrueType::computeTableChecksum(Guchar *data, int length) {
     switch (length & 3) {
     case 3:
       word |= (data[i+2] & 0xff) <<  8;
+      /* fall through */
     case 2:
       word |= (data[i+1] & 0xff) << 16;
+      /* fall through */
     case 1:
       word |= (data[i  ] & 0xff) << 24;
       break;
diff --git a/fofi/FoFiTrueType.h b/fofi/FoFiTrueType.h
index a0f759b..670fa8b 100644
--- a/fofi/FoFiTrueType.h
+++ b/fofi/FoFiTrueType.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "FoFiBase.h"
 
diff --git a/fofi/FoFiType1.cc b/fofi/FoFiType1.cc
index 4f5972a..82edf8f 100644
--- a/fofi/FoFiType1.cc
+++ b/fofi/FoFiType1.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include "gmem.h"
@@ -58,7 +54,7 @@ FoFiType1::~FoFiType1() {
   if (name) {
     gfree(name);
   }
-  if (encoding && encoding != (char **)fofiType1StandardEncoding) {
+  if (encoding && encoding != fofiType1StandardEncoding) {
     for (i = 0; i < 256; ++i) {
       gfree(encoding[i]);
     }
@@ -215,7 +211,7 @@ void FoFiType1::parse() {
     // get encoding
     } else if (!encoding &&
 	       !strncmp(line, "/Encoding StandardEncoding def", 30)) {
-      encoding = (char **)fofiType1StandardEncoding;
+      encoding = const_cast<char **>(fofiType1StandardEncoding);
     } else if (!encoding &&
 	       !strncmp(line, "/Encoding 256 array", 19)) {
       encoding = (char **)gmallocn(256, sizeof(char *));
diff --git a/fofi/FoFiType1.h b/fofi/FoFiType1.h
index 4a64f24..3576391 100644
--- a/fofi/FoFiType1.h
+++ b/fofi/FoFiType1.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "FoFiBase.h"
 
diff --git a/fofi/FoFiType1C.cc b/fofi/FoFiType1C.cc
index cdb767a..a6f0a2d 100644
--- a/fofi/FoFiType1C.cc
+++ b/fofi/FoFiType1C.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
@@ -111,8 +107,8 @@ FoFiType1C::~FoFiType1C() {
     delete name;
   }
   if (encoding &&
-      encoding != (char **)fofiType1StandardEncoding &&
-      encoding != (char **)fofiType1ExpertEncoding) {
+      encoding != fofiType1StandardEncoding &&
+      encoding != fofiType1ExpertEncoding) {
     for (i = 0; i < 256; ++i) {
       gfree(encoding[i]);
     }
@@ -324,13 +320,13 @@ void FoFiType1C::convertToType1(char *psName, const char **newEncoding,
 
   // write the encoding
   (*outputFunc)(outputStream, "/Encoding ", 10);
-  if (!newEncoding && encoding == (char **)fofiType1StandardEncoding) {
+  if (!newEncoding && encoding == fofiType1StandardEncoding) {
     (*outputFunc)(outputStream, "StandardEncoding def\n", 21);
   } else {
     (*outputFunc)(outputStream, "256 array\n", 10);
     (*outputFunc)(outputStream,
 		  "0 1 255 {1 index exch /.notdef put} for\n", 40);
-    enc = newEncoding ? newEncoding : (const char **)encoding;
+    enc = newEncoding ? newEncoding : const_cast<const char **>(encoding);
     for (i = 0; i < 256; ++i) {
       if (enc[i]) {
 	buf = GString::format("dup {0:d} /{1:s} put\n", i, enc[i]);
@@ -2108,10 +2104,10 @@ void FoFiType1C::cvtNum(Type1COp op, GString *charBuf) {
 }
 
 void FoFiType1C::eexecWrite(Type1CEexecBuf *eb, const char *s) {
-  Guchar *p;
+  const Guchar *p;
   Guchar x;
 
-  for (p = (Guchar *)s; *p; ++p) {
+  for (p = (const Guchar *)s; *p; ++p) {
     x = *p ^ (Guchar)(eb->r1 >> 8);
     eb->r1 = (Gushort)((x + eb->r1) * 52845 + 22719);
     if (eb->ascii) {
@@ -2615,10 +2611,10 @@ void FoFiType1C::buildEncoding() {
   int pos, c, sid, nLeft, nSups, i, j;
 
   if (topDict.encodingOffset == 0) {
-    encoding = (char **)fofiType1StandardEncoding;
+    encoding = const_cast<char **>(fofiType1StandardEncoding);
 
   } else if (topDict.encodingOffset == 1) {
-    encoding = (char **)fofiType1ExpertEncoding;
+    encoding = const_cast<char **>(fofiType1ExpertEncoding);
 
   } else {
     encoding = (char **)gmallocn(256, sizeof(char *));
diff --git a/fofi/FoFiType1C.h b/fofi/FoFiType1C.h
index ae86968..3d9ccdc 100644
--- a/fofi/FoFiType1C.h
+++ b/fofi/FoFiType1C.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "FoFiBase.h"
 
diff --git a/fofi/Makefile.am b/fofi/Makefile.am
new file mode 100644
index 0000000..b46d04b
--- /dev/null
+++ b/fofi/Makefile.am
@@ -0,0 +1,12 @@
+noinst_LIBRARIES = libfofi.a
+
+AM_CPPFLAGS = -I$(top_builddir) -I$(srcdir) -I$(top_srcdir)/goo
+
+libfofi_a_SOURCES = \
+	FoFiBase.cc FoFiBase.h \
+	FoFiEncodings.cc FoFiEncodings.h \
+	FoFiIdentifier.cc FoFiIdentifier.h \
+	FoFiTrueType.cc FoFiTrueType.h \
+	FoFiType1.cc FoFiType1.h \
+	FoFiType1C.cc FoFiType1C.h \
+	$(empty)
diff --git a/goo/CMakeLists.txt b/goo/CMakeLists.txt
deleted file mode 100644
index 7302dbb..0000000
--- a/goo/CMakeLists.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-#========================================================================
-#
-# goo/CMakeLists.txt
-#
-# CMake script for the goo library.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-include_directories("${PROJECT_SOURCE_DIR}")
-include_directories("${PROJECT_BINARY_DIR}")
-
-add_library(goo_objs OBJECT
-  FixedPoint.cc
-  GHash.cc
-  GList.cc
-  GString.cc
-  gfile.cc
-  gmem.cc
-  gmempp.cc
-  parseargs.c
-)
-
-add_library(goo
-  $<TARGET_OBJECTS:goo_objs>
-)
diff --git a/goo/FixedPoint.cc b/goo/FixedPoint.cc
index 503a06a..48de165 100644
--- a/goo/FixedPoint.cc
+++ b/goo/FixedPoint.cc
@@ -10,11 +10,7 @@
 
 #include <aconf.h>
 
-#if USE_FIXEDPOINT
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
+#ifdef USE_FIXEDPOINT
 
 #include "gmempp.h"
 #include "FixedPoint.h"
@@ -131,4 +127,4 @@ GBool FixedPoint::checkDet(FixedPoint m11, FixedPoint m12,
   return det >= e || det <= -e;
 }
 
-#endif // USE_FIXEDPOINT
+#endif /* USE_FIXEDPOINT */
diff --git a/goo/FixedPoint.h b/goo/FixedPoint.h
index 438343f..9352dd2 100644
--- a/goo/FixedPoint.h
+++ b/goo/FixedPoint.h
@@ -13,11 +13,7 @@
 
 #include <aconf.h>
 
-#if USE_FIXEDPOINT
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
+#ifdef USE_FIXEDPOINT
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -160,6 +156,6 @@ private:
   int val;		   // fixed point: (n-fixptShift).(fixptShift)
 };
 
-#endif // USE_FIXEDPOINT
+#endif /* USE_FIXEDPOINT */
 
 #endif
diff --git a/goo/GHash.cc b/goo/GHash.cc
index e6b3244..c77a1b9 100644
--- a/goo/GHash.cc
+++ b/goo/GHash.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmem.h"
 #include "gmempp.h"
 #include "GString.h"
diff --git a/goo/GHash.h b/goo/GHash.h
index 179753a..92ce226 100644
--- a/goo/GHash.h
+++ b/goo/GHash.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 class GString;
diff --git a/goo/GList.cc b/goo/GList.cc
index c194818..6a6b1b0 100644
--- a/goo/GList.cc
+++ b/goo/GList.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include "gmem.h"
diff --git a/goo/GList.h b/goo/GList.h
index 0050437..14db002 100644
--- a/goo/GList.h
+++ b/goo/GList.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 //------------------------------------------------------------------------
diff --git a/goo/GMutex.h b/goo/GMutex.h
index d73366b..02c696b 100644
--- a/goo/GMutex.h
+++ b/goo/GMutex.h
@@ -16,7 +16,9 @@
 #  include <windows.h>
 #  include <intrin.h>
 #else
+# ifdef HAVE_PTHREAD
 #  include <pthread.h>
+# endif
 #endif
 
 //------------------------------------------------------------------------
@@ -45,6 +47,7 @@ typedef CRITICAL_SECTION GMutex;
 
 #else // assume pthreads
 
+# ifdef HAVE_PTHREAD
 typedef pthread_mutex_t GMutex;
 
 #define gInitMutex(m) pthread_mutex_init(m, NULL)
@@ -52,6 +55,17 @@ typedef pthread_mutex_t GMutex;
 #define gLockMutex(m) pthread_mutex_lock(m)
 #define gUnlockMutex(m) pthread_mutex_unlock(m)
 
+#else
+
+typedef int GMutex;
+
+#define gInitMutex(m) (*(m) = 0)
+#define gDestroyMutex(m)
+#define gLockMutex(m)
+#define gUnlockMutex(m)
+
+#endif
+
 #endif
 
 //------------------------------------------------------------------------
diff --git a/goo/GString.cc b/goo/GString.cc
index 54de35b..993f47e 100644
--- a/goo/GString.cc
+++ b/goo/GString.cc
@@ -10,10 +10,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
@@ -99,7 +95,7 @@ static const char *formatStrings[] = {
 
 //------------------------------------------------------------------------
 
-static inline int size(int len) {
+static inline unsigned int size(int len) {
   int delta;
   for (delta = 8; delta < len && delta < 0x100000; delta <<= 1) ;
   if (len > INT_MAX - delta) {
@@ -109,6 +105,12 @@ static inline int size(int len) {
   return (len + delta) & ~(delta - 1);
 }
 
+#if defined(__GNUC__) && __GNUC__ >= 7
+#pragma GCC diagnostic ignored "-Wstringop-overflow"
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
+#pragma GCC diagnostic ignored "-Wrestrict"
+#endif
+
 inline void GString::resize(int length1) {
   char *s1;
 
diff --git a/goo/GString.h b/goo/GString.h
index 6b342f8..2e67fd0 100644
--- a/goo/GString.h
+++ b/goo/GString.h
@@ -13,10 +13,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <limits.h> // for LLONG_MAX and ULLONG_MAX
 #include <stdarg.h>
 #include "gtypes.h"
diff --git a/goo/Makefile.am b/goo/Makefile.am
new file mode 100644
index 0000000..948b750
--- /dev/null
+++ b/goo/Makefile.am
@@ -0,0 +1,16 @@
+noinst_LIBRARIES = libgoo.a
+
+AM_CPPFLAGS = -I$(top_builddir) -I$(srcdir)
+
+libgoo_a_SOURCES = \
+	FixedPoint.cc FixedPoint.h \
+	GHash.cc GHash.h \
+	GList.cc GList.h \
+	GMutex.h \
+	GString.cc GString.h \
+	gfile.cc gfile.h \
+	gmem.cc gmem.h \
+	gmempp.cc gmempp.h \
+	gtypes.h \
+	parseargs.c parseargs.c \
+	$(empty)
diff --git a/goo/gfile.cc b/goo/gfile.cc
index 87b1b4a..35deacd 100644
--- a/goo/gfile.cc
+++ b/goo/gfile.cc
@@ -474,7 +474,7 @@ GBool openTempFile(GString **name, FILE **f,
   int fd;
 
   if (ext) {
-#if HAVE_MKSTEMPS
+#ifdef HAVE_MKSTEMPS
     if ((s = getenv("TMPDIR"))) {
       *name = new GString(s);
     } else {
@@ -491,7 +491,7 @@ GBool openTempFile(GString **name, FILE **f,
     fd = open((*name)->getCString(), O_WRONLY | O_CREAT | O_EXCL, 0600);
 #endif
   } else {
-#if HAVE_MKSTEMP
+#ifdef HAVE_MKSTEMP
     if ((s = getenv("TMPDIR"))) {
       *name = new GString(s);
     } else {
@@ -499,13 +499,13 @@ GBool openTempFile(GString **name, FILE **f,
     }
     (*name)->append("/XXXXXX");
     fd = mkstemp((*name)->getCString());
-#else // HAVE_MKSTEMP
+#else /* HAVE_MKSTEMP */
     if (!(s = tmpnam(NULL))) {
       return gFalse;
     }
     *name = new GString(s);
     fd = open((*name)->getCString(), O_WRONLY | O_CREAT | O_EXCL, 0600);
-#endif // HAVE_MKSTEMP
+#endif /* HAVE_MKSTEMP */
   }
   if (fd < 0 || !(*f = fdopen(fd, mode))) {
     delete *name;
@@ -665,11 +665,11 @@ char *getLine(char *buf, int size, FILE *f) {
 }
 
 int gfseek(FILE *f, GFileOffset offset, int whence) {
-#if HAVE_FSEEKO
+#if defined(HAVE_FSEEKO)
   return fseeko(f, offset, whence);
-#elif HAVE_FSEEK64
+#elif defined(HAVE_FSEEK64)
   return fseek64(f, offset, whence);
-#elif HAVE_FSEEKI64
+#elif defined(HAVE__FSEEKI64)
   return _fseeki64(f, offset, whence);
 #else
   return fseek(f, offset, whence);
@@ -677,11 +677,11 @@ int gfseek(FILE *f, GFileOffset offset, int whence) {
 }
 
 GFileOffset gftell(FILE *f) {
-#if HAVE_FSEEKO
+#if defined(HAVE_FSEEKO)
   return ftello(f);
-#elif HAVE_FSEEK64
+#elif defined(HAVE_FSEEK64)
   return ftell64(f);
-#elif HAVE_FSEEKI64
+#elif defined(HAVE__FSEEKI64)
   return _ftelli64(f);
 #else
   return ftell(f);
@@ -711,5 +711,8 @@ void fixCommandLine(int *argc, char **argv[]) {
   (*argv)[argcw] = NULL;
 
   LocalFree(argvw);
+#else
+  (void)argc;
+  (void)argv;
 #endif
 }
diff --git a/goo/gfile.h b/goo/gfile.h
index 8fff67e..1a483b0 100644
--- a/goo/gfile.h
+++ b/goo/gfile.h
@@ -92,13 +92,13 @@ extern char *getLine(char *buf, int size, FILE *f);
 
 // Type used by gfseek/gftell for file offsets.  This will be 64 bits
 // on systems that support it.
-#if HAVE_FSEEKO
+#if defined(HAVE_FSEEKO)
 typedef off_t GFileOffset;
-#define GFILEOFFSET_MAX 0x7fffffffffffffffLL
-#elif HAVE_FSEEK64
+#define GFILEOFFSET_MAX (sizeof(off_t) > 4 ? 0x7fffffffffffffffLL : LONG_MAX)
+#elif defined(HAVE_FSEEK64)
 typedef long long GFileOffset;
 #define GFILEOFFSET_MAX 0x7fffffffffffffffLL
-#elif HAVE_FSEEKI64
+#elif defined(HAVE__FSEEKI64)
 typedef __int64 GFileOffset;
 #define GFILEOFFSET_MAX 0x7fffffffffffffffLL
 #else
diff --git a/goo/gmem.cc b/goo/gmem.cc
index 7cf9581..7307836 100644
--- a/goo/gmem.cc
+++ b/goo/gmem.cc
@@ -15,7 +15,7 @@
 #include <stdint.h>
 #include <string.h>
 #include <limits.h>
-#if MULTITHREADED && defined(_WIN32)
+#if defined(MULTITHREADED) && defined(_WIN32)
 #  include <windows.h>
 #endif
 #include "gmem.h"
@@ -55,7 +55,7 @@ static int gMemAlloc = 0;
 static size_t gMemInUse = 0;
 static size_t gMaxMemInUse = 0;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #  ifdef _WIN32
      static CRITICAL_SECTION gMemMutex;
      static INIT_ONCE gMemMutexInitStruct = INIT_ONCE_STATIC_INIT;
@@ -350,7 +350,8 @@ void gfree(void *p) {
 }
 
 void gMemError(const char *msg) GMEM_EXCEP {
-#if USE_EXCEPTIONS
+#ifdef USE_EXCEPTIONS
+  (void)msg;
   throw GMemException();
 #else
   fprintf(stderr, "%s\n", msg);
diff --git a/goo/gmem.h b/goo/gmem.h
index e152199..1b54568 100644
--- a/goo/gmem.h
+++ b/goo/gmem.h
@@ -12,7 +12,7 @@
 #include <stdio.h>
 #include <aconf.h>
 
-#if USE_EXCEPTIONS
+#ifdef USE_EXCEPTIONS
 
 class GMemException {
 public:
@@ -20,13 +20,17 @@ public:
   ~GMemException() {}
 };
 
-#define GMEM_EXCEP throw(GMemException)
+#if __cplusplus >= 201103L
+#  define GMEM_EXCEP noexcept(false)
+#else
+#  define GMEM_EXCEP throw(GMemException)
+#endif
 
-#else // USE_EXCEPTIONS
+#else /* USE_EXCEPTIONS */
 
 #define GMEM_EXCEP
 
-#endif // USE_EXCEPTIONS
+#endif /* USE_EXCEPTIONS */
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/goo/parseargs.c b/goo/parseargs.c
index 2f5844f..de21dc9 100644
--- a/goo/parseargs.c
+++ b/goo/parseargs.c
@@ -13,11 +13,11 @@
 #include <ctype.h>
 #include "parseargs.h"
 
-static ArgDesc *findArg(ArgDesc *args, char *arg);
-static GBool grabArg(ArgDesc *arg, int i, int *argc, char *argv[]);
+static const ArgDesc *findArg(const ArgDesc *args, char *arg);
+static GBool grabArg(const ArgDesc *arg, int i, int *argc, char *argv[]);
 
-GBool parseArgs(ArgDesc *args, int *argc, char *argv[]) {
-  ArgDesc *arg;
+GBool parseArgs(const ArgDesc *args, int *argc, char *argv[]) {
+  const ArgDesc *arg;
   int i, j;
   GBool ok;
 
@@ -44,9 +44,9 @@ GBool parseArgs(ArgDesc *args, int *argc, char *argv[]) {
   return ok;
 }
 
-void printUsage(const char *program, const char *otherArgs, ArgDesc *args) {
-  ArgDesc *arg;
-  char *typ;
+void printUsage(const char *program, const char *otherArgs, const ArgDesc *args) {
+  const ArgDesc *arg;
+  const char *typ;
   int w, w1;
 
   w = 0;
@@ -89,8 +89,8 @@ void printUsage(const char *program, const char *otherArgs, ArgDesc *args) {
   }
 }
 
-static ArgDesc *findArg(ArgDesc *args, char *arg) {
-  ArgDesc *p;
+static const ArgDesc *findArg(const ArgDesc *args, char *arg) {
+  const ArgDesc *p;
 
   for (p = args; p->arg; ++p) {
     if (p->kind < argFlagDummy && !strcmp(p->arg, arg))
@@ -99,7 +99,7 @@ static ArgDesc *findArg(ArgDesc *args, char *arg) {
   return NULL;
 }
 
-static GBool grabArg(ArgDesc *arg, int i, int *argc, char *argv[]) {
+static GBool grabArg(const ArgDesc *arg, int i, int *argc, char *argv[]) {
   int n;
   int j;
   GBool ok;
diff --git a/goo/parseargs.h b/goo/parseargs.h
index b4daa3f..64039f1 100644
--- a/goo/parseargs.h
+++ b/goo/parseargs.h
@@ -51,13 +51,13 @@ typedef struct {
  * descriptor list <args>.  Stops parsing if "--" is found (and removes
  * it).  Returns gFalse if there was an error.
  */
-extern GBool parseArgs(ArgDesc *args, int *argc, char *argv[]);
+extern GBool parseArgs(const ArgDesc *args, int *argc, char *argv[]);
 
 /*
  * Print usage message, based on arg descriptor list.
  */
 extern void printUsage(const char *program, const char *otherArgs,
-		       ArgDesc *args);
+		       const ArgDesc *args);
 
 /*
  * Check if a string is a valid integer or floating point number.
diff --git a/m4/ax_prog_cc_for_build.m4 b/m4/ax_prog_cc_for_build.m4
new file mode 100644
index 0000000..12cb005
--- /dev/null
+++ b/m4/ax_prog_cc_for_build.m4
@@ -0,0 +1,125 @@
+# ===========================================================================
+#   https://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PROG_CC_FOR_BUILD
+#
+# DESCRIPTION
+#
+#   This macro searches for a C compiler that generates native executables,
+#   that is a C compiler that surely is not a cross-compiler. This can be
+#   useful if you have to generate source code at compile-time like for
+#   example GCC does.
+#
+#   The macro sets the CC_FOR_BUILD and CPP_FOR_BUILD macros to anything
+#   needed to compile or link (CC_FOR_BUILD) and preprocess (CPP_FOR_BUILD).
+#   The value of these variables can be overridden by the user by specifying
+#   a compiler with an environment variable (like you do for standard CC).
+#
+#   It also sets BUILD_EXEEXT and BUILD_OBJEXT to the executable and object
+#   file extensions for the build platform, and GCC_FOR_BUILD to `yes' if
+#   the compiler we found is GCC. All these variables but GCC_FOR_BUILD are
+#   substituted in the Makefile.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Paolo Bonzini <bonzini@gnu.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 9
+
+AU_ALIAS([AC_PROG_CC_FOR_BUILD], [AX_PROG_CC_FOR_BUILD])
+AC_DEFUN([AX_PROG_CC_FOR_BUILD], [dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_PROG_CPP])dnl
+AC_REQUIRE([AC_EXEEXT])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+
+dnl Use the standard macros, but make them use other variable names
+dnl
+pushdef([ac_cv_prog_CPP], ac_cv_build_prog_CPP)dnl
+pushdef([ac_cv_prog_gcc], ac_cv_build_prog_gcc)dnl
+pushdef([ac_cv_prog_cc_works], ac_cv_build_prog_cc_works)dnl
+pushdef([ac_cv_prog_cc_cross], ac_cv_build_prog_cc_cross)dnl
+pushdef([ac_cv_prog_cc_g], ac_cv_build_prog_cc_g)dnl
+pushdef([ac_cv_exeext], ac_cv_build_exeext)dnl
+pushdef([ac_cv_objext], ac_cv_build_objext)dnl
+pushdef([ac_exeext], ac_build_exeext)dnl
+pushdef([ac_objext], ac_build_objext)dnl
+pushdef([CC], CC_FOR_BUILD)dnl
+pushdef([CPP], CPP_FOR_BUILD)dnl
+pushdef([CFLAGS], CFLAGS_FOR_BUILD)dnl
+pushdef([CPPFLAGS], CPPFLAGS_FOR_BUILD)dnl
+pushdef([LDFLAGS], LDFLAGS_FOR_BUILD)dnl
+pushdef([host], build)dnl
+pushdef([host_alias], build_alias)dnl
+pushdef([host_cpu], build_cpu)dnl
+pushdef([host_vendor], build_vendor)dnl
+pushdef([host_os], build_os)dnl
+pushdef([ac_cv_host], ac_cv_build)dnl
+pushdef([ac_cv_host_alias], ac_cv_build_alias)dnl
+pushdef([ac_cv_host_cpu], ac_cv_build_cpu)dnl
+pushdef([ac_cv_host_vendor], ac_cv_build_vendor)dnl
+pushdef([ac_cv_host_os], ac_cv_build_os)dnl
+pushdef([ac_cpp], ac_build_cpp)dnl
+pushdef([ac_compile], ac_build_compile)dnl
+pushdef([ac_link], ac_build_link)dnl
+
+save_cross_compiling=$cross_compiling
+save_ac_tool_prefix=$ac_tool_prefix
+cross_compiling=no
+ac_tool_prefix=
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_EXEEXT
+
+ac_tool_prefix=$save_ac_tool_prefix
+cross_compiling=$save_cross_compiling
+
+dnl Restore the old definitions
+dnl
+popdef([ac_link])dnl
+popdef([ac_compile])dnl
+popdef([ac_cpp])dnl
+popdef([ac_cv_host_os])dnl
+popdef([ac_cv_host_vendor])dnl
+popdef([ac_cv_host_cpu])dnl
+popdef([ac_cv_host_alias])dnl
+popdef([ac_cv_host])dnl
+popdef([host_os])dnl
+popdef([host_vendor])dnl
+popdef([host_cpu])dnl
+popdef([host_alias])dnl
+popdef([host])dnl
+popdef([LDFLAGS])dnl
+popdef([CPPFLAGS])dnl
+popdef([CFLAGS])dnl
+popdef([CPP])dnl
+popdef([CC])dnl
+popdef([ac_objext])dnl
+popdef([ac_exeext])dnl
+popdef([ac_cv_objext])dnl
+popdef([ac_cv_exeext])dnl
+popdef([ac_cv_prog_cc_g])dnl
+popdef([ac_cv_prog_cc_cross])dnl
+popdef([ac_cv_prog_cc_works])dnl
+popdef([ac_cv_prog_gcc])dnl
+popdef([ac_cv_prog_CPP])dnl
+
+dnl Finally, set Makefile variables
+dnl
+BUILD_EXEEXT=$ac_build_exeext
+BUILD_OBJEXT=$ac_build_objext
+AC_SUBST(BUILD_EXEEXT)dnl
+AC_SUBST(BUILD_OBJEXT)dnl
+AC_SUBST([CFLAGS_FOR_BUILD])dnl
+AC_SUBST([CPPFLAGS_FOR_BUILD])dnl
+AC_SUBST([LDFLAGS_FOR_BUILD])dnl
+])
diff --git a/m4/ax_pthread.m4 b/m4/ax_pthread.m4
new file mode 100644
index 0000000..5fbf9fe
--- /dev/null
+++ b/m4/ax_pthread.m4
@@ -0,0 +1,485 @@
+# ===========================================================================
+#        https://www.gnu.org/software/autoconf-archive/ax_pthread.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])
+#
+# DESCRIPTION
+#
+#   This macro figures out how to build C programs using POSIX threads. It
+#   sets the PTHREAD_LIBS output variable to the threads library and linker
+#   flags, and the PTHREAD_CFLAGS output variable to any special C compiler
+#   flags that are needed. (The user can also force certain compiler
+#   flags/libs to be tested by setting these environment variables.)
+#
+#   Also sets PTHREAD_CC to any special C compiler that is needed for
+#   multi-threaded programs (defaults to the value of CC otherwise). (This
+#   is necessary on AIX to use the special cc_r compiler alias.)
+#
+#   NOTE: You are assumed to not only compile your program with these flags,
+#   but also to link with them as well. For example, you might link with
+#   $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS $LIBS
+#
+#   If you are only building threaded programs, you may wish to use these
+#   variables in your default LIBS, CFLAGS, and CC:
+#
+#     LIBS="$PTHREAD_LIBS $LIBS"
+#     CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+#     CC="$PTHREAD_CC"
+#
+#   In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute constant
+#   has a nonstandard name, this macro defines PTHREAD_CREATE_JOINABLE to
+#   that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).
+#
+#   Also HAVE_PTHREAD_PRIO_INHERIT is defined if pthread is found and the
+#   PTHREAD_PRIO_INHERIT symbol is defined when compiling with
+#   PTHREAD_CFLAGS.
+#
+#   ACTION-IF-FOUND is a list of shell commands to run if a threads library
+#   is found, and ACTION-IF-NOT-FOUND is a list of commands to run it if it
+#   is not found. If ACTION-IF-FOUND is not specified, the default action
+#   will define HAVE_PTHREAD.
+#
+#   Please let the authors know if this macro fails on any platform, or if
+#   you have any other suggestions or comments. This macro was based on work
+#   by SGJ on autoconf scripts for FFTW (http://www.fftw.org/) (with help
+#   from M. Frigo), as well as ac_pthread and hb_pthread macros posted by
+#   Alejandro Forero Cuervo to the autoconf macro repository. We are also
+#   grateful for the helpful feedback of numerous users.
+#
+#   Updated for Autoconf 2.68 by Daniel Richard G.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2011 Daniel Richard G. <skunk@iSKUNK.ORG>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 24
+
+AU_ALIAS([ACX_PTHREAD], [AX_PTHREAD])
+AC_DEFUN([AX_PTHREAD], [
+AC_REQUIRE([AC_CANONICAL_HOST])
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_PROG_SED])
+AC_LANG_PUSH([C])
+ax_pthread_ok=no
+
+# We used to check for pthread.h first, but this fails if pthread.h
+# requires special compiler flags (e.g. on Tru64 or Sequent).
+# It gets checked for in the link test anyway.
+
+# First of all, check if the user has set any of the PTHREAD_LIBS,
+# etcetera environment variables, and if threads linking works using
+# them:
+if test "x$PTHREAD_CFLAGS$PTHREAD_LIBS" != "x"; then
+        ax_pthread_save_CC="$CC"
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        AS_IF([test "x$PTHREAD_CC" != "x"], [CC="$PTHREAD_CC"])
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+        AC_MSG_CHECKING([for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS])
+        AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_join])], [ax_pthread_ok=yes])
+        AC_MSG_RESULT([$ax_pthread_ok])
+        if test "x$ax_pthread_ok" = "xno"; then
+                PTHREAD_LIBS=""
+                PTHREAD_CFLAGS=""
+        fi
+        CC="$ax_pthread_save_CC"
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+fi
+
+# We must check for the threads library under a number of different
+# names; the ordering is very important because some systems
+# (e.g. DEC) have both -lpthread and -lpthreads, where one of the
+# libraries is broken (non-POSIX).
+
+# Create a list of thread flags to try.  Items starting with a "-" are
+# C compiler flags, and other items are library names, except for "none"
+# which indicates that we try without any flags at all, and "pthread-config"
+# which is a program returning the flags for the Pth emulation library.
+
+ax_pthread_flags="pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
+
+# The ordering *is* (sometimes) important.  Some notes on the
+# individual items follow:
+
+# pthreads: AIX (must check this before -lpthread)
+# none: in case threads are in libc; should be tried before -Kthread and
+#       other compiler flags to prevent continual compiler warnings
+# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64
+#           (Note: HP C rejects this with "bad form for `-t' option")
+# -pthreads: Solaris/gcc (Note: HP C also rejects)
+# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
+#      doesn't hurt to check since this sometimes defines pthreads and
+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which
+#      is present but should not be used directly; and before -mthreads,
+#      because the compiler interprets this as "-mt" + "-hreads")
+# -mthreads: Mingw32/gcc, Lynx/gcc
+# pthread: Linux, etcetera
+# --thread-safe: KAI C++
+# pthread-config: use pthread-config program (for GNU Pth library)
+
+case $host_os in
+
+        freebsd*)
+
+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+
+        ax_pthread_flags="-kthread lthread $ax_pthread_flags"
+        ;;
+
+        hpux*)
+
+        # From the cc(1) man page: "[-mt] Sets various -D flags to enable
+        # multi-threading and also sets -lpthread."
+
+        ax_pthread_flags="-mt -pthread pthread $ax_pthread_flags"
+        ;;
+
+        openedition*)
+
+        # IBM z/OS requires a feature-test macro to be defined in order to
+        # enable POSIX threads at all, so give the user a hint if this is
+        # not set. (We don't define these ourselves, as they can affect
+        # other portions of the system API in unpredictable ways.)
+
+        AC_EGREP_CPP([AX_PTHREAD_ZOS_MISSING],
+            [
+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)
+             AX_PTHREAD_ZOS_MISSING
+#            endif
+            ],
+            [AC_MSG_WARN([IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support.])])
+        ;;
+
+        solaris*)
+
+        # On Solaris (at least, for some versions), libc contains stubbed
+        # (non-functional) versions of the pthreads routines, so link-based
+        # tests will erroneously succeed. (N.B.: The stubs are missing
+        # pthread_cleanup_push, or rather a function called by this macro,
+        # so we could check for that, but who knows whether they'll stub
+        # that too in a future libc.)  So we'll check first for the
+        # standard Solaris way of linking pthreads (-mt -lpthread).
+
+        ax_pthread_flags="-mt,pthread pthread $ax_pthread_flags"
+        ;;
+esac
+
+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)
+
+AS_IF([test "x$GCC" = "xyes"],
+      [ax_pthread_flags="-pthread -pthreads $ax_pthread_flags"])
+
+# The presence of a feature test macro requesting re-entrant function
+# definitions is, on some systems, a strong hint that pthreads support is
+# correctly enabled
+
+case $host_os in
+        darwin* | hpux* | linux* | osf* | solaris*)
+        ax_pthread_check_macro="_REENTRANT"
+        ;;
+
+        aix*)
+        ax_pthread_check_macro="_THREAD_SAFE"
+        ;;
+
+        *)
+        ax_pthread_check_macro="--"
+        ;;
+esac
+AS_IF([test "x$ax_pthread_check_macro" = "x--"],
+      [ax_pthread_check_cond=0],
+      [ax_pthread_check_cond="!defined($ax_pthread_check_macro)"])
+
+# Are we compiling with Clang?
+
+AC_CACHE_CHECK([whether $CC is Clang],
+    [ax_cv_PTHREAD_CLANG],
+    [ax_cv_PTHREAD_CLANG=no
+     # Note that Autoconf sets GCC=yes for Clang as well as GCC
+     if test "x$GCC" = "xyes"; then
+        AC_EGREP_CPP([AX_PTHREAD_CC_IS_CLANG],
+            [/* Note: Clang 2.7 lacks __clang_[a-z]+__ */
+#            if defined(__clang__) && defined(__llvm__)
+             AX_PTHREAD_CC_IS_CLANG
+#            endif
+            ],
+            [ax_cv_PTHREAD_CLANG=yes])
+     fi
+    ])
+ax_pthread_clang="$ax_cv_PTHREAD_CLANG"
+
+ax_pthread_clang_warning=no
+
+# Clang needs special handling, because older versions handle the -pthread
+# option in a rather... idiosyncratic way
+
+if test "x$ax_pthread_clang" = "xyes"; then
+
+        # Clang takes -pthread; it has never supported any other flag
+
+        # (Note 1: This will need to be revisited if a system that Clang
+        # supports has POSIX threads in a separate library.  This tends not
+        # to be the way of modern systems, but it's conceivable.)
+
+        # (Note 2: On some systems, notably Darwin, -pthread is not needed
+        # to get POSIX threads support; the API is always present and
+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But
+        # -pthread does define _REENTRANT, and while the Darwin headers
+        # ignore this macro, third-party headers might not.)
+
+        PTHREAD_CFLAGS="-pthread"
+        PTHREAD_LIBS=
+
+        ax_pthread_ok=yes
+
+        # However, older versions of Clang make a point of warning the user
+        # that, in an invocation where only linking and no compilation is
+        # taking place, the -pthread option has no effect ("argument unused
+        # during compilation").  They expect -pthread to be passed in only
+        # when source code is being compiled.
+        #
+        # Problem is, this is at odds with the way Automake and most other
+        # C build frameworks function, which is that the same flags used in
+        # compilation (CFLAGS) are also used in linking.  Many systems
+        # supported by AX_PTHREAD require exactly this for POSIX threads
+        # support, and in fact it is often not straightforward to specify a
+        # flag that is used only in the compilation phase and not in
+        # linking.  Such a scenario is extremely rare in practice.
+        #
+        # Even though use of the -pthread flag in linking would only print
+        # a warning, this can be a nuisance for well-run software projects
+        # that build with -Werror.  So if the active version of Clang has
+        # this misfeature, we search for an option to squash it.
+
+        AC_CACHE_CHECK([whether Clang needs flag to prevent "argument unused" warning when linking with -pthread],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown
+             # Create an alternate version of $ac_link that compiles and
+             # links in two steps (.c -> .o, .o -> exe) instead of one
+             # (.c -> exe), because the warning occurs only in the second
+             # step
+             ax_pthread_save_ac_link="$ac_link"
+             ax_pthread_sed='s/conftest\.\$ac_ext/conftest.$ac_objext/g'
+             ax_pthread_link_step=`$as_echo "$ac_link" | sed "$ax_pthread_sed"`
+             ax_pthread_2step_ac_link="($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)"
+             ax_pthread_save_CFLAGS="$CFLAGS"
+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do
+                AS_IF([test "x$ax_pthread_try" = "xunknown"], [break])
+                CFLAGS="-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS"
+                ac_link="$ax_pthread_save_ac_link"
+                AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                    [ac_link="$ax_pthread_2step_ac_link"
+                     AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                         [break])
+                    ])
+             done
+             ac_link="$ax_pthread_save_ac_link"
+             CFLAGS="$ax_pthread_save_CFLAGS"
+             AS_IF([test "x$ax_pthread_try" = "x"], [ax_pthread_try=no])
+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG="$ax_pthread_try"
+            ])
+
+        case "$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" in
+                no | unknown) ;;
+                *) PTHREAD_CFLAGS="$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS" ;;
+        esac
+
+fi # $ax_pthread_clang = yes
+
+if test "x$ax_pthread_ok" = "xno"; then
+for ax_pthread_try_flag in $ax_pthread_flags; do
+
+        case $ax_pthread_try_flag in
+                none)
+                AC_MSG_CHECKING([whether pthreads work without any flags])
+                ;;
+
+                -mt,pthread)
+                AC_MSG_CHECKING([whether pthreads work with -mt -lpthread])
+                PTHREAD_CFLAGS="-mt"
+                PTHREAD_LIBS="-lpthread"
+                ;;
+
+                -*)
+                AC_MSG_CHECKING([whether pthreads work with $ax_pthread_try_flag])
+                PTHREAD_CFLAGS="$ax_pthread_try_flag"
+                ;;
+
+                pthread-config)
+                AC_CHECK_PROG([ax_pthread_config], [pthread-config], [yes], [no])
+                AS_IF([test "x$ax_pthread_config" = "xno"], [continue])
+                PTHREAD_CFLAGS="`pthread-config --cflags`"
+                PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
+                ;;
+
+                *)
+                AC_MSG_CHECKING([for the pthreads library -l$ax_pthread_try_flag])
+                PTHREAD_LIBS="-l$ax_pthread_try_flag"
+                ;;
+        esac
+
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Check for various functions.  We must include pthread.h,
+        # since some functions may be macros.  (On the Sequent, we
+        # need a special flag -Kthread to make this header compile.)
+        # We check for pthread_join because it is in -lpthread on IRIX
+        # while pthread_create is in libc.  We check for pthread_attr_init
+        # due to DEC craziness with -lpthreads.  We check for
+        # pthread_cleanup_push because it is one of the few pthread
+        # functions on Solaris that doesn't have a non-functional libc stub.
+        # We try pthread_create on general principles.
+
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>
+#                       if $ax_pthread_check_cond
+#                        error "$ax_pthread_check_macro must be defined"
+#                       endif
+                        static void routine(void *a) { a = 0; }
+                        static void *start_routine(void *a) { return a; }],
+                       [pthread_t th; pthread_attr_t attr;
+                        pthread_create(&th, 0, start_routine, 0);
+                        pthread_join(th, 0);
+                        pthread_attr_init(&attr);
+                        pthread_cleanup_push(routine, 0);
+                        pthread_cleanup_pop(0) /* ; */])],
+            [ax_pthread_ok=yes],
+            [])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        AC_MSG_RESULT([$ax_pthread_ok])
+        AS_IF([test "x$ax_pthread_ok" = "xyes"], [break])
+
+        PTHREAD_LIBS=""
+        PTHREAD_CFLAGS=""
+done
+fi
+
+# Various other checks:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.
+        AC_CACHE_CHECK([for joinable pthread attribute],
+            [ax_cv_PTHREAD_JOINABLE_ATTR],
+            [ax_cv_PTHREAD_JOINABLE_ATTR=unknown
+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
+                 AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],
+                                                 [int attr = $ax_pthread_attr; return attr /* ; */])],
+                                [ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break],
+                                [])
+             done
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xunknown" && \
+               test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xPTHREAD_CREATE_JOINABLE" && \
+               test "x$ax_pthread_joinable_attr_defined" != "xyes"],
+              [AC_DEFINE_UNQUOTED([PTHREAD_CREATE_JOINABLE],
+                                  [$ax_cv_PTHREAD_JOINABLE_ATTR],
+                                  [Define to necessary symbol if this constant
+                                   uses a non-standard name on your system.])
+               ax_pthread_joinable_attr_defined=yes
+              ])
+
+        AC_CACHE_CHECK([whether more special flags are required for pthreads],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS=no
+             case $host_os in
+             solaris*)
+             ax_cv_PTHREAD_SPECIAL_FLAGS="-D_POSIX_PTHREAD_SEMANTICS"
+             ;;
+             esac
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_SPECIAL_FLAGS" != "xno" && \
+               test "x$ax_pthread_special_flags_added" != "xyes"],
+              [PTHREAD_CFLAGS="$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS"
+               ax_pthread_special_flags_added=yes])
+
+        AC_CACHE_CHECK([for PTHREAD_PRIO_INHERIT],
+            [ax_cv_PTHREAD_PRIO_INHERIT],
+            [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <pthread.h>]],
+                                             [[int i = PTHREAD_PRIO_INHERIT;]])],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=yes],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=no])
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_PRIO_INHERIT" = "xyes" && \
+               test "x$ax_pthread_prio_inherit_defined" != "xyes"],
+              [AC_DEFINE([HAVE_PTHREAD_PRIO_INHERIT], [1], [Have PTHREAD_PRIO_INHERIT.])
+               ax_pthread_prio_inherit_defined=yes
+              ])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        # More AIX lossage: compile with *_r variant
+        if test "x$GCC" != "xyes"; then
+            case $host_os in
+                aix*)
+                AS_CASE(["x/$CC"],
+                    [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],
+                    [#handle absolute path differently from PATH based program lookup
+                     AS_CASE(["x$CC"],
+                         [x/*],
+                         [AS_IF([AS_EXECUTABLE_P([${CC}_r])],[PTHREAD_CC="${CC}_r"])],
+                         [AC_CHECK_PROGS([PTHREAD_CC],[${CC}_r],[$CC])])])
+                ;;
+            esac
+        fi
+fi
+
+test -n "$PTHREAD_CC" || PTHREAD_CC="$CC"
+
+AC_SUBST([PTHREAD_LIBS])
+AC_SUBST([PTHREAD_CFLAGS])
+AC_SUBST([PTHREAD_CC])
+
+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ifelse([$1],,[AC_DEFINE([HAVE_PTHREAD],[1],[Define if you have POSIX threads libraries and header files.])],[$1])
+        :
+else
+        ax_pthread_ok=no
+        $2
+fi
+AC_LANG_POP
+])dnl AX_PTHREAD
diff --git a/m4/pkg.m4 b/m4/pkg.m4
new file mode 100644
index 0000000..13a8890
--- /dev/null
+++ b/m4/pkg.m4
@@ -0,0 +1,275 @@
+# pkg.m4 - Macros to locate and utilise pkg-config.   -*- Autoconf -*-
+# serial 12 (pkg-config-0.29.2)
+
+dnl Copyright © 2004 Scott James Remnant <scott@netsplit.com>.
+dnl Copyright © 2012-2015 Dan Nicholson <dbn.lists@gmail.com>
+dnl
+dnl This program is free software; you can redistribute it and/or modify
+dnl it under the terms of the GNU General Public License as published by
+dnl the Free Software Foundation; either version 2 of the License, or
+dnl (at your option) any later version.
+dnl
+dnl This program is distributed in the hope that it will be useful, but
+dnl WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+dnl General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU General Public License
+dnl along with this program; if not, write to the Free Software
+dnl Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+dnl 02111-1307, USA.
+dnl
+dnl As a special exception to the GNU General Public License, if you
+dnl distribute this file as part of a program that contains a
+dnl configuration script generated by Autoconf, you may include it under
+dnl the same distribution terms that you use for the rest of that
+dnl program.
+
+dnl PKG_PREREQ(MIN-VERSION)
+dnl -----------------------
+dnl Since: 0.29
+dnl
+dnl Verify that the version of the pkg-config macros are at least
+dnl MIN-VERSION. Unlike PKG_PROG_PKG_CONFIG, which checks the user's
+dnl installed version of pkg-config, this checks the developer's version
+dnl of pkg.m4 when generating configure.
+dnl
+dnl To ensure that this macro is defined, also add:
+dnl m4_ifndef([PKG_PREREQ],
+dnl     [m4_fatal([must install pkg-config 0.29 or later before running autoconf/autogen])])
+dnl
+dnl See the "Since" comment for each macro you use to see what version
+dnl of the macros you require.
+m4_defun([PKG_PREREQ],
+[m4_define([PKG_MACROS_VERSION], [0.29.2])
+m4_if(m4_version_compare(PKG_MACROS_VERSION, [$1]), -1,
+    [m4_fatal([pkg.m4 version $1 or higher is required but ]PKG_MACROS_VERSION[ found])])
+])dnl PKG_PREREQ
+
+dnl PKG_PROG_PKG_CONFIG([MIN-VERSION])
+dnl ----------------------------------
+dnl Since: 0.16
+dnl
+dnl Search for the pkg-config tool and set the PKG_CONFIG variable to
+dnl first found in the path. Checks that the version of pkg-config found
+dnl is at least MIN-VERSION. If MIN-VERSION is not specified, 0.9.0 is
+dnl used since that's the first version where most current features of
+dnl pkg-config existed.
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])
+m4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
+AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
+AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+fi[]dnl
+])dnl PKG_PROG_PKG_CONFIG
+
+dnl PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+dnl -------------------------------------------------------------------
+dnl Since: 0.18
+dnl
+dnl Check to see whether a particular set of modules exists. Similar to
+dnl PKG_CHECK_MODULES(), but does not set variables or print errors.
+dnl
+dnl Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+dnl only at the first occurence in configure.ac, so if the first place
+dnl it's called might be skipped (such as if it is within an "if", you
+dnl have to call PKG_CHECK_EXISTS manually
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_default([$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+dnl _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+dnl ---------------------------------------------
+dnl Internal wrapper calling pkg-config via PKG_CONFIG and setting
+dnl pkg_failed based on the result.
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes ],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])dnl _PKG_CONFIG
+
+dnl _PKG_SHORT_ERRORS_SUPPORTED
+dnl ---------------------------
+dnl Internal check to see if pkg-config supports short errors.
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])dnl _PKG_SHORT_ERRORS_SUPPORTED
+
+
+dnl PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl   [ACTION-IF-NOT-FOUND])
+dnl --------------------------------------------------------------
+dnl Since: 0.4.0
+dnl
+dnl Note that if there is a possibility the first call to
+dnl PKG_CHECK_MODULES might not happen, you should be sure to include an
+dnl explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $2])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+        AC_MSG_RESULT([no])
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
+        else
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	m4_default([$4], [AC_MSG_ERROR(
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT])[]dnl
+        ])
+elif test $pkg_failed = untried; then
+        AC_MSG_RESULT([no])
+	m4_default([$4], [AC_MSG_FAILURE(
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl
+        ])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	$3
+fi[]dnl
+])dnl PKG_CHECK_MODULES
+
+
+dnl PKG_CHECK_MODULES_STATIC(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl   [ACTION-IF-NOT-FOUND])
+dnl ---------------------------------------------------------------------
+dnl Since: 0.29
+dnl
+dnl Checks for existence of MODULES and gathers its build flags with
+dnl static libraries enabled. Sets VARIABLE-PREFIX_CFLAGS from --cflags
+dnl and VARIABLE-PREFIX_LIBS from --libs.
+dnl
+dnl Note that if there is a possibility the first call to
+dnl PKG_CHECK_MODULES_STATIC might not happen, you should be sure to
+dnl include an explicit call to PKG_PROG_PKG_CONFIG in your
+dnl configure.ac.
+AC_DEFUN([PKG_CHECK_MODULES_STATIC],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+_save_PKG_CONFIG=$PKG_CONFIG
+PKG_CONFIG="$PKG_CONFIG --static"
+PKG_CHECK_MODULES($@)
+PKG_CONFIG=$_save_PKG_CONFIG[]dnl
+])dnl PKG_CHECK_MODULES_STATIC
+
+
+dnl PKG_INSTALLDIR([DIRECTORY])
+dnl -------------------------
+dnl Since: 0.27
+dnl
+dnl Substitutes the variable pkgconfigdir as the location where a module
+dnl should install pkg-config .pc files. By default the directory is
+dnl $libdir/pkgconfig, but the default can be changed by passing
+dnl DIRECTORY. The user can override through the --with-pkgconfigdir
+dnl parameter.
+AC_DEFUN([PKG_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([pkgconfigdir],
+    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,
+    [with_pkgconfigdir=]pkg_default)
+AC_SUBST([pkgconfigdir], [$with_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+])dnl PKG_INSTALLDIR
+
+
+dnl PKG_NOARCH_INSTALLDIR([DIRECTORY])
+dnl --------------------------------
+dnl Since: 0.27
+dnl
+dnl Substitutes the variable noarch_pkgconfigdir as the location where a
+dnl module should install arch-independent pkg-config .pc files. By
+dnl default the directory is $datadir/pkgconfig, but the default can be
+dnl changed by passing DIRECTORY. The user can override through the
+dnl --with-noarch-pkgconfigdir parameter.
+AC_DEFUN([PKG_NOARCH_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([noarch-pkgconfigdir],
+    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,
+    [with_noarch_pkgconfigdir=]pkg_default)
+AC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+])dnl PKG_NOARCH_INSTALLDIR
+
+
+dnl PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,
+dnl [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+dnl -------------------------------------------
+dnl Since: 0.28
+dnl
+dnl Retrieves the value of the pkg-config variable for the given module.
+AC_DEFUN([PKG_CHECK_VAR],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl
+
+_PKG_CONFIG([$1], [variable="][$3]["], [$2])
+AS_VAR_COPY([$1], [pkg_cv_][$1])
+
+AS_VAR_IF([$1], [""], [$5], [$4])dnl
+])dnl PKG_CHECK_VAR
diff --git a/splash/CMakeLists.txt b/splash/CMakeLists.txt
deleted file mode 100644
index f84968c..0000000
--- a/splash/CMakeLists.txt
+++ /dev/null
@@ -1,47 +0,0 @@
-#========================================================================
-#
-# splash/CMakeLists.txt
-#
-# CMake script for the splash library.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-if (HAVE_SPLASH)
-  include_directories("${PROJECT_SOURCE_DIR}")
-  include_directories("${PROJECT_BINARY_DIR}")
-  include_directories("${PROJECT_SOURCE_DIR}/goo")
-  include_directories("${PROJECT_SOURCE_DIR}/fofi")
-  include_directories("${FREETYPE_INCLUDE_DIRS}")
-
-  if (HAVE_DTYPE4_H)
-    include_directories("${DTYPE_INCLUDE_DIR}")
-    set(DTYPE_SRCS
-        SplashDT4Font.cc SplashDT4FontEngine.cc SplashDT4FontFile.cc)
-  endif ()
-
-  add_library(splash_objs OBJECT
-    Splash.cc
-    SplashBitmap.cc
-    SplashClip.cc
-    SplashFTFont.cc
-    SplashFTFontEngine.cc
-    SplashFTFontFile.cc
-    SplashFont.cc
-    SplashFontEngine.cc
-    SplashFontFile.cc
-    SplashFontFileID.cc
-    SplashPath.cc
-    SplashPattern.cc
-    SplashScreen.cc
-    SplashState.cc
-    SplashXPath.cc
-    SplashXPathScanner.cc
-    ${DTYPE_SRCS}
-  )
-
-  add_library(splash
-    $<TARGET_OBJECTS:splash_objs>
-  )
-endif ()
diff --git a/splash/Makefile.am b/splash/Makefile.am
new file mode 100644
index 0000000..711ca80
--- /dev/null
+++ b/splash/Makefile.am
@@ -0,0 +1,26 @@
+noinst_LIBRARIES = libsplash.a
+
+AM_CPPFLAGS = -I$(top_builddir) -I$(srcdir) -I$(top_srcdir)/goo -I$(top_srcdir)/fofi $(FREETYPE2_CFLAGS)
+
+libsplash_a_SOURCES = \
+	Splash.cc Splash.h \
+	SplashBitmap.cc SplashBitmap.h \
+	SplashClip.cc SplashClip.h \
+	SplashErrorCodes.h \
+	SplashFTFont.cc SplashFTFont.h \
+	SplashFTFontEngine.cc SplashFTFontEngine.h \
+	SplashFTFontFile.cc SplashFTFontFile.h \
+	SplashFont.cc SplashFont.h \
+	SplashFontEngine.cc SplashFontEngine.h \
+	SplashFontFile.cc SplashFontFile.h \
+	SplashFontFileID.cc SplashFontFileID.h \
+	SplashGlyphBitmap.h \
+	SplashMath.h \
+	SplashPath.cc SplashPath.h \
+	SplashPattern.cc SplashPattern.h \
+	SplashScreen.cc SplashScreen.h \
+	SplashState.cc SplashState.h \
+	SplashTypes.h \
+	SplashXPath.cc SplashXPath.h \
+	SplashXPathScanner.cc SplashXPathScanner.h \
+	$(empty)
diff --git a/splash/Splash.cc b/splash/Splash.cc
index 77718ab..3230c9a 100644
--- a/splash/Splash.cc
+++ b/splash/Splash.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
@@ -99,7 +95,7 @@ SplashPipeResultColorCtrl Splash::pipeResultColorNoAlphaBlend[] = {
   splashPipeResultColorNoAlphaBlendMono,
   splashPipeResultColorNoAlphaBlendRGB,
   splashPipeResultColorNoAlphaBlendRGB
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   ,
   splashPipeResultColorNoAlphaBlendCMYK
 #endif
@@ -110,7 +106,7 @@ SplashPipeResultColorCtrl Splash::pipeResultColorAlphaNoBlend[] = {
   splashPipeResultColorAlphaNoBlendMono,
   splashPipeResultColorAlphaNoBlendRGB,
   splashPipeResultColorAlphaNoBlendRGB
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   ,
   splashPipeResultColorAlphaNoBlendCMYK
 #endif
@@ -121,7 +117,7 @@ SplashPipeResultColorCtrl Splash::pipeResultColorAlphaBlend[] = {
   splashPipeResultColorAlphaBlendMono,
   splashPipeResultColorAlphaBlendRGB,
   splashPipeResultColorAlphaBlendRGB
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   ,
   splashPipeResultColorAlphaBlendCMYK
 #endif
@@ -220,7 +216,7 @@ inline void Splash::pipeInit(SplashPipe *pipe, SplashPattern *pattern,
       pipe->run = &Splash::pipeRunSimpleRGB8;
     } else if (mode == splashModeBGR8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunSimpleBGR8;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     } else if (mode == splashModeCMYK8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunSimpleCMYK8;
 #endif
@@ -234,7 +230,7 @@ inline void Splash::pipeInit(SplashPipe *pipe, SplashPattern *pattern,
       pipe->run = &Splash::pipeRunShapeRGB8;
     } else if (mode == splashModeBGR8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunShapeBGR8;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     } else if (mode == splashModeCMYK8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunShapeCMYK8;
 #endif
@@ -252,7 +248,7 @@ inline void Splash::pipeInit(SplashPipe *pipe, SplashPattern *pattern,
       pipe->run = &Splash::pipeRunAARGB8;
     } else if (mode == splashModeBGR8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunAABGR8;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     } else if (mode == splashModeCMYK8 && bitmap->alpha) {
       pipe->run = &Splash::pipeRunAACMYK8;
 #endif
@@ -275,7 +271,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
   Guchar color0Mask;
   Guchar *alpha0Ptr;
   SplashColorPtr softMaskPtr;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   SplashColor cSrc2, cDest2;
 #endif
 
@@ -412,7 +408,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	cResult1 = state->rgbTransferG[cSrcPtr[1]];
 	cResult2 = state->rgbTransferB[cSrcPtr[2]];
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	cResult0 = state->cmykTransferC[cSrcPtr[0]];
 	cResult1 = state->cmykTransferM[cSrcPtr[1]];
@@ -451,7 +447,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	  cDest[0] = color0Ptr[2];
 	  color0Ptr += 3;
 	  break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 	case splashModeCMYK8:
 	  cDest[0] = color0Ptr[0];
 	  cDest[1] = color0Ptr[1];
@@ -481,7 +477,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	  cDest[1] = destColorPtr[1];
 	  cDest[2] = destColorPtr[0];
 	  break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 	case splashModeCMYK8:
 	  cDest[0] = destColorPtr[0];
 	  cDest[1] = destColorPtr[1];
@@ -512,7 +508,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	cSrc[1] = state->rgbTransferG[cSrcPtr[1]];
 	cSrc[2] = state->rgbTransferB[cSrcPtr[2]];
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	if (state->overprintMask & 0x01) {
 	  cSrc[0] = state->cmykTransferC[cSrcPtr[0]];
@@ -560,14 +556,16 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	// case, shape is the source (group) alpha.
 	t = (aDest * 255) / shape - aDest;
 	switch (bitmap->mode) {
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 	case splashModeCMYK8:
 	  cSrc[3] = clip255(cSrc[3] + ((cSrc[3] - cDest[3]) * t) / 255);
 #endif
+	  /* fall through */
 	case splashModeRGB8:
 	case splashModeBGR8:
 	  cSrc[2] = clip255(cSrc[2] + ((cSrc[2] - cDest[2]) * t) / 255);
 	  cSrc[1] = clip255(cSrc[1] + ((cSrc[1] - cDest[1]) * t) / 255);
+	  /* fall through */
 	case splashModeMono1:
 	case splashModeMono8:
 	  cSrc[0] = clip255(cSrc[0] + ((cSrc[0] - cDest[0]) * t) / 255);
@@ -578,7 +576,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
       //----- blend function
 
       if (state->blendFunc) {
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 	if (bitmap->mode == splashModeCMYK8) {
 	  // convert colors to additive
 	  cSrc2[0] = (Guchar)(0xff - cSrc[0]);
@@ -647,7 +645,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 	cResult1 = div255((255 - aDest) * cSrc[1] + aDest * cBlend[1]);
 	cResult2 = div255((255 - aDest) * cSrc[2] + aDest * cBlend[2]);
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashPipeResultColorNoAlphaBlendCMYK:
 	cResult0 = div255((255 - aDest) * cSrc[0] + aDest * cBlend[0]);
 	cResult1 = div255((255 - aDest) * cSrc[1] + aDest * cBlend[1]);
@@ -678,7 +676,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 			      / alphaI);
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashPipeResultColorAlphaNoBlendCMYK:
 	if (alphaI == 0) {
 	  cResult0 = 0;
@@ -728,7 +726,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
 			      / alphaI);
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashPipeResultColorAlphaBlendCMYK:
 	if (alphaI == 0) {
 	  cResult0 = 0;
@@ -786,7 +784,7 @@ void Splash::pipeRun(SplashPipe *pipe, int x0, int x1, int y,
       destColorPtr[2] = cResult0;
       destColorPtr += 3;
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       destColorPtr[0] = cResult0;
       destColorPtr[1] = cResult1;
@@ -818,6 +816,7 @@ void Splash::pipeRunSimpleMono1(SplashPipe *pipe, int x0, int x1, int y,
   SplashScreenCursor screenCursor;
   int cSrcStride, x;
 
+  (void)shapePtr;
   if (cSrcPtr) {
     cSrcStride = 1;
   } else {
@@ -861,6 +860,7 @@ void Splash::pipeRunSimpleMono8(SplashPipe *pipe, int x0, int x1, int y,
   Guchar *destAlphaPtr;
   int cSrcStride, x;
 
+  (void)shapePtr;
   if (cSrcPtr) {
     cSrcStride = 1;
   } else {
@@ -896,6 +896,7 @@ void Splash::pipeRunSimpleRGB8(SplashPipe *pipe, int x0, int x1, int y,
   Guchar *destAlphaPtr;
   int cSrcStride, x;
 
+  (void)shapePtr;
   if (cSrcPtr) {
     cSrcStride = 3;
   } else {
@@ -934,6 +935,7 @@ void Splash::pipeRunSimpleBGR8(SplashPipe *pipe, int x0, int x1, int y,
   Guchar *destAlphaPtr;
   int cSrcStride, x;
 
+  (void)shapePtr;
   if (cSrcPtr) {
     cSrcStride = 3;
   } else {
@@ -963,7 +965,7 @@ void Splash::pipeRunSimpleBGR8(SplashPipe *pipe, int x0, int x1, int y,
   }
 }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 // special case:
 // !pipe->pattern && pipe->noTransparency && !state->blendFunc &&
 // bitmap->mode == splashModeCMYK8 && bitmap->alpha) {
@@ -973,6 +975,7 @@ void Splash::pipeRunSimpleCMYK8(SplashPipe *pipe, int x0, int x1, int y,
   Guchar *destAlphaPtr;
   int cSrcStride, x;
 
+  (void)shapePtr;
   if (cSrcPtr) {
     cSrcStride = 4;
   } else {
@@ -1391,7 +1394,7 @@ void Splash::pipeRunShapeBGR8(SplashPipe *pipe, int x0, int x1, int y,
   updateModX(lastX);
 }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 // special case:
 // !pipe->pattern && pipe->shapeOnly && !state->blendFunc &&
 // bitmap->mode == splashModeCMYK8 && bitmap->alpha
@@ -1868,7 +1871,7 @@ void Splash::pipeRunAABGR8(SplashPipe *pipe, int x0, int x1, int y,
   updateModX(lastX);
 }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 // special case:
 // !pipe->pattern && !pipe->noTransparency && !state->softMask &&
 // pipe->usesShape && !pipe->alpha0Ptr && !state->blendFunc &&
@@ -2344,7 +2347,7 @@ void Splash::clear(SplashColorPtr color, Guchar alpha) {
       }
     }
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     if (color[0] == color[1] && color[1] == color[2] && color[2] == color[3]) {
       if (bitmap->rowSize < 0) {
@@ -2642,7 +2645,7 @@ SplashPath *Splash::flattenPath(SplashPath *path, SplashCoord *matrix,
   int i;
 
   fPath = new SplashPath();
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   flatness2 = flatness;
 #else
   flatness2 = flatness * flatness;
@@ -2711,7 +2714,7 @@ void Splash::flattenCurve(SplashCoord x0, SplashCoord y0,
     // line)
     transform(matrix, (xl0 + xr3) * 0.5, (yl0 + yr3) * 0.5, &mx, &my);
     transform(matrix, xx1, yy1, &tx, &ty);
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
     d1 = splashDist(tx, ty, mx, my);
 #else
     dx = tx - mx;
@@ -2719,7 +2722,7 @@ void Splash::flattenCurve(SplashCoord x0, SplashCoord y0,
     d1 = dx*dx + dy*dy;
 #endif
     transform(matrix, xx2, yy2, &tx, &ty);
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
     d2 = splashDist(tx, ty, mx, my);
 #else
     dx = tx - mx;
@@ -2909,10 +2912,13 @@ SplashPath *Splash::makeDashedPath(SplashPath *path) {
 	  dPath->lineTo(dPath->pts[k].x, dPath->pts[k].y);
 	} while (!(dPath->flags[k] & splashPathLast));
 	++k;
+#pragma GCC diagnostic ignored "-Wpragmas"
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
 	memmove(&dPath->pts[subpathStart], &dPath->pts[k],
 		(dPath->length - k) * sizeof(SplashPathPoint));
 	memmove(&dPath->flags[subpathStart], &dPath->flags[k],
 		(dPath->length - k) * sizeof(Guchar));
+#pragma GCC diagnostic warning "-Wclass-memaccess"
 	dPath->length -= k - subpathStart;
 	dPath->curSubpath -= k - subpathStart;
       }
@@ -3380,7 +3386,7 @@ SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,
   // stream-mode upscaling -- this is slower, so we only use it if the
   // upscaled mask is large (in which case clipping should remove many
   // pixels)
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   if ((wSize > 2 * w && hSize > 2 * h && (int)wSize > 1000000 / (int)hSize) ||
       (wSize >     w && hSize >     h && (int)wSize > 10000000 / (int)hSize) ||
       ((wSize > w || hSize > h) && (int)wSize > 25000000 / (int)hSize)) {
@@ -3481,6 +3487,7 @@ void Splash::upscaleMask(SplashImageMaskSource src, void *srcData,
   SplashCoord ix, iy, sx, sy, pix0, pix1;
   int xMinI, yMinI, xMaxI, yMaxI, x, y, x0, y0, x1, y1, tt;
 
+  (void)glyphMode;
   // compute the bbox of the target quadrilateral
   xMin = xMax = mat[4];
   t = mat[2] + mat[4];
@@ -3649,6 +3656,7 @@ void Splash::arbitraryTransformMask(SplashImageMaskSource src, void *srcData,
   int nSections;
   int bw, y, xa, xb, x, i, xx, yy;
 
+  (void)glyphMode;
   // compute the four vertices of the target quadrilateral
   vx[0] = mat[4];                    vy[0] = mat[5];
   vx[1] = mat[2] + mat[4];           vy[1] = mat[3] + mat[5];
@@ -4435,7 +4443,7 @@ SplashError Splash::drawImage(SplashImageSource src, void *srcData,
     ok = srcMode == splashModeRGB8;
     nComps = 3;
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     ok = srcMode == splashModeCMYK8;
     nComps = 4;
@@ -4467,7 +4475,7 @@ SplashError Splash::drawImage(SplashImageSource src, void *srcData,
   // stream-mode upscaling -- this is slower, so we only use it if the
   // upscaled image is large (in which case clipping should remove
   // many pixels)
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   if ((wSize > 2 * w && hSize > 2 * h && (int)wSize > 1000000 / (int)hSize) ||
       (wSize >     w && hSize >     h && (int)wSize > 10000000 / (int)hSize) ||
       ((wSize > w || hSize > h) && (int)wSize > 25000000 / (int)hSize)) {
@@ -4570,6 +4578,7 @@ void Splash::upscaleImage(SplashImageSource src, void *srcData,
   SplashBitmapRowSize rowSize;
   int xMinI, yMinI, xMaxI, yMaxI, x, y, x0, y0, x1, y1, tt, i;
 
+  (void)srcMode;
   // compute the bbox of the target quadrilateral
   xMin = xMax = mat[4];
   t = mat[2] + mat[4];
@@ -5090,7 +5099,7 @@ void Splash::scaleImageYdXd(SplashImageSource src, void *srcData,
   Guchar *lineBuf, *alphaLineBuf;
   Guint *pixBuf, *alphaPixBuf;
   Guint pix0, pix1, pix2;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   Guint pix3;
 #endif
   Guint alpha;
@@ -5204,7 +5213,7 @@ void Splash::scaleImageYdXd(SplashImageSource src, void *srcData,
 	*destPtr++ = (Guchar)pix2;
 	break;
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 
 	// compute the final pixel
@@ -5290,7 +5299,7 @@ void Splash::scaleImageYdXu(SplashImageSource src, void *srcData,
 
   // make gcc happy
   pix[0] = pix[1] = pix[2] = 0;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   pix[3] = 0;
 #endif
 
@@ -5360,7 +5369,7 @@ void Splash::scaleImageYdXu(SplashImageSource src, void *srcData,
 	  *destPtr++ = (Guchar)pix[2];
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	for (i = 0; i < xStep; ++i) {
 	  *destPtr++ = (Guchar)pix[0];
@@ -5423,7 +5432,7 @@ void Splash::scaleImageYuXd(SplashImageSource src, void *srcData,
 
   // make gcc happy
   pix[0] = pix[1] = pix[2] = 0;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   pix[3] = 0;
 #endif
 
@@ -5493,7 +5502,7 @@ void Splash::scaleImageYuXd(SplashImageSource src, void *srcData,
 	  *destPtr++ = (Guchar)pix[2];
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	for (i = 0; i < yStep; ++i) {
 	  destPtr = destPtr0 + (i * scaledWidth + x) * nComps;
@@ -5542,7 +5551,7 @@ void Splash::scaleImageYuXu(SplashImageSource src, void *srcData,
 			    SplashBitmap *dest) {
   Guchar *lineBuf, *alphaLineBuf;
   Guchar pix0, pix1, pix2;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   Guchar pix3;
 #endif
   Guchar alpha;
@@ -5619,7 +5628,7 @@ void Splash::scaleImageYuXu(SplashImageSource src, void *srcData,
 	  *destPtr++ = pix2;
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	pix0 = *srcPtr++;
 	pix1 = *srcPtr++;
@@ -5737,7 +5746,7 @@ void Splash::scaleImageYuXuI(SplashImageSource src, void *srcData,
 
   // make gcc happy
   pix[0] = pix[1] = pix[2] = 0;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   pix[3] = 0;
 #endif
 
@@ -5815,7 +5824,7 @@ void Splash::scaleImageYuXuI(SplashImageSource src, void *srcData,
 	*destPtr++ = pix[1];
 	*destPtr++ = pix[2];
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	*destPtr++ = pix[0];
 	*destPtr++ = pix[1];
@@ -6339,7 +6348,7 @@ void Splash::compositeBackground(SplashColorPtr color) {
   SplashColorPtr p;
   Guchar *q;
   Guchar alpha, alpha1, c, color0, color1, color2, mask;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   Guchar color3;
 #endif
   int x, y;
@@ -6417,7 +6426,7 @@ void Splash::compositeBackground(SplashColorPtr color) {
       }
     }
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     color0 = color[0];
     color1 = color[1];
@@ -6498,7 +6507,7 @@ SplashError Splash::blitTransparent(SplashBitmap *src, int xSrc, int ySrc,
       memcpy(p, q, 3 * w);
     }
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     for (y = 0; y < h; ++y) {
       p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];
@@ -6572,7 +6581,7 @@ SplashError Splash::blitCorrectedAlpha(SplashBitmap *dest, int xSrc, int ySrc,
       memcpy(p, q, 3 * w);
     }
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     for (y = 0; y < h; ++y) {
       p = &dest->data[(yDest + y) * dest->rowSize + 4 * xDest];
@@ -6716,7 +6725,7 @@ SplashPath *Splash::makeStrokePath(SplashPath *path, SplashCoord w,
 	 ++k1) ;
 
     // compute the deltas for segment (i1, j0)
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
     // the 1/d value can be small, which introduces significant
     // inaccuracies in fixed point mode
     d = splashDist(pathIn->pts[i1].x, pathIn->pts[i1].y,
@@ -6815,7 +6824,7 @@ SplashPath *Splash::makeStrokePath(SplashPath *path, SplashCoord w,
     if (!last || closed) {
 
       // compute the deltas for segment (j1, k0)
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
       // the 1/d value can be small, which introduces significant
       // inaccuracies in fixed point mode
       d = splashDist(pathIn->pts[j1].x, pathIn->pts[j1].y,
diff --git a/splash/Splash.h b/splash/Splash.h
index 423ed36..86e5f2c 100644
--- a/splash/Splash.h
+++ b/splash/Splash.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 #include "SplashClip.h"
 
@@ -48,17 +44,17 @@ typedef GBool (*SplashImageSource)(void *data, SplashColorPtr colorLine,
 enum SplashPipeResultColorCtrl {
   splashPipeResultColorNoAlphaBlendMono,
   splashPipeResultColorNoAlphaBlendRGB,
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   splashPipeResultColorNoAlphaBlendCMYK,
 #endif
   splashPipeResultColorAlphaNoBlendMono,
   splashPipeResultColorAlphaNoBlendRGB,
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   splashPipeResultColorAlphaNoBlendCMYK,
 #endif
   splashPipeResultColorAlphaBlendMono,
   splashPipeResultColorAlphaBlendRGB
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   ,
   splashPipeResultColorAlphaBlendCMYK
 #endif
@@ -275,7 +271,7 @@ private:
 			 Guchar *shapePtr, SplashColorPtr cSrcPtr);
   void pipeRunSimpleBGR8(SplashPipe *pipe, int x0, int x1, int y,
 			 Guchar *shapePtr, SplashColorPtr cSrcPtr);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   void pipeRunSimpleCMYK8(SplashPipe *pipe, int x0, int x1, int y,
 			  Guchar *shapePtr, SplashColorPtr cSrcPtr);
 #endif
@@ -287,7 +283,7 @@ private:
 			Guchar *shapePtr, SplashColorPtr cSrcPtr);
   void pipeRunShapeBGR8(SplashPipe *pipe, int x0, int x1, int y,
 			Guchar *shapePtr, SplashColorPtr cSrcPtr);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   void pipeRunShapeCMYK8(SplashPipe *pipe, int x0, int x1, int y,
 			 Guchar *shapePtr, SplashColorPtr cSrcPtr);
 #endif
@@ -299,7 +295,7 @@ private:
 		     Guchar *shapePtr, SplashColorPtr cSrcPtr);
   void pipeRunAABGR8(SplashPipe *pipe, int x0, int x1, int y,
 		     Guchar *shapePtr, SplashColorPtr cSrcPtr);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   void pipeRunAACMYK8(SplashPipe *pipe, int x0, int x1, int y,
 		      Guchar *shapePtr, SplashColorPtr cSrcPtr);
 #endif
diff --git a/splash/SplashBitmap.cc b/splash/SplashBitmap.cc
index aa91617..76c81a1 100644
--- a/splash/SplashBitmap.cc
+++ b/splash/SplashBitmap.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <limits.h>
 #include "gmem.h"
@@ -52,7 +48,7 @@ SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,
     }
     rowSize = (SplashBitmapRowSize)width * 3;
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     if (width <= 0 || width > INT_MAX / 4) {
       gMemError("invalid bitmap width");
@@ -152,7 +148,7 @@ SplashError SplashBitmap::writePNMFile(FILE *f) {
     }
     break;
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     fprintf(f, "P7\n");
     fprintf(f, "WIDTH %d\n", width);
@@ -217,7 +213,7 @@ void SplashBitmap::getPixel(int x, int y, SplashColorPtr pixel) {
     pixel[1] = p[1];
     pixel[2] = p[0];
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     p = &data[y * rowSize + 4 * x];
     pixel[0] = p[0];
diff --git a/splash/SplashBitmap.h b/splash/SplashBitmap.h
index d03f44c..2b6f4fa 100644
--- a/splash/SplashBitmap.h
+++ b/splash/SplashBitmap.h
@@ -10,10 +10,7 @@
 #define SPLASHBITMAP_H
 
 #include <aconf.h>
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
+#define __STDC_LIMIT_MACROS
 
 #include <stdio.h>
 #include <limits.h>
diff --git a/splash/SplashClip.cc b/splash/SplashClip.cc
index bf7b802..bd14e89 100644
--- a/splash/SplashClip.cc
+++ b/splash/SplashClip.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include "gmem.h"
diff --git a/splash/SplashClip.h b/splash/SplashClip.h
index fb86ed8..d748f98 100644
--- a/splash/SplashClip.h
+++ b/splash/SplashClip.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 #include "SplashMath.h"
 
diff --git a/splash/SplashFTFont.cc b/splash/SplashFTFont.cc
index 9148144..80847fd 100644
--- a/splash/SplashFTFont.cc
+++ b/splash/SplashFTFont.cc
@@ -8,11 +8,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
+#ifdef HAVE_FREETYPE
 
 #include <ft2build.h>
 #include FT_OUTLINE_H
@@ -48,7 +44,7 @@ SplashFTFont::SplashFTFont(SplashFTFontFile *fontFileA, SplashCoord *matA,
   FT_Face face;
   int size, div;
   int x, y;
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   SplashCoord scale;
 #endif
 
@@ -74,7 +70,7 @@ SplashFTFont::SplashFTFont(SplashFTFontFile *fontFileA, SplashCoord *matA,
 
   div = face->bbox.xMax > 20000 ? 65536 : 1;
 
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   scale = (SplashCoord)1 / (SplashCoord)face->units_per_EM;
 
   // transform the four corners of the font bounding box -- the min
@@ -127,7 +123,7 @@ SplashFTFont::SplashFTFont(SplashFTFontFile *fontFileA, SplashCoord *matA,
   } else if (y > yMax) {
     yMax = y;
   }
-#else // USE_FIXEDPOINT
+#else /* USE_FIXEDPOINT */
   // transform the four corners of the font bounding box -- the min
   // and max values form the bounding box of the transformed font
   x = (int)((mat[0] * (SplashCoord)face->bbox.xMin
@@ -186,7 +182,7 @@ SplashFTFont::SplashFTFont(SplashFTFontFile *fontFileA, SplashCoord *matA,
   } else if (y > yMax) {
     yMax = y;
   }
-#endif // USE_FIXEDPOINT
+#endif /* USE_FIXEDPOINT */
   // This is a kludge: some buggy PDF generators embed fonts with
   // zero bounding boxes.
   if (xMax == xMin) {
@@ -199,7 +195,7 @@ SplashFTFont::SplashFTFont(SplashFTFontFile *fontFileA, SplashCoord *matA,
   }
 
   // compute the transform matrix
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   matrix.xx = (FT_Fixed)((mat[0] / size).get16Dot16());
   matrix.yx = (FT_Fixed)((mat[1] / size).get16Dot16());
   matrix.xy = (FT_Fixed)((mat[2] / size).get16Dot16());
@@ -225,6 +221,7 @@ SplashFTFont::~SplashFTFont() {
 
 GBool SplashFTFont::getGlyph(int c, int xFrac, int yFrac,
 			     SplashGlyphBitmap *bitmap) {
+  (void)yFrac;
   return SplashFont::getGlyph(c, xFrac, 0, bitmap);
 }
 
@@ -239,6 +236,7 @@ GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,
   Guchar *p, *q;
   int i;
 
+  (void)yFrac;
   ff = (SplashFTFontFile *)fontFile;
 
   ff->face->size = sizeObj;
@@ -457,4 +455,4 @@ static int glyphPathCubicTo(const FT_Vector *ctrl1, const FT_Vector *ctrl2,
   return 0;
 }
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
diff --git a/splash/SplashFTFont.h b/splash/SplashFTFont.h
index ac08b00..fec9296 100644
--- a/splash/SplashFTFont.h
+++ b/splash/SplashFTFont.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
+#ifdef HAVE_FREETYPE
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
@@ -55,6 +51,6 @@ private:
   SplashCoord textScale;
 };
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
 
 #endif
diff --git a/splash/SplashFTFontEngine.cc b/splash/SplashFTFontEngine.cc
index 3393954..ec21786 100644
--- a/splash/SplashFTFontEngine.cc
+++ b/splash/SplashFTFontEngine.cc
@@ -8,11 +8,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
+#ifdef HAVE_FREETYPE
 
 #include <stdio.h>
 #ifndef _WIN32
@@ -43,7 +39,7 @@ static void fileWrite(void *stream, const char *data, int len) {
   fwrite(data, 1, len, (FILE *)stream);
 }
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 static void gstringWrite(void *stream, const char *data, int len) {
   ((GString *)stream)->append(data, len);
 }
@@ -81,15 +77,15 @@ SplashFTFontEngine::~SplashFTFontEngine() {
 }
 
 SplashFontFile *SplashFTFontEngine::loadType1Font(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						  GString *fontBuf,
 #else
 						  char *fileName,
 						  GBool deleteFile,
 #endif
-						  const char **enc) {
+						  const char *const *enc) {
   return SplashFTFontFile::loadType1Font(this, idA, splashFontType1,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					 fontBuf,
 #else
 					 fileName, deleteFile,
@@ -98,7 +94,7 @@ SplashFontFile *SplashFTFontEngine::loadType1Font(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFTFontEngine::loadType1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						   GString *fontBuf,
 #else
 						   char *fileName,
@@ -106,7 +102,7 @@ SplashFontFile *SplashFTFontEngine::loadType1CFont(SplashFontFileID *idA,
 #endif
 						   const char **enc) {
   return SplashFTFontFile::loadType1Font(this, idA, splashFontType1C,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					 fontBuf,
 #else
 					 fileName, deleteFile,
@@ -115,7 +111,7 @@ SplashFontFile *SplashFTFontEngine::loadType1CFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 							GString *fontBuf,
 #else
 							char *fileName,
@@ -123,7 +119,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
 #endif
 							const char **enc) {
   FoFiTrueType *ff;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf2;
 #else
   GString *tmpFileName;
@@ -131,7 +127,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
 #endif
   SplashFontFile *ret;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (!(ff = FoFiTrueType::make(fontBuf->getCString(), fontBuf->getLength(),
 				0, gTrue))) {
 #else
@@ -140,7 +136,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
     return NULL;
   }
   if (ff->isHeadlessCFF()) {
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
     fontBuf2 = new GString();
     ff->convertToType1(NULL, enc, gFalse, &gstringWrite, fontBuf2);
     delete ff;
@@ -175,7 +171,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
   } else {
     delete ff;
     ret = SplashFTFontFile::loadType1Font(this, idA, splashFontOpenTypeT1C,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					  fontBuf,
 #else
 					  fileName, deleteFile,
@@ -186,7 +182,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFTFontEngine::loadCIDFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						GString *fontBuf,
 #else
 						char *fileName,
@@ -206,7 +202,7 @@ SplashFontFile *SplashFTFontEngine::loadCIDFont(SplashFontFileID *idA,
   } else if (useCIDs) {
     cidToGIDMap = NULL;
     nCIDs = 0;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   } else if ((ff = FoFiType1C::make(fontBuf->getCString(),
 				    fontBuf->getLength()))) {
 #else
@@ -219,7 +215,7 @@ SplashFontFile *SplashFTFontEngine::loadCIDFont(SplashFontFileID *idA,
     nCIDs = 0;
   }
   ret = SplashFTFontFile::loadCIDFont(this, idA, splashFontCID,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				      fontBuf,
 #else
 				      fileName, deleteFile,
@@ -233,7 +229,7 @@ SplashFontFile *SplashFTFontEngine::loadCIDFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 							GString *fontBuf,
 #else
 							char *fileName,
@@ -242,7 +238,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
 							int *codeToGID,
 							int codeToGIDLen) {
   FoFiTrueType *ff;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf2;
 #else
   GString *tmpFileName;
@@ -254,7 +250,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
   int nCIDs;
   SplashFontFile *ret;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (!(ff = FoFiTrueType::make(fontBuf->getCString(), fontBuf->getLength(),
 				0, gTrue))) {
 #else
@@ -268,7 +264,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
     if (!ff->getCFFBlock(&cffStart, &cffLength)) {
       return NULL;
     }
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
     fontBuf2 = new GString(cffStart, cffLength);
     if (!useCIDs) {
       cidToGIDMap = ff->getCIDToGIDMap(&nCIDs);
@@ -308,7 +304,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
       cidToGIDMap = ff->getCIDToGIDMap(&nCIDs);
     }
     ret = SplashFTFontFile::loadCIDFont(this, idA, splashFontOpenTypeCFF,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					fontBuf,
 #else
 					fileName, deleteFile,
@@ -324,7 +320,7 @@ SplashFontFile *SplashFTFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						     GString *fontBuf,
 #else
 						     char *fileName,
@@ -334,7 +330,7 @@ SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
 						     int *codeToGID,
 						     int codeToGIDLen) {
   FoFiTrueType *ff;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf2;
 #else
   GString *tmpFileName;
@@ -342,7 +338,7 @@ SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
 #endif
   SplashFontFile *ret;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (!(ff = FoFiTrueType::make(fontBuf->getCString(), fontBuf->getLength(),
 				fontNum))) {
 #else
@@ -350,7 +346,7 @@ SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
 #endif
     return NULL;
   }
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   fontBuf2 = new GString;
   ff->writeTTF(&gstringWrite, fontBuf2);
 #else
@@ -364,13 +360,13 @@ SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
 #endif
   delete ff;
   ret = SplashFTFontFile::loadTrueTypeFont(this, idA, splashFontTrueType,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					   fontBuf2,
 #else
 					   tmpFileName->getCString(), gTrue,
 #endif
 					   0, codeToGID, codeToGIDLen);
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (ret) {
     delete fontBuf;
   } else {
@@ -389,4 +385,4 @@ SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
   return ret;
 }
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
diff --git a/splash/SplashFTFontEngine.h b/splash/SplashFTFontEngine.h
index 24db3c6..90e1120 100644
--- a/splash/SplashFTFontEngine.h
+++ b/splash/SplashFTFontEngine.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
+#ifdef HAVE_FREETYPE
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
@@ -38,42 +34,42 @@ public:
 
   // Load fonts.
   SplashFontFile *loadType1Font(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				GString *fontBuf,
 #else
 				char *fileName, GBool deleteFile,
 #endif
-				const char **enc);
+				const char *const *enc);
   SplashFontFile *loadType1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				 GString *fontBuf,
 #else
 				 char *fileName, GBool deleteFile,
 #endif
 				 const char **enc);
   SplashFontFile *loadOpenTypeT1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				      GString *fontBuf,
 #else
 				      char *fileName, GBool deleteFile,
 #endif
 				      const char **enc);
   SplashFontFile *loadCIDFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			      GString *fontBuf,
 #else
 			      char *fileName, GBool deleteFile,
 #endif
 			      int *codeToGID, int codeToGIDLen);
   SplashFontFile *loadOpenTypeCFFFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				      GString *fontBuf,
 #else
 				      char *fileName, GBool deleteFile,
 #endif
 				      int *codeToGID, int codeToGIDLen);
   SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				   GString *fontBuf,
 #else
 				   char *fileName, GBool deleteFile,
@@ -94,6 +90,6 @@ private:
   friend class SplashFTFont;
 };
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
 
 #endif
diff --git a/splash/SplashFTFontFile.cc b/splash/SplashFTFontFile.cc
index b5fd02a..d5d13f9 100644
--- a/splash/SplashFTFontFile.cc
+++ b/splash/SplashFTFontFile.cc
@@ -8,11 +8,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
+#ifdef HAVE_FREETYPE
 
 #include "gmem.h"
 #include "gmempp.h"
@@ -28,19 +24,19 @@
 SplashFontFile *SplashFTFontFile::loadType1Font(SplashFTFontEngine *engineA,
 						SplashFontFileID *idA,
 						SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						GString *fontBufA,
 #else
 						char *fileNameA,
 						GBool deleteFileA,
 #endif
-						const char **encA) {
+						const char *const *encA) {
   FT_Face faceA;
   int *codeToGIDA;
   const char *name;
   int i;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (FT_New_Memory_Face(engineA->lib, (FT_Byte *)fontBufA->getCString(),
 			 fontBufA->getLength(), 0, &faceA)) {
 #else
@@ -52,12 +48,12 @@ SplashFontFile *SplashFTFontFile::loadType1Font(SplashFTFontEngine *engineA,
   for (i = 0; i < 256; ++i) {
     codeToGIDA[i] = 0;
     if ((name = encA[i])) {
-      codeToGIDA[i] = (int)FT_Get_Name_Index(faceA, (char *)name);
+      codeToGIDA[i] = (int)FT_Get_Name_Index(faceA, const_cast<char *>(name));
     }
   }
 
   return new SplashFTFontFile(engineA, idA, fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			      fontBufA,
 #else
 			      fileNameA, deleteFileA,
@@ -68,7 +64,7 @@ SplashFontFile *SplashFTFontFile::loadType1Font(SplashFTFontEngine *engineA,
 SplashFontFile *SplashFTFontFile::loadCIDFont(SplashFTFontEngine *engineA,
 					      SplashFontFileID *idA,
 					      SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					      GString *fontBufA,
 #else
 					      char *fileNameA,
@@ -78,7 +74,7 @@ SplashFontFile *SplashFTFontFile::loadCIDFont(SplashFTFontEngine *engineA,
 					      int codeToGIDLenA) {
   FT_Face faceA;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (FT_New_Memory_Face(engineA->lib, (FT_Byte *)fontBufA->getCString(),
 			 fontBufA->getLength(), 0, &faceA)) {
 #else
@@ -88,7 +84,7 @@ SplashFontFile *SplashFTFontFile::loadCIDFont(SplashFTFontEngine *engineA,
   }
 
   return new SplashFTFontFile(engineA, idA, fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			      fontBufA,
 #else
 			      fileNameA, deleteFileA,
@@ -99,7 +95,7 @@ SplashFontFile *SplashFTFontFile::loadCIDFont(SplashFTFontEngine *engineA,
 SplashFontFile *SplashFTFontFile::loadTrueTypeFont(SplashFTFontEngine *engineA,
 						   SplashFontFileID *idA,
 						   SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						   GString *fontBufA,
 #else
 						   char *fileNameA,
@@ -110,7 +106,7 @@ SplashFontFile *SplashFTFontFile::loadTrueTypeFont(SplashFTFontEngine *engineA,
 						   int codeToGIDLenA) {
   FT_Face faceA;
 
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (FT_New_Memory_Face(engineA->lib, (FT_Byte *)fontBufA->getCString(),
 			 fontBufA->getLength(), fontNum, &faceA)) {
 #else
@@ -120,7 +116,7 @@ SplashFontFile *SplashFTFontFile::loadTrueTypeFont(SplashFTFontEngine *engineA,
   }
 
   return new SplashFTFontFile(engineA, idA, fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			      fontBufA,
 #else
 			      fileNameA, deleteFileA,
@@ -131,14 +127,14 @@ SplashFontFile *SplashFTFontFile::loadTrueTypeFont(SplashFTFontEngine *engineA,
 SplashFTFontFile::SplashFTFontFile(SplashFTFontEngine *engineA,
 				   SplashFontFileID *idA,
 				   SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				   GString *fontBufA,
 #else
 				   char *fileNameA, GBool deleteFileA,
 #endif
 				   FT_Face faceA,
 				   int *codeToGIDA, int codeToGIDLenA):
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   SplashFontFile(idA, fontTypeA, fontBufA)
 #else
   SplashFontFile(idA, fontTypeA, fileNameA, deleteFileA)
@@ -168,4 +164,4 @@ SplashFont *SplashFTFontFile::makeFont(SplashCoord *mat,
   return font;
 }
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
diff --git a/splash/SplashFTFontFile.h b/splash/SplashFTFontFile.h
index 3a6b9b7..3c7b87b 100644
--- a/splash/SplashFTFontFile.h
+++ b/splash/SplashFTFontFile.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#if HAVE_FREETYPE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
+#ifdef HAVE_FREETYPE
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
@@ -34,16 +30,16 @@ public:
   static SplashFontFile *loadType1Font(SplashFTFontEngine *engineA,
 				       SplashFontFileID *idA,
 				       SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				       GString *fontBufA,
 #else
 				       char *fileNameA, GBool deleteFileA,
 #endif
-				       const char **encA);
+				       const char *const *encA);
   static SplashFontFile *loadCIDFont(SplashFTFontEngine *engineA,
 				     SplashFontFileID *idA,
 				     SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				     GString *fontBufA,
 #else
 				     char *fileNameA, GBool deleteFileA,
@@ -52,7 +48,7 @@ public:
   static SplashFontFile *loadTrueTypeFont(SplashFTFontEngine *engineA,
 					  SplashFontFileID *idA,
 					  SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					  GString *fontBufA,
 #else
 					  char *fileNameA,
@@ -74,7 +70,7 @@ private:
   SplashFTFontFile(SplashFTFontEngine *engineA,
 		   SplashFontFileID *idA,
 		   SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 		   GString *fontBufA,
 #else
 		   char *fileNameA, GBool deleteFileA,
@@ -90,6 +86,6 @@ private:
   friend class SplashFTFont;
 };
 
-#endif // HAVE_FREETYPE_H
+#endif /* HAVE_FREETYPE */
 
 #endif
diff --git a/splash/SplashFont.cc b/splash/SplashFont.cc
index add3431..75c4169 100644
--- a/splash/SplashFont.cc
+++ b/splash/SplashFont.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
diff --git a/splash/SplashFont.h b/splash/SplashFont.h
index 2bb9654..3612924 100644
--- a/splash/SplashFont.h
+++ b/splash/SplashFont.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "SplashTypes.h"
 #include "SplashMath.h"
diff --git a/splash/SplashFontEngine.cc b/splash/SplashFontEngine.cc
index 2d0542d..a8618db 100644
--- a/splash/SplashFontEngine.cc
+++ b/splash/SplashFontEngine.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stdio.h>
 #ifndef _WIN32
@@ -38,7 +34,7 @@ extern "C" int unlink(char *filename);
 //------------------------------------------------------------------------
 
 SplashFontEngine::SplashFontEngine(
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
 				   GBool enableFreeType,
 				   Guint freeTypeFlags,
 #endif
@@ -49,7 +45,7 @@ SplashFontEngine::SplashFontEngine(
     fontCache[i] = NULL;
   }
 
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (enableFreeType) {
     ftEngine = SplashFTFontEngine::init(aa, freeTypeFlags);
   } else {
@@ -67,7 +63,7 @@ SplashFontEngine::~SplashFontEngine() {
     }
   }
 
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (ftEngine) {
     delete ftEngine;
   }
@@ -90,20 +86,20 @@ SplashFontFile *SplashFontEngine::getFontFile(SplashFontFileID *id) {
 }
 
 SplashFontFile *SplashFontEngine::loadType1Font(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						GString *fontBuf,
 #else
 						char *fileName,
 						GBool deleteFile,
 #endif
-						const char **enc) {
+						const char *const *enc) {
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadType1Font(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				       fontBuf,
 #else
 				       fileName, deleteFile,
@@ -112,7 +108,7 @@ SplashFontFile *SplashFontEngine::loadType1Font(SplashFontFileID *idA,
   }
 #endif
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
@@ -126,7 +122,7 @@ SplashFontFile *SplashFontEngine::loadType1Font(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFontEngine::loadType1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						 GString *fontBuf,
 #else
 						 char *fileName,
@@ -136,10 +132,10 @@ SplashFontFile *SplashFontEngine::loadType1CFont(SplashFontFileID *idA,
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadType1CFont(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					fontBuf,
 #else
 					fileName, deleteFile,
@@ -148,7 +144,7 @@ SplashFontFile *SplashFontEngine::loadType1CFont(SplashFontFileID *idA,
   }
 #endif
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
@@ -162,7 +158,7 @@ SplashFontFile *SplashFontEngine::loadType1CFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						      GString *fontBuf,
 #else
 						      char *fileName,
@@ -172,10 +168,10 @@ SplashFontFile *SplashFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadOpenTypeT1CFont(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					     fontBuf,
 #else
 					     fileName, deleteFile,
@@ -184,7 +180,7 @@ SplashFontFile *SplashFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
   }
 #endif
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
@@ -198,7 +194,7 @@ SplashFontFile *SplashFontEngine::loadOpenTypeT1CFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFontEngine::loadCIDFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					      GString *fontBuf,
 #else
 					      char *fileName,
@@ -209,10 +205,10 @@ SplashFontFile *SplashFontEngine::loadCIDFont(SplashFontFileID *idA,
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadCIDFont(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				     fontBuf,
 #else
 				     fileName, deleteFile,
@@ -221,7 +217,7 @@ SplashFontFile *SplashFontEngine::loadCIDFont(SplashFontFileID *idA,
   }
 #endif
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
@@ -235,7 +231,7 @@ SplashFontFile *SplashFontEngine::loadCIDFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						      GString *fontBuf,
 #else
 						      char *fileName,
@@ -246,10 +242,10 @@ SplashFontFile *SplashFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadOpenTypeCFFFont(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					     fontBuf,
 #else
 					     fileName, deleteFile,
@@ -258,7 +254,7 @@ SplashFontFile *SplashFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
   }
 #endif
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
@@ -272,7 +268,7 @@ SplashFontFile *SplashFontEngine::loadOpenTypeCFFFont(SplashFontFileID *idA,
 }
 
 SplashFontFile *SplashFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 						   GString *fontBuf,
 #else
 						   char *fileName,
@@ -285,10 +281,10 @@ SplashFontFile *SplashFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
   SplashFontFile *fontFile;
 
   fontFile = NULL;
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   if (!fontFile && ftEngine) {
     fontFile = ftEngine->loadTrueTypeFont(idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					  fontBuf,
 #else
 					  fileName, deleteFile,
@@ -297,11 +293,12 @@ SplashFontFile *SplashFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
   }
 #endif
 
+  (void)fontName;
   if (!fontFile) {
     gfree(codeToGID);
   }
 
-#if !LOAD_FONTS_FROM_MEM && !defined(_WIN32) && !defined(__ANDROID__)
+#if !defined(LOAD_FONTS_FROM_MEM) && !defined(_WIN32) && !defined(__ANDROID__)
   // delete the (temporary) font file -- with Unix hard link
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
diff --git a/splash/SplashFontEngine.h b/splash/SplashFontEngine.h
index ac2558e..67a9753 100644
--- a/splash/SplashFontEngine.h
+++ b/splash/SplashFontEngine.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 class GString;
 
@@ -29,7 +25,7 @@ class SplashFont;
 
 #define splashFontCacheSize 16
 
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
 #define splashFTNoHinting (1 << 0)
 #endif
 
@@ -42,7 +38,7 @@ public:
 
   // Create a font engine.
   SplashFontEngine(
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
 		   GBool enableFreeType,
 		   Guint freeTypeFlags,
 #endif
@@ -56,42 +52,42 @@ public:
 
   // Load fonts - these create new SplashFontFile objects.
   SplashFontFile *loadType1Font(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				GString *fontBuf,
 #else
 				char *fileName, GBool deleteFile,
 #endif
-				const char **enc);
+				const char *const *enc);
   SplashFontFile *loadType1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				 GString *fontBuf,
 #else
 				 char *fileName, GBool deleteFile,
 #endif
 				 const char **enc);
   SplashFontFile *loadOpenTypeT1CFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				      GString *fontBuf,
 #else
 				      char *fileName, GBool deleteFile,
 #endif
 				      const char **enc);
   SplashFontFile *loadCIDFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			      GString *fontBuf,
 #else
 			      char *fileName, GBool deleteFile,
 #endif
 			      int *codeToGID, int codeToGIDLen);
   SplashFontFile *loadOpenTypeCFFFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				      GString *fontBuf,
 #else
 				      char *fileName, GBool deleteFile,
 #endif
 				      int *codeToGID, int codeToGIDLen);
   SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 				   GString *fontBuf,
 #else
 				   char *fileName, GBool deleteFile,
@@ -115,7 +111,7 @@ private:
 
   SplashFont *fontCache[splashFontCacheSize];
 
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   SplashFTFontEngine *ftEngine;
 #endif
 };
diff --git a/splash/SplashFontFile.cc b/splash/SplashFontFile.cc
index 2d260e3..962b23a 100644
--- a/splash/SplashFontFile.cc
+++ b/splash/SplashFontFile.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #ifndef _WIN32
 #  include <unistd.h>
@@ -33,7 +29,7 @@ extern "C" int unlink(char *filename);
 
 SplashFontFile::SplashFontFile(SplashFontFileID *idA,
 			       SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			       GString *fontBufA
 #else
 			       char *fileNameA, GBool deleteFileA
@@ -41,7 +37,7 @@ SplashFontFile::SplashFontFile(SplashFontFileID *idA,
 			       ) {
   id = idA;
   fontType = fontTypeA;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   fontBuf = fontBufA;
 #else
   fileName = new GString(fileNameA);
@@ -51,7 +47,7 @@ SplashFontFile::SplashFontFile(SplashFontFileID *idA,
 }
 
 SplashFontFile::~SplashFontFile() {
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   delete fontBuf;
 #else
   if (deleteFile) {
@@ -63,7 +59,7 @@ SplashFontFile::~SplashFontFile() {
 }
 
 void SplashFontFile::incRefCnt() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicIncrement(&refCnt);
 #else
   ++refCnt;
@@ -73,7 +69,7 @@ void SplashFontFile::incRefCnt() {
 void SplashFontFile::decRefCnt() {
   GBool done;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   done = gAtomicDecrement(&refCnt) == 0;
 #else
   done = --refCnt == 0;
diff --git a/splash/SplashFontFile.h b/splash/SplashFontFile.h
index 133e6ab..850a483 100644
--- a/splash/SplashFontFile.h
+++ b/splash/SplashFontFile.h
@@ -11,14 +11,10 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "SplashTypes.h"
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -68,7 +64,7 @@ protected:
 
   SplashFontFile(SplashFontFileID *idA,
 		 SplashFontType fontTypeA,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 		 GString *fontBufA
 #else
 		 char *fileNameA, GBool deleteFileA
@@ -77,13 +73,13 @@ protected:
 
   SplashFontFileID *id;
   SplashFontType fontType;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf;
 #else
   GString *fileName;
   GBool deleteFile;
 #endif
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter refCnt;
 #else
   int refCnt;
diff --git a/splash/SplashFontFileID.cc b/splash/SplashFontFileID.cc
index 27f5203..2c03cf1 100644
--- a/splash/SplashFontFileID.cc
+++ b/splash/SplashFontFileID.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "SplashFontFileID.h"
 
diff --git a/splash/SplashFontFileID.h b/splash/SplashFontFileID.h
index 384018a..c4a0d7e 100644
--- a/splash/SplashFontFileID.h
+++ b/splash/SplashFontFileID.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 //------------------------------------------------------------------------
diff --git a/splash/SplashMath.h b/splash/SplashMath.h
index 71afa3c..4d36400 100644
--- a/splash/SplashMath.h
+++ b/splash/SplashMath.h
@@ -11,7 +11,7 @@
 
 #include <aconf.h>
 
-#if USE_FIXEDPONT
+#ifdef USE_FIXEDPOINT
 #  include "FixedPoint.h"
 #else
 #  include <math.h>
@@ -23,7 +23,7 @@
 #include "SplashTypes.h"
 
 static inline SplashCoord splashAbs(SplashCoord x) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   return FixedPoint::abs(x);
 #else
   return fabs(x);
@@ -34,7 +34,7 @@ static inline SplashCoord splashAbs(SplashCoord x) {
 // in changing the FPCW multiple times - so we optimize it with
 // some inline assembly or SSE intrinsics.
 static inline int splashFloor(SplashCoord x) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
 
   //--- fixed point
 
@@ -110,7 +110,7 @@ static inline int splashFloor(SplashCoord x) {
 // in changing the FPCW multiple times - so we optimize it with
 // some inline assembly or SSE intrinsics.
 static inline int splashCeil(SplashCoord x) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
 
   //--- fixed point
 
@@ -186,7 +186,7 @@ static inline int splashCeil(SplashCoord x) {
 }
 
 static inline int splashRound(SplashCoord x) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
 
   //--- fixed point
 
@@ -202,7 +202,7 @@ static inline int splashRound(SplashCoord x) {
 }
 
 static inline SplashCoord splashAvg(SplashCoord x, SplashCoord y) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   return FixedPoint::avg(x, y);
 #else
   return 0.5 * (x + y);
@@ -210,7 +210,7 @@ static inline SplashCoord splashAvg(SplashCoord x, SplashCoord y) {
 }
 
 static inline SplashCoord splashSqrt(SplashCoord x) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   return FixedPoint::sqrt(x);
 #else
   return sqrt(x);
@@ -218,7 +218,7 @@ static inline SplashCoord splashSqrt(SplashCoord x) {
 }
 
 static inline SplashCoord splashPow(SplashCoord x, SplashCoord y) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   return FixedPoint::pow(x, y);
 #else
   return pow(x, y);
@@ -230,7 +230,7 @@ static inline SplashCoord splashDist(SplashCoord x0, SplashCoord y0,
   SplashCoord dx, dy;
   dx = x1 - x0;
   dy = y1 - y0;
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   // this handles the situation where dx*dx or dy*dy is too large to
   // fit in the 16.16 fixed point format
   SplashCoord dxa, dya, d;
@@ -253,7 +253,7 @@ static inline SplashCoord splashDist(SplashCoord x0, SplashCoord y0,
 static inline GBool splashCheckDet(SplashCoord m11, SplashCoord m12,
 				   SplashCoord m21, SplashCoord m22,
 				   SplashCoord epsilon) {
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   return FixedPoint::checkDet(m11, m12, m21, m22, epsilon);
 #else
   return fabs(m11 * m22 - m12 * m21) >= epsilon;
diff --git a/splash/SplashPath.cc b/splash/SplashPath.cc
index 7921667..7c63dac 100644
--- a/splash/SplashPath.cc
+++ b/splash/SplashPath.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
@@ -47,8 +43,11 @@ SplashPath::SplashPath(SplashPath *path) {
   size = path->size;
   pts = (SplashPathPoint *)gmallocn(size, sizeof(SplashPathPoint));
   flags = (Guchar *)gmallocn(size, sizeof(Guchar));
+#pragma GCC diagnostic ignored "-Wpragmas"
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
   memcpy(pts, path->pts, length * sizeof(SplashPathPoint));
   memcpy(flags, path->flags, length * sizeof(Guchar));
+#pragma GCC diagnostic warning "-Wclass-memaccess"
   curSubpath = path->curSubpath;
   if (path->hints) {
     hintsLength = hintsSize = path->hintsLength;
diff --git a/splash/SplashPath.h b/splash/SplashPath.h
index b5732b8..648b320 100644
--- a/splash/SplashPath.h
+++ b/splash/SplashPath.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 //------------------------------------------------------------------------
diff --git a/splash/SplashPattern.cc b/splash/SplashPattern.cc
index 0c5b509..fc01ee6 100644
--- a/splash/SplashPattern.cc
+++ b/splash/SplashPattern.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "SplashMath.h"
 #include "SplashScreen.h"
@@ -39,6 +35,8 @@ SplashSolidColor::~SplashSolidColor() {
 }
 
 void SplashSolidColor::getColor(int x, int y, SplashColorPtr c) {
+  (void)x;
+  (void)y;
   splashColorCopy(c, color);
 }
 
diff --git a/splash/SplashPattern.h b/splash/SplashPattern.h
index fcbe21d..45a9dcd 100644
--- a/splash/SplashPattern.h
+++ b/splash/SplashPattern.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 class SplashScreen;
diff --git a/splash/SplashScreen.cc b/splash/SplashScreen.cc
index 9993edc..328acea 100644
--- a/splash/SplashScreen.cc
+++ b/splash/SplashScreen.cc
@@ -8,13 +8,9 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 #include <algorithm>
 #endif
 #include "gmem.h"
@@ -40,7 +36,7 @@ struct SplashScreenPoint {
   int dist;
 };
 
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 
 struct cmpDistancesFunctor {
   bool operator()(const SplashScreenPoint &p0, const SplashScreenPoint &p1) {
@@ -48,7 +44,7 @@ struct cmpDistancesFunctor {
   }
 };
 
-#else // HAVE_STD_SORT
+#else
 
 static int cmpDistances(const void *p0, const void *p1) {
   return ((SplashScreenPoint *)p0)->dist - ((SplashScreenPoint *)p1)->dist;
@@ -349,7 +345,7 @@ void SplashScreen::buildSCDMatrix(int r) {
 	}
       }
     }
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
     std::sort(pts, pts + n, cmpDistancesFunctor());
 #else
     qsort(pts, n, sizeof(SplashScreenPoint), &cmpDistances);
diff --git a/splash/SplashScreen.h b/splash/SplashScreen.h
index 560e275..9edf8e8 100644
--- a/splash/SplashScreen.h
+++ b/splash/SplashScreen.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 //------------------------------------------------------------------------
diff --git a/splash/SplashState.cc b/splash/SplashState.cc
index 74421c4..eb7d65f 100644
--- a/splash/SplashState.cc
+++ b/splash/SplashState.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
@@ -28,7 +24,7 @@
 // number of components in each color mode
 int splashColorModeNComps[] = {
   1, 1, 3, 3
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   , 4
 #endif
 };
@@ -38,6 +34,7 @@ SplashState::SplashState(int width, int height, GBool vectorAntialias,
   SplashColor color;
   int i;
 
+  (void)vectorAntialias;
   matrix[0] = 1;  matrix[1] = 0;
   matrix[2] = 0;  matrix[3] = 1;
   matrix[4] = 0;  matrix[5] = 0;
@@ -68,7 +65,7 @@ SplashState::SplashState(int width, int height, GBool vectorAntialias,
     rgbTransferG[i] = (Guchar)i;
     rgbTransferB[i] = (Guchar)i;
     grayTransfer[i] = (Guchar)i;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     cmykTransferC[i] = (Guchar)i;
     cmykTransferM[i] = (Guchar)i;
     cmykTransferY[i] = (Guchar)i;
@@ -85,6 +82,7 @@ SplashState::SplashState(int width, int height, GBool vectorAntialias,
   SplashColor color;
   int i;
 
+  (void)vectorAntialias;
   matrix[0] = 1;  matrix[1] = 0;
   matrix[2] = 0;  matrix[3] = 1;
   matrix[4] = 0;  matrix[5] = 0;
@@ -115,7 +113,7 @@ SplashState::SplashState(int width, int height, GBool vectorAntialias,
     rgbTransferG[i] = (Guchar)i;
     rgbTransferB[i] = (Guchar)i;
     grayTransfer[i] = (Guchar)i;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     cmykTransferC[i] = (Guchar)i;
     cmykTransferM[i] = (Guchar)i;
     cmykTransferY[i] = (Guchar)i;
@@ -143,7 +141,10 @@ SplashState::SplashState(SplashState *state) {
   if (state->lineDash) {
     lineDashLength = state->lineDashLength;
     lineDash = (SplashCoord *)gmallocn(lineDashLength, sizeof(SplashCoord));
+#pragma GCC diagnostic ignored "-Wpragmas"
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
     memcpy(lineDash, state->lineDash, lineDashLength * sizeof(SplashCoord));
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
   } else {
     lineDash = NULL;
     lineDashLength = 0;
@@ -160,7 +161,7 @@ SplashState::SplashState(SplashState *state) {
   memcpy(rgbTransferG, state->rgbTransferG, 256);
   memcpy(rgbTransferB, state->rgbTransferB, 256);
   memcpy(grayTransfer, state->grayTransfer, 256);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   memcpy(cmykTransferC, state->cmykTransferC, 256);
   memcpy(cmykTransferM, state->cmykTransferM, 256);
   memcpy(cmykTransferY, state->cmykTransferY, 256);
@@ -205,7 +206,9 @@ void SplashState::setLineDash(SplashCoord *lineDashA, int lineDashLengthA,
   lineDashLength = lineDashLengthA;
   if (lineDashLength > 0) {
     lineDash = (SplashCoord *)gmallocn(lineDashLength, sizeof(SplashCoord));
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
     memcpy(lineDash, lineDashA, lineDashLength * sizeof(SplashCoord));
+#pragma GCC diagnostic warning "-Wclass-memaccess"
   } else {
     lineDash = NULL;
   }
@@ -275,16 +278,12 @@ void SplashState::setSoftMask(SplashBitmap *softMaskA) {
 
 void SplashState::setTransfer(Guchar *red, Guchar *green, Guchar *blue,
 			      Guchar *gray) {
-#if SPLASH_CMYK
-  int i;
-#endif
-
   memcpy(rgbTransferR, red, 256);
   memcpy(rgbTransferG, green, 256);
   memcpy(rgbTransferB, blue, 256);
   memcpy(grayTransfer, gray, 256);
-#if SPLASH_CMYK
-  for (i = 0; i < 256; ++i) {
+#ifdef SPLASH_CMYK
+  for (int i = 0; i < 256; ++i) {
     cmykTransferC[i] = (Guchar)(255 - rgbTransferR[255 - i]);
     cmykTransferM[i] = (Guchar)(255 - rgbTransferG[255 - i]);
     cmykTransferY[i] = (Guchar)(255 - rgbTransferB[255 - i]);
diff --git a/splash/SplashState.h b/splash/SplashState.h
index 38cb118..8a0abd0 100644
--- a/splash/SplashState.h
+++ b/splash/SplashState.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 class SplashPattern;
@@ -117,7 +113,7 @@ private:
          rgbTransferG[256],
          rgbTransferB[256];
   Guchar grayTransfer[256];
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   Guchar cmykTransferC[256],
          cmykTransferM[256],
          cmykTransferY[256],
diff --git a/splash/SplashTypes.h b/splash/SplashTypes.h
index 5860884..fc7ba36 100644
--- a/splash/SplashTypes.h
+++ b/splash/SplashTypes.h
@@ -16,7 +16,7 @@
 // coordinates
 //------------------------------------------------------------------------
 
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
 #include "FixedPoint.h"
 typedef FixedPoint SplashCoord;
 #else
@@ -42,7 +42,7 @@ enum SplashColorMode {
   splashModeBGR8		// 1 byte per component, 3 bytes per pixel:
 				//   BGRBGR...
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   ,
   splashModeCMYK8		// 1 byte per component, 4 bytes per pixel:
 				//   CMYKCMYK...
@@ -55,7 +55,7 @@ extern int splashColorModeNComps[];
 
 // max number of components in any SplashColor
 #define splashMaxColorComps 3
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 #  undef splashMaxColorComps
 #  define splashMaxColorComps 4
 #endif
@@ -73,7 +73,7 @@ static inline Guchar splashBGR8R(SplashColorPtr bgr8) { return bgr8[2]; }
 static inline Guchar splashBGR8G(SplashColorPtr bgr8) { return bgr8[1]; }
 static inline Guchar splashBGR8B(SplashColorPtr bgr8) { return bgr8[0]; }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 // CMYK8
 static inline Guchar splashCMYK8C(SplashColorPtr cmyk8) { return cmyk8[0]; }
 static inline Guchar splashCMYK8M(SplashColorPtr cmyk8) { return cmyk8[1]; }
@@ -85,7 +85,7 @@ static inline void splashColorCopy(SplashColorPtr dest, SplashColorPtr src) {
   dest[0] = src[0];
   dest[1] = src[1];
   dest[2] = src[2];
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   dest[3] = src[3];
 #endif
 }
@@ -94,7 +94,7 @@ static inline void splashColorXor(SplashColorPtr dest, SplashColorPtr src) {
   dest[0] ^= src[0];
   dest[1] ^= src[1];
   dest[2] ^= src[2];
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   dest[3] ^= src[3];
 #endif
 }
diff --git a/splash/SplashXPath.cc b/splash/SplashXPath.cc
index f0164a8..c790b92 100644
--- a/splash/SplashXPath.cc
+++ b/splash/SplashXPath.cc
@@ -8,13 +8,9 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 #include <algorithm>
 #endif
 #include "gmem.h"
@@ -66,7 +62,7 @@ inline void SplashXPath::transform(SplashCoord *matrix,
 #define maxCoord 100000000.0
 
 void SplashXPath::clampCoords(SplashCoord *x, SplashCoord *y) {
-#if !USE_FIXEDPOINT
+#ifndef USE_FIXEDPOINT
   if (*x > maxCoord) {
     *x = maxCoord;
   } else if (*x < -maxCoord) {
@@ -77,6 +73,9 @@ void SplashXPath::clampCoords(SplashCoord *x, SplashCoord *y) {
   } else if (*y < -maxCoord) {
     *y = -maxCoord;
   }
+#else
+  (void) x;
+  (void) y;
 #endif
 }
 
@@ -181,7 +180,7 @@ SplashXPath::SplashXPath(SplashPath *path, SplashCoord *matrix,
   isRect = gFalse;
   rectX0 = rectY0 = rectX1 = rectY1 = 0;
   if (length == 4) {
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
     std::sort(segs, segs + length, SplashXPathSeg::cmpY);
 #else
     qsort(segs, length, sizeof(SplashXPathSeg), &SplashXPathSeg::cmpY);
@@ -327,7 +326,10 @@ SplashXPath::SplashXPath(SplashXPath *xPath) {
   length = xPath->length;
   size = xPath->size;
   segs = (SplashXPathSeg *)gmallocn(size, sizeof(SplashXPathSeg));
+#pragma GCC diagnostic ignored "-Wpragmas"
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
   memcpy(segs, xPath->segs, length * sizeof(SplashXPathSeg));
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
   xMin = xPath->xMin;
   yMin = xPath->yMin;
   xMax = xPath->xMax;
@@ -365,12 +367,16 @@ void SplashXPath::addCurve(SplashCoord x0, SplashCoord y0,
   SplashCoord dx, dy, mx, my, d1, d2, flatness2;
   int p1, p2, p3;
 
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
   flatness2 = flatness;
 #else
   flatness2 = flatness * flatness;
 #endif
 
+  (void)first;
+  (void)last;
+  (void)end0;
+  (void)end1;
   // initial segment
   p1 = 0;
   p2 = splashMaxCurveSplits;
@@ -395,7 +401,7 @@ void SplashXPath::addCurve(SplashCoord x0, SplashCoord y0,
     // line)
     mx = (xl0 + xr3) * 0.5;
     my = (yl0 + yr3) * 0.5;
-#if USE_FIXEDPOINT
+#ifndef USE_FIXEDPOINT
     d1 = splashDist(xx1, yy1, mx, my);
     d2 = splashDist(xx2, yy2, mx, my);
 #else
@@ -583,7 +589,7 @@ void SplashXPath::finishSegments() {
       t = seg->y0;  seg->y0 = seg->y1;  seg->y1 = t;
       seg->count = -1;
     }
-#if USE_FIXEDPOINT
+#ifdef USE_FIXEDPOINT
     if (seg->y0 == seg->y1 || seg->x0 == seg->x1 ||
 	!FixedPoint::divCheck(seg->x1 - seg->x0, seg->y1 - seg->y0,
 			      &seg->dxdy) ||
diff --git a/splash/SplashXPath.h b/splash/SplashXPath.h
index 82d7889..996f28c 100644
--- a/splash/SplashXPath.h
+++ b/splash/SplashXPath.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 class SplashPath;
@@ -41,7 +37,7 @@ struct SplashXPathSeg {
   SplashCoord sx0, sx1, mx;
   SplashXPathSeg *prev, *next;
 
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 
   static bool cmpMX(const SplashXPathSeg &s0,
 		    const SplashXPathSeg &s1) {
diff --git a/splash/SplashXPathScanner.cc b/splash/SplashXPathScanner.cc
index 3f167b8..1c5f265 100644
--- a/splash/SplashXPathScanner.cc
+++ b/splash/SplashXPathScanner.cc
@@ -8,13 +8,9 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
 #include <algorithm>
 #endif
 #include "gmem.h"
@@ -36,7 +32,7 @@
 #define aaVert  4
 #define aaHoriz 4
 
-static Guchar map16to255[17] = {
+static Guchar const map16to255[17] = {
   0,
   16,
   32,
@@ -151,7 +147,7 @@ void SplashXPathScanner::reset(GBool aa, GBool aaChanged) {
 
   //--- sort the inactive segments by iy, mx
   if (aaChanged) {
-#if HAVE_STD_SORT
+#ifdef HAVE_STD_SORT
     std::sort(xPath->segs, xPath->segs + xPath->length, &SplashXPathSeg::cmpMX);
 #else
     qsort(xPath->segs, xPath->length, sizeof(SplashXPathSeg),
diff --git a/splash/SplashXPathScanner.h b/splash/SplashXPathScanner.h
index 39cc0eb..decfc50 100644
--- a/splash/SplashXPathScanner.h
+++ b/splash/SplashXPathScanner.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 #include "SplashXPath.h"
 
diff --git a/xpdf-qt/.gitignore b/xpdf-qt/.gitignore
new file mode 100644
index 0000000..9ecc3a2
--- /dev/null
+++ b/xpdf-qt/.gitignore
@@ -0,0 +1,3 @@
+moc_*
+qrc_icons.cc
+xpdf
diff --git a/xpdf-qt/CMakeLists.txt b/xpdf-qt/CMakeLists.txt
deleted file mode 100644
index 941d2f8..0000000
--- a/xpdf-qt/CMakeLists.txt
+++ /dev/null
@@ -1,99 +0,0 @@
-#========================================================================
-#
-# xpdf-qt/cmake-xpdf.txt
-#
-# CMake script for the xpdf application.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-if ((QT4_FOUND OR Qt5Widgets_FOUND)
-    AND HAVE_SPLASH AND MULTITHREADED AND USE_EXCEPTIONS)
-  include_directories("${PROJECT_SOURCE_DIR}")
-  include_directories("${PROJECT_BINARY_DIR}")
-  include_directories("${PROJECT_SOURCE_DIR}/goo")
-  include_directories("${PROJECT_SOURCE_DIR}/fofi")
-  include_directories("${PROJECT_SOURCE_DIR}/splash")
-  include_directories("${PROJECT_SOURCE_DIR}/xpdf")
-  if (QT4_FOUND)
-    include(${QT_USE_FILE})
-  else ()
-    include_directories(SYSTEM "${QT_INCLUDES}")
-    add_definitions(${QT_DEFINITIONS})
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${QT_CFLAGS}")
-  endif ()
-  cmake_policy(SET CMP0020 NEW)
-
-  if (Qt5Widgets_FOUND AND NOT (Qt5Widgets_VERSION VERSION_LESS 5.7.0))
-    set(CMAKE_CXX_STANDARD 11)
-    set(CMAKE_CXX_STANDARD_REQUIRED ON)
-  endif ()
-
-  if (XPDFWIDGET_PRINTING)
-    if (WIN32)
-      if (EXISTS ${PROJECT_SOURCE_DIR}/xpdf/WinPDFPrinter.cc)
-        add_definitions(-DXPDFWIDGET_PRINTING=1)
-        add_definitions(-DXPDFWIDGET_WIN32_PRINTING=1)
-        set(XPDFWIDGET_PRINT_MODULES XpdfWidgetPrint.cc
-                                     ${PROJECT_SOURCE_DIR}/xpdf/GDIOutputDev.cc
-                                     ${PROJECT_SOURCE_DIR}/xpdf/WinPDFPrinter.cc)
-      endif ()
-    else ()
-      add_definitions(-DXPDFWIDGET_PRINTING=1)
-      set(XPDFWIDGET_PRINT_MODULES XpdfWidgetPrint.cc)
-    endif ()
-  else ()
-    set(XPDFWIDGET_PRINT_MODULES "")
-  endif ()
-
-  if (QT4_FOUND)
-    qt4_wrap_cpp(XPDFWIDGET_MOC XpdfWidget.h)
-    qt4_wrap_cpp(XPDFVIEWER_MOC XpdfViewer.h)
-    qt4_wrap_cpp(XPDFAPP_MOC XpdfApp.h)
-    qt4_add_resources(XPDF_ICONS icons.qrc)
-  else ()
-    qt5_wrap_cpp(XPDFWIDGET_MOC XpdfWidget.h)
-    qt5_wrap_cpp(XPDFVIEWER_MOC XpdfViewer.h)
-    qt5_wrap_cpp(XPDFAPP_MOC XpdfApp.h)
-    qt5_add_resources(XPDF_ICONS icons.qrc)
-  endif ()
-
-  # workaround for a conflict between the Qt5 QDateTime and windows.h
-  if (WIN32)
-    add_definitions(-DNOMINMAX)
-  endif ()
-
-  add_executable(xpdf
-    $<TARGET_OBJECTS:goo_objs>
-    $<TARGET_OBJECTS:fofi_objs>
-    $<TARGET_OBJECTS:splash_objs>
-    $<TARGET_OBJECTS:xpdf_objs>
-    $<TARGET_OBJECTS:xpdf_widget_objs>
-    ${XPDFWIDGET_PRINT_MODULES}
-    QtPDFCore.cc
-    XpdfApp.cc
-    XpdfViewer.cc
-    XpdfWidget.cc
-    xpdf.cc
-    xpdf.rc
-    ${XPDFAPP_MOC}
-    ${XPDFVIEWER_MOC}
-    ${XPDFWIDGET_MOC}
-    ${XPDF_ICONS}
-  )
-  target_link_libraries(xpdf ${QT_LIBRARIES} ${EXTRA_QT_LIBRARIES}
-                        ${PAPER_LIBRARY}
-                        ${FREETYPE_LIBRARY} ${FREETYPE_OTHER_LIBS}
-                        ${DTYPE_LIBRARY} ${LCMS_LIBRARY}
-                        ${CMAKE_THREAD_LIBS_INIT})
-  set_property(TARGET xpdf PROPERTY WIN32_EXECUTABLE 1)
-  if (QT4_FOUND)
-    set_property(TARGET xpdf PROPERTY QT4_NO_LINK_QTMAIN ON)
-  else ()
-    set_property(TARGET xpdf PROPERTY Qt5_NO_LINK_QTMAIN ON)
-  endif ()
-
-  install(TARGETS xpdf RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-  install(FILES ${PROJECT_SOURCE_DIR}/doc/xpdf.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-endif ()
diff --git a/xpdf-qt/Makefile.am b/xpdf-qt/Makefile.am
new file mode 100644
index 0000000..6d60ba1
--- /dev/null
+++ b/xpdf-qt/Makefile.am
@@ -0,0 +1,95 @@
+#========================================================================
+#
+# xpdf-qt/Makefile.am
+#
+# Automake script for the xpdf application.
+#
+# Copyright 2019 Thorsten Otto
+#
+#========================================================================
+
+if HAVE_QT
+if HAVE_FREETYPE
+if MULTITHREADED
+if USE_EXCEPTIONS
+bin_PROGRAMS = xpdf
+endif
+endif
+endif
+endif
+
+AM_CPPFLAGS = -I$(top_builddir) -I$(srcdir) -I$(top_srcdir)/goo -I$(top_srcdir)/fofi -I$(top_srcdir)/splash -I$(top_srcdir)/xpdf
+AM_CPPFLAGS += $(PNG_CFLAGS)
+AM_CPPFLAGS += $(LCMS_CFLAGS)
+AM_CPPFLAGS += $(FREETYPE2_CFLAGS)
+AM_CPPFLAGS += $(QT_CFLAGS)
+AM_CPPFLAGS += $(PTHREAD_CFLAGS)
+
+MOC_SOURCES = moc_XpdfApp.cc moc_XpdfViewer.cc moc_XpdfWidget.cc
+
+xpdf_SOURCES = \
+	xpdf.cc \
+	QtPDFCore.cc QtPDFCore.h \
+	XpdfApp.cc XpdfApp.h \
+	XpdfViewer.cc XpdfViewer.h \
+	XpdfWidget.cc XpdfWidget.h \
+	$(MOC_SOURCES) \
+	qrc_icons.cc \
+	$(empty)
+
+QRC_ICONS = \
+	back.svg \
+	findNext.svg \
+	findPrevious.svg \
+	findSettings.svg \
+	fitPage.svg \
+	fitPageOn.svg \
+	fitWidth.svg \
+	fitWidthOn.svg \
+	forward.svg \
+	indicator-icon0.svg \
+	indicator-icon1.svg \
+	indicator-icon2.svg \
+	indicator-icon3.svg \
+	indicator-icon4.svg \
+	indicator-icon5.svg \
+	indicator-icon6.svg \
+	indicator-icon7.svg \
+	indicator-icon-err0.svg \
+	indicator-icon-err1.svg \
+	indicator-icon-err2.svg \
+	indicator-icon-err3.svg \
+	indicator-icon-err4.svg \
+	indicator-icon-err5.svg \
+	indicator-icon-err6.svg \
+	indicator-icon-err7.svg \
+	selectModeLinear.svg \
+	selectModeBlock.svg \
+	xpdf-icon.svg \
+	zoomIn.svg \
+	zoomOut.svg \
+	$(empty)
+
+if XPDFWIDGET_PRINTING
+xpdf_SOURCES += XpdfWidgetPrint.cc XpdfWidgetPrint.h
+endif
+
+xpdf_LDADD = -L../xpdf -lxpdf_widget -lxpdf -L../goo -lgoo -L../fofi -lfofi -L../splash -lsplash
+xpdf_DEPENDENCIES = ../xpdf/libxpdf.a ../xpdf/libxpdf_widget.a ../goo/libgoo.a ../fofi/libfofi.a ../splash/libsplash.a
+xpdf_LDADD += $(QT_LIBS) $(LCMS_LIBS) $(FREETYPE2_LIBS) $(PTHREAD_CFLAGS) $(PTHREAD_LIBS)
+
+moc_XpdfApp.cc: XpdfApp.h
+	$(AM_V_GEN)$(MOC) -o$@ $(QT_DEFS) $<
+
+moc_XpdfViewer.cc: XpdfViewer.h
+	$(AM_V_GEN)$(MOC) -o$@ $(QT_DEFS) $<
+
+moc_XpdfWidget.cc: XpdfWidget.h
+	$(AM_V_GEN)$(MOC) -o$@ $(QT_DEFS) $<
+
+qrc_icons.cc: icons.qrc $(QRC_ICONS)
+	$(AM_V_GEN)$(RCC) --name icons -o $@ $<
+
+CLEANFILES = $(MOC_SOURCES) $(MOC_SOURCES:cpp=cpp_parameters) qrc_icons.cc
+
+EXTRA_DIST = icons.qrc $(QRC_ICONS) xpdf.rc xpdf-icon.ico
diff --git a/xpdf-qt/QtPDFCore.cc b/xpdf-qt/QtPDFCore.cc
index 9fde978..6c960f9 100644
--- a/xpdf-qt/QtPDFCore.cc
+++ b/xpdf-qt/QtPDFCore.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <math.h>
 #include <string.h>
 #include <QApplication>
@@ -246,6 +242,8 @@ void QtPDFCore::startPan(int wx, int wy) {
 }
 
 void QtPDFCore::endPan(int wx, int wy) {
+  (void) wx;
+  (void) wy;
   panning = gFalse;
 }
 
@@ -447,9 +445,11 @@ QString QtPDFCore::getSelectedTextQString() {
   QChar c;
   int i;
 
+#if 0
   if (!doc->okToCopy()) {
     return "";
   }
+#endif
   if (!(s = getSelectedText())) {
     return "";
   }
@@ -476,9 +476,11 @@ void QtPDFCore::copySelection(GBool toClipboard) {
   if (!toClipboard && !QApplication::clipboard()->supportsSelection()) {
     return;
   }
+#if 0
   if (!doc->okToCopy()) {
     return;
   }
+#endif
   if (hasSelection()) {
     QApplication::clipboard()->setText(getSelectedTextQString(),
 				       toClipboard ? QClipboard::Clipboard
diff --git a/xpdf-qt/QtPDFCore.h b/xpdf-qt/QtPDFCore.h
index 07ce205..85ed809 100644
--- a/xpdf-qt/QtPDFCore.h
+++ b/xpdf-qt/QtPDFCore.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <QDateTime>
 #include "gtypes.h"
 #include "SplashTypes.h"
diff --git a/xpdf-qt/XpdfApp.cc b/xpdf-qt/XpdfApp.cc
index d12fb9d..2d99f79 100644
--- a/xpdf-qt/XpdfApp.cc
+++ b/xpdf-qt/XpdfApp.cc
@@ -61,7 +61,7 @@ static ArgDesc argDesc[] = {
   {"-help",         argFlag,   &printHelpArg,      0,                          "print usage information"},
   {"--help",        argFlag,   &printHelpArg,      0,                          "print usage information"},
   {"-?",            argFlag,   &printHelpArg,      0,                          "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 //------------------------------------------------------------------------
diff --git a/xpdf-qt/XpdfViewer.cc b/xpdf-qt/XpdfViewer.cc
index 5d8e77b..3117596 100644
--- a/xpdf-qt/XpdfViewer.cc
+++ b/xpdf-qt/XpdfViewer.cc
@@ -166,7 +166,7 @@ XpdfViewerCmd XpdfViewer::cmdTab[] = {
   { "prevPage",                0, gTrue,  gFalse, &XpdfViewer::cmdPrevPage },
   { "prevPageNoScroll",        0, gTrue,  gFalse, &XpdfViewer::cmdPrevPageNoScroll },
   { "prevTab",                 0, gTrue,  gFalse, &XpdfViewer::cmdPrevTab },
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   { "print",                   0, gTrue,  gFalse, &XpdfViewer::cmdPrint },
 #endif
   { "quit",                    0, gFalse, gFalse, &XpdfViewer::cmdQuit },
@@ -294,6 +294,7 @@ void XpdfErrorWindow::clearBtnPressed() {
 }
 
 void XpdfErrorWindow::closeEvent(QCloseEvent *event) {
+  (void) event;
   lastSize = size();
 }
 
@@ -322,6 +323,10 @@ void XpdfErrorWindow::errorCbk(void *data, ErrorCategory category,
 
 void XpdfErrorWindow::dummyErrorCbk(void *data, ErrorCategory category,
 				    int pos, char *msg) {
+  (void) data;
+  (void) category;
+  (void) pos;
+  (void) msg;
 }
 
 void XpdfErrorWindow::customEvent(QEvent *event) {
@@ -357,6 +362,7 @@ QValidator::State ZoomValidator::validate(QString &input, int &pos) const {
   QChar c;
   int n, i;
 
+  (void) pos;
   n = input.length();
   if (n == 0) {
     return QValidator::Intermediate;
@@ -413,6 +419,8 @@ QVariant PropertyListAnimation::interpolated(const QVariant &from,
 					     qreal progress) const {
   int i;
 
+  (void) from;
+  (void) to;
   i = (int)(progress * valueList.size());
   if (i < 0) {
     i = 0;
@@ -512,6 +520,7 @@ int OutlineModel::rowCount(const QModelIndex &par) const {
 }
 
 int OutlineModel::columnCount(const QModelIndex &par) const {
+  (void) par;
   return 1;
 }
 
@@ -671,6 +680,7 @@ int LayerModel::rowCount(const QModelIndex &par) const {
 }
 
 int LayerModel::columnCount(const QModelIndex &par) const {
+  (void) par;
   return 1;
 }
 
@@ -1094,6 +1104,9 @@ int XpdfViewer::mouseY(QInputEvent *event) {
 }
 
 void XpdfViewer::cmdAbout(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (!aboutDialog) {
     createAboutDialog();
   }
@@ -1103,28 +1116,40 @@ void XpdfViewer::cmdAbout(GString *args[], int nArgs, QInputEvent *event) {
 
 void XpdfViewer::cmdBlockSelectMode(GString *args[], int nArgs,
 				    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setBlockSelectMode();
   updateSelectModeInfo();
 }
 
 void XpdfViewer::cmdCheckOpenFile(GString *args[], int nArgs,
 				  QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   checkOpen(args[0]->getCString(), 1, "", "");
 }
 
 void XpdfViewer::cmdCheckOpenFileAtDest(GString *args[], int nArgs,
 					QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   checkOpen(args[0]->getCString(), 1, args[1]->getCString(), "");
 }
 
 void XpdfViewer::cmdCheckOpenFileAtPage(GString *args[], int nArgs,
 					QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   checkOpen(args[0]->getCString(), atoi(args[1]->getCString()), "", "");
 }
 
 void XpdfViewer::cmdCloseSidebar(GString *args[], int nArgs,
 				 QInputEvent *event) {
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] == 0) {
     return;
   }
@@ -1138,6 +1163,9 @@ void XpdfViewer::cmdCloseSidebarMoveResizeWin(GString *args[], int nArgs,
 					      QInputEvent *event) {
   int newWidth;
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] == 0) {
     return;
   }
@@ -1153,6 +1181,9 @@ void XpdfViewer::cmdCloseSidebarResizeWin(GString *args[], int nArgs,
 					  QInputEvent *event) {
   int newWidth;
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] == 0) {
     return;
   }
@@ -1165,6 +1196,9 @@ void XpdfViewer::cmdCloseSidebarResizeWin(GString *args[], int nArgs,
 
 void XpdfViewer::cmdCloseTabOrQuit(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   closeTab(currentTab);
   if (tabInfo->getLength() == 0) {
     app->closeWindowOrQuit(this);
@@ -1174,35 +1208,54 @@ void XpdfViewer::cmdCloseTabOrQuit(GString *args[], int nArgs,
 
 void XpdfViewer::cmdCloseWindowOrQuit(GString *args[], int nArgs,
 				      QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   app->closeWindowOrQuit(this);
 }
 
 
 void XpdfViewer::cmdContinuousMode(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplayContinuous);
   updateModeInfo();
 }
 
 void XpdfViewer::cmdCopy(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->copySelection();
 }
 
 #if 0 // for debugging
 void XpdfViewer::cmdDebug1(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
 }
 #endif
 
 void XpdfViewer::cmdEndPan(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
   currentTab->pdf->getCore()->endPan(mouseX(event), mouseY(event));
 }
 
 void XpdfViewer::cmdEndSelection(GString *args[], int nArgs,
 				 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
   currentTab->pdf->getCore()->endSelection(mouseX(event), mouseY(event));
 }
 
 void XpdfViewer::cmdFind(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   clearFindError();
   findEdit->setFocus(Qt::OtherFocusReason);
   findEdit->selectAll();
@@ -1211,6 +1264,9 @@ void XpdfViewer::cmdFind(GString *args[], int nArgs, QInputEvent *event) {
 void XpdfViewer::cmdFindFirst(GString *args[], int nArgs, QInputEvent *event) {
   int flags;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   clearFindError();
   flags = 0;
   if (findCaseSensitiveAction->isChecked()) {
@@ -1227,6 +1283,9 @@ void XpdfViewer::cmdFindFirst(GString *args[], int nArgs, QInputEvent *event) {
 void XpdfViewer::cmdFindNext(GString *args[], int nArgs, QInputEvent *event) {
   int flags;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   clearFindError();
   flags = XpdfWidget::findNext;
   if (findCaseSensitiveAction->isChecked()) {
@@ -1244,6 +1303,9 @@ void XpdfViewer::cmdFindPrevious(GString *args[], int nArgs,
 				 QInputEvent *event) {
   int flags;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   clearFindError();
   flags = XpdfWidget::findBackward | XpdfWidget::findNext;
   if (findCaseSensitiveAction->isChecked()) {
@@ -1259,73 +1321,113 @@ void XpdfViewer::cmdFindPrevious(GString *args[], int nArgs,
 
 void XpdfViewer::cmdFocusToDocWin(GString *args[], int nArgs,
 				  QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setFocus(Qt::OtherFocusReason);
 }
 
 void XpdfViewer::cmdFocusToPageNum(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   pageNumber->setFocus(Qt::OtherFocusReason);
   pageNumber->selectAll();
 }
 
 void XpdfViewer::cmdFollowLink(GString *args[], int nArgs,
 			       QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gFalse, gFalse, gFalse);
 }
 
 void XpdfViewer::cmdFollowLinkInNewTab(GString *args[], int nArgs,
 				       QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gFalse, gTrue, gFalse);
 }
 
 void XpdfViewer::cmdFollowLinkInNewTabNoSel(GString *args[], int nArgs,
 					    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gTrue, gTrue, gFalse);
 }
 
 void XpdfViewer::cmdFollowLinkInNewWin(GString *args[], int nArgs,
 				       QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gFalse, gFalse, gTrue);
 }
 
 void XpdfViewer::cmdFollowLinkInNewWinNoSel(GString *args[], int nArgs,
 					    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gTrue, gFalse, gTrue);
 }
 
 void XpdfViewer::cmdFollowLinkNoSel(GString *args[], int nArgs,
 				    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   followLink(event, gTrue, gFalse, gFalse);
 }
 
 void XpdfViewer::cmdFullScreenMode(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (!(windowState() & Qt::WindowFullScreen)) {
     enterFullScreenMode();
   }
 }
 
 void XpdfViewer::cmdGotoDest(GString *args[], int nArgs, QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoNamedDestination(args[0]->getCString());
   updateZoomInfo();
 }
 
 void XpdfViewer::cmdGotoLastPage(GString *args[], int nArgs,
 				 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoLastPage();
 }
 
 void XpdfViewer::cmdGoBackward(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->goBackward();
 }
 
 void XpdfViewer::cmdGoForward(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->goForward();
 }
 
 void XpdfViewer::cmdGotoPage(GString *args[], int nArgs, QInputEvent *event) {
   int pg;
 
+  (void) nArgs;
+  (void) event;
   pg = atoi(args[0]->getCString());
   if (pg < 1 || pg > currentTab->pdf->getNumPages()) {
     return;
@@ -1334,16 +1436,25 @@ void XpdfViewer::cmdGotoPage(GString *args[], int nArgs, QInputEvent *event) {
 }
 
 void XpdfViewer::cmdHelp(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   QDesktopServices::openUrl(QUrl(helpURL, QUrl::TolerantMode));
 }
 
 void XpdfViewer::cmdHorizontalContinuousMode(GString *args[], int nArgs,
 					     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplayHorizontalContinuous);
 }
 
 void XpdfViewer::cmdLinearSelectMode(GString *args[], int nArgs,
 				     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setLinearSelectMode();
   updateSelectModeInfo();
 }
@@ -1356,6 +1467,9 @@ void XpdfViewer::cmdLoadTabState(GString *args[], int nArgs,
   GBool first;
   int n;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   path = globalParams->getTabStateFile();
   if (!(f = openFile(path->getCString(), "rb"))) {
     msg = GString::format("Couldn't read the tab file '{0:t}'", path);
@@ -1395,27 +1509,42 @@ void XpdfViewer::cmdLoadTabState(GString *args[], int nArgs,
 }
 
 void XpdfViewer::cmdNewTab(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   addTab();
   updateModeInfo();
   updateDocInfo();
 }
 
 void XpdfViewer::cmdNewWindow(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   app->newWindow();
 }
 
 void XpdfViewer::cmdNextPage(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoNextPage();
 }
 
 void XpdfViewer::cmdNextPageNoScroll(GString *args[], int nArgs,
 				     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoNextPage(false);
 }
 
 void XpdfViewer::cmdNextTab(GString *args[], int nArgs, QInputEvent *event) {
   int i;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (tabInfo->getLength() == 1) {
     return;
   }
@@ -1436,6 +1565,9 @@ void XpdfViewer::cmdOpen(GString *args[], int nArgs,
   QString startFile, fileName;
   QDir startDir;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (!(startFile = currentTab->pdf->getFileName()).isEmpty()) {
     startDir = QDir(startFile);
     startDir.cdUp();
@@ -1456,27 +1588,39 @@ void XpdfViewer::cmdOpen(GString *args[], int nArgs,
 
 void XpdfViewer::cmdOpenErrorWindow(GString *args[], int nArgs,
 				    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   errorWindow->show();
   errorWindow->raise();
 }
 
 void XpdfViewer::cmdOpenFile(GString *args[], int nArgs, QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   open(args[0]->getCString(), 1, "", "");
 }
 
 void XpdfViewer::cmdOpenFileAtDest(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   open(args[0]->getCString(), 1, args[1]->getCString(), "");
 }
 
 void XpdfViewer::cmdOpenFileAtPage(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   open(args[0]->getCString(), atoi(args[1]->getCString()), "", "");
 }
 
 void XpdfViewer::cmdOpenSidebar(GString *args[], int nArgs,
 				QInputEvent *event) {
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] > 0) {
     return;
   }
@@ -1489,6 +1633,9 @@ void XpdfViewer::cmdOpenSidebarMoveResizeWin(GString *args[], int nArgs,
 					     QInputEvent *event) {
   int newWidth;
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] > 0) {
     return;
   }
@@ -1503,6 +1650,9 @@ void XpdfViewer::cmdOpenSidebarResizeWin(GString *args[], int nArgs,
 					 QInputEvent *event) {
   int newWidth;
   QList<int> sizes = sidebarSplitter->sizes();
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (sizes[0] > 0) {
     return;
   }
@@ -1513,15 +1663,23 @@ void XpdfViewer::cmdOpenSidebarResizeWin(GString *args[], int nArgs,
 }
 
 void XpdfViewer::cmdPageDown(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollPageDown();
 }
 
 void XpdfViewer::cmdPageUp(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollPageUp();
 }
 
 void XpdfViewer::cmdPostPopupMenu(GString *args[], int nArgs,
 				  QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
   if (!popupMenu) {
     return;
   }
@@ -1530,17 +1688,26 @@ void XpdfViewer::cmdPostPopupMenu(GString *args[], int nArgs,
 }
 
 void XpdfViewer::cmdPrevPage(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoPreviousPage();
 }
 
 void XpdfViewer::cmdPrevPageNoScroll(GString *args[], int nArgs,
 				     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->gotoPreviousPage(false);
 }
 
 void XpdfViewer::cmdPrevTab(GString *args[], int nArgs, QInputEvent *event) {
   int i;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (tabInfo->getLength() == 1) {
     return;
   }
@@ -1557,28 +1724,43 @@ void XpdfViewer::cmdPrevTab(GString *args[], int nArgs, QInputEvent *event) {
 }
 
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 void XpdfViewer::cmdPrint(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->print(true);
 }
 #endif
 
 void XpdfViewer::cmdQuit(GString *args[], int nArgs,
 			 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   app->quit();
 }
 
 void XpdfViewer::cmdReload(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (currentTab->pdf->reload() != XpdfWidget::pdfOk) {
     QMessageBox::warning(NULL, "Xpdf Error", "Couldn't reload file");
   }
 }
 
 void XpdfViewer::cmdRotateCW(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setRotate((currentTab->pdf->getRotate() + 90) % 360);
 }
 
 void XpdfViewer::cmdRotateCCW(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setRotate((currentTab->pdf->getRotate() + 270) % 360);
 }
 
@@ -1616,6 +1798,7 @@ void XpdfViewer::cmdRun(GString *args[], int nArgs, QInputEvent *event) {
   char c0, c1;
   int i;
 
+  (void) nArgs;
   cmd = new GString();
   fmt = args[0];
   i = 0;
@@ -1708,6 +1891,9 @@ void XpdfViewer::cmdSaveAs(GString *args[], int nArgs, QInputEvent *event) {
   QString startFile, fileName;
   QDir startDir;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (!(startFile = currentTab->pdf->getFileName()).isEmpty()) {
     startDir = QDir(startFile);
   } else {
@@ -1723,6 +1909,9 @@ void XpdfViewer::cmdSaveAs(GString *args[], int nArgs, QInputEvent *event) {
 }
 
 void XpdfViewer::cmdSaveImage(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   execSaveImageDialog();
 }
 
@@ -1734,6 +1923,9 @@ void XpdfViewer::cmdSaveTabState(GString *args[], int nArgs,
   GString *path, *msg;
   int i;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   path = globalParams->getTabStateFile();
   if (!(f = openFile(path->getCString(), "wb"))) {
     msg = GString::format("Couldn't write the tab file '{0:t}'", path);
@@ -1758,83 +1950,119 @@ void XpdfViewer::cmdSaveTabState(GString *args[], int nArgs,
 void XpdfViewer::cmdScrollDown(GString *args[], int nArgs,
 			       QInputEvent *event) {
   int dy = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollBy(0, dy);
 }
 
 void XpdfViewer::cmdScrollDownNextPage(GString *args[], int nArgs,
 				       QInputEvent *event) {
   int dy = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollDownNextPage(dy);
 }
 
 void XpdfViewer::cmdScrollLeft(GString *args[], int nArgs,
 			       QInputEvent *event) {
   int dx = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollBy(-dx, 0);
 }
 
 void XpdfViewer::cmdScrollOutlineDown(GString *args[], int nArgs,
 				      QInputEvent *event) {
   QScrollBar *sb = currentTab->outlineTree->verticalScrollBar();
+  (void) nArgs;
+  (void) event;
   sb->setValue(sb->value() + atoi(args[0]->getCString()));
 }
 
 void XpdfViewer::cmdScrollOutlineUp(GString *args[], int nArgs,
 				    QInputEvent *event) {
   QScrollBar *sb = currentTab->outlineTree->verticalScrollBar();
+  (void) nArgs;
+  (void) event;
   sb->setValue(sb->value() - atoi(args[0]->getCString()));
 }
 
 void XpdfViewer::cmdScrollRight(GString *args[], int nArgs,
 				QInputEvent *event) {
   int dx = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollBy(dx, 0);
 }
 
 void XpdfViewer::cmdScrollToBottomEdge(GString *args[], int nArgs,
 				       QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToBottomEdge();
 }
 
 void XpdfViewer::cmdScrollToBottomRight(GString *args[], int nArgs,
 					QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToBottomRight();
 }
 
 void XpdfViewer::cmdScrollToLeftEdge(GString *args[], int nArgs,
 				     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToLeftEdge();
 }
 
 void XpdfViewer::cmdScrollToRightEdge(GString *args[], int nArgs,
 				      QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToRightEdge();
 }
 
 void XpdfViewer::cmdScrollToTopEdge(GString *args[], int nArgs,
 				    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToTopEdge();
 }
 
 void XpdfViewer::cmdScrollToTopLeft(GString *args[], int nArgs,
 				    QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollToTopLeft();
 }
 
 void XpdfViewer::cmdScrollUp(GString *args[], int nArgs,
 			     QInputEvent *event) {
   int dy = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->scrollBy(0, -dy);
 }
 
 void XpdfViewer::cmdScrollUpPrevPage(GString *args[], int nArgs,
 				     QInputEvent *event) {
   int dy = scaleScroll(atoi(args[0]->getCString()));
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->getCore()->scrollUpPrevPage(dy);
 }
 
 void XpdfViewer::cmdSetSelection(GString *args[], int nArgs,
 				 QInputEvent *event) {
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setCurrentSelection(atoi(args[0]->getCString()),
 				       atof(args[1]->getCString()),
 				       atof(args[2]->getCString()),
@@ -1844,31 +2072,47 @@ void XpdfViewer::cmdSetSelection(GString *args[], int nArgs,
 
 void XpdfViewer::cmdSideBySideContinuousMode(GString *args[], int nArgs,
 					     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplaySideBySideContinuous);
 }
 
 void XpdfViewer::cmdSideBySideSingleMode(GString *args[], int nArgs,
 					 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplaySideBySideSingle);
 }
 
 void XpdfViewer::cmdSinglePageMode(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplaySingle);
   updateModeInfo();
 }
 
 void XpdfViewer::cmdStartPan(GString *args[], int nArgs, QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
   currentTab->pdf->getCore()->startPan(mouseX(event), mouseY(event));
 }
 
 void XpdfViewer::cmdStartSelection(GString *args[], int nArgs,
 				   QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
   currentTab->pdf->getCore()->startSelection(mouseX(event), mouseY(event));
 }
 
 void XpdfViewer::cmdToggleContinuousMode(GString *args[], int nArgs,
 					 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   XpdfWidget::DisplayMode mode = currentTab->pdf->getDisplayMode();
   if (mode == XpdfWidget::pdfDisplaySingle) {
     currentTab->pdf->setDisplayMode(XpdfWidget::pdfDisplayContinuous);
@@ -1880,6 +2124,9 @@ void XpdfViewer::cmdToggleContinuousMode(GString *args[], int nArgs,
 
 void XpdfViewer::cmdToggleFullScreenMode(GString *args[], int nArgs,
 					 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (windowState() & Qt::WindowFullScreen) {
     exitFullScreenMode();
   } else {
@@ -1889,6 +2136,9 @@ void XpdfViewer::cmdToggleFullScreenMode(GString *args[], int nArgs,
 
 void XpdfViewer::cmdToggleSelectMode(GString *args[], int nArgs,
 				     QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (currentTab->pdf->isBlockSelectMode()) {
     currentTab->pdf->setLinearSelectMode();
   } else {
@@ -1929,6 +2179,9 @@ void XpdfViewer::cmdToggleSidebarResizeWin(GString *args[], int nArgs,
 
 void XpdfViewer::cmdWindowMode(GString *args[], int nArgs,
 			       QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (windowState() & Qt::WindowFullScreen) {
     exitFullScreenMode();
   }
@@ -1936,12 +2189,18 @@ void XpdfViewer::cmdWindowMode(GString *args[], int nArgs,
 
 void XpdfViewer::cmdZoomFitPage(GString *args[], int nArgs,
 				QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->zoomCentered(XpdfWidget::zoomToPage);
   updateZoomInfo();
 }
 
 void XpdfViewer::cmdZoomFitWidth(GString *args[], int nArgs,
 				 QInputEvent *event) {
+  (void) args;
+  (void) nArgs;
+  (void) event;
   currentTab->pdf->zoomCentered(XpdfWidget::zoomToWidth);
   updateZoomInfo();
 }
@@ -1950,6 +2209,9 @@ void XpdfViewer::cmdZoomIn(GString *args[], int nArgs, QInputEvent *event) {
   double z;
   int i;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   z = currentTab->pdf->getZoomPercent(currentTab->pdf->getMidPage());
   for (i = 0; i < zoomComboBox->count(); ++i) {
     if (zoomComboBoxVals[i] > z) {
@@ -1965,6 +2227,9 @@ void XpdfViewer::cmdZoomOut(GString *args[], int nArgs, QInputEvent *event) {
   double z;
   int i;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   z = currentTab->pdf->getZoomPercent(currentTab->pdf->getMidPage());
   for (i = zoomComboBox->count() - 1; i >= 0; --i) {
     if (zoomComboBoxVals[i] < z) {
@@ -1981,6 +2246,8 @@ void XpdfViewer::cmdZoomPercent(GString *args[], int nArgs,
   QString zoomStr;
   int z;
 
+  (void) nArgs;
+  (void) event;
   z = (int)floor(atof(args[0]->getCString()) + 0.5);
   if (z > maxZoom) {
     z = maxZoom;
@@ -1994,6 +2261,9 @@ void XpdfViewer::cmdZoomToSelection(GString *args[], int nArgs,
   double x0, y0, x1, y1, rx, ry, z, w, h, t;
   int pg, xx0, yy0, xx1, yy1;
 
+  (void) args;
+  (void) nArgs;
+  (void) event;
   if (currentTab->pdf->getCurrentSelection(&pg, &x0, &y0, &x1, &y1)) {
     z = currentTab->pdf->getZoomPercent(pg);
     currentTab->pdf->getCore()->cvtUserToDev(pg, x0, y0, &xx0, &yy0);
@@ -2288,6 +2558,7 @@ int XpdfViewer::getContext(Qt::KeyboardModifiers qtMods) {
   GBool contin;
   int context;
 
+  (void) qtMods;
   mode = currentTab->pdf->getDisplayMode();
   contin = mode == XpdfWidget::pdfDisplayContinuous ||
            mode == XpdfWidget::pdfDisplaySideBySideContinuous ||
@@ -2327,7 +2598,7 @@ void XpdfViewer::pageChange(int pg) {
   updateOutline(pg);
 }
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 void XpdfViewer::printStatus(int nextPage, int firstPage, int lastPage) {
   if (!printStatusDialog) {
     printStatusDialog = new QProgressDialog("Printing...", "Cancel",
@@ -2380,7 +2651,7 @@ void XpdfViewer::saveImageMenuAction() {
   execCmd("saveImage", NULL);
 }
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 void XpdfViewer::printMenuAction() {
   execCmd("print", NULL);
 }
@@ -2562,6 +2833,7 @@ void XpdfViewer::switchTab(QListWidgetItem *current,
   XpdfTabInfo *tab;
   int i;
 
+  (void) previous;
   for (i = 0; i < tabInfo->getLength(); ++i) {
     tab = (XpdfTabInfo *)tabInfo->get(i);
     if (tab->listItem == current) {
@@ -2572,6 +2844,7 @@ void XpdfViewer::switchTab(QListWidgetItem *current,
 }
 
 void XpdfViewer::infoComboBoxChanged(int idx) {
+  (void) idx;
   updateInfoPane();
 }
 
@@ -2656,7 +2929,7 @@ void XpdfViewer::createWindow() {
   connect(findErrorTimer, SIGNAL(timeout()), this, SLOT(clearFindError()));
 
   aboutDialog = NULL;
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   printStatusDialog = NULL;
 #endif
 
@@ -2849,7 +3122,7 @@ void XpdfViewer::createMainMenu() {
   fileSubmenu->addAction("&Save as...", this, SLOT(saveAsMenuAction()));
   fileSubmenu->addSeparator();
   fileSubmenu->addAction("Save image...", this, SLOT(saveImageMenuAction()));
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   fileSubmenu->addSeparator();
   fileSubmenu->addAction("&Print...", this, SLOT(printMenuAction()));
 #endif
@@ -3092,7 +3365,7 @@ void XpdfViewer::addTab() {
   connect(pdf, SIGNAL(mouseMove(QMouseEvent*)),
 	  this, SLOT(mouseMove(QMouseEvent*)));
   connect(pdf, SIGNAL(midPageChange(int)), this, SLOT(pageChange(int)));
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   connect(pdf, SIGNAL(printStatus(int, int, int)),
 	  this, SLOT(printStatus(int, int, int)));
 #endif
diff --git a/xpdf-qt/XpdfViewer.h b/xpdf-qt/XpdfViewer.h
index 74b30d7..a5f4310 100644
--- a/xpdf-qt/XpdfViewer.h
+++ b/xpdf-qt/XpdfViewer.h
@@ -168,7 +168,7 @@ private slots:
   void mouseWheel(QWheelEvent *e);
   void mouseMove(QMouseEvent *e);
   void pageChange(int pg);
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   void printStatus(int nextPage, int firstPage, int lastPage);
   void cancelPrint();
 #endif
@@ -178,7 +178,7 @@ private slots:
   void reloadMenuAction();
   void saveAsMenuAction();
   void saveImageMenuAction();
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   void printMenuAction();
 #endif
   void quitMenuAction();
@@ -291,7 +291,7 @@ private:
   void cmdPrevPage(GString *args[], int nArgs, QInputEvent *event);
   void cmdPrevPageNoScroll(GString *args[], int nArgs, QInputEvent *event);
   void cmdPrevTab(GString *args[], int nArgs, QInputEvent *event);
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   void cmdPrint(GString *args[], int nArgs, QInputEvent *event);
 #endif
   void cmdQuit(GString *args[], int nArgs, QInputEvent *event);
@@ -437,7 +437,7 @@ private:
 
   XpdfErrorWindow *errorWindow;
   QDialog *aboutDialog;
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   QProgressDialog *printStatusDialog;
 #endif
 
diff --git a/xpdf-qt/XpdfWidget.cc b/xpdf-qt/XpdfWidget.cc
index ec4dc87..8abe815 100644
--- a/xpdf-qt/XpdfWidget.cc
+++ b/xpdf-qt/XpdfWidget.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #ifdef _WIN32
 #include <windows.h>
 #endif
@@ -20,7 +16,7 @@
 #include <QPaintEvent>
 #include <QTimer>
 #include <QAbstractScrollArea>
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 #  include <QPrinter>
 #  include <QPrintDialog>
 #endif
@@ -43,7 +39,7 @@
 #include "TextString.h"
 #include "QtPDFCore.h"
 #include "XpdfWidget.h"
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 #  include "XpdfWidgetPrint.h"
 #endif
 
@@ -103,7 +99,7 @@ void XpdfWidget::setup(const QColor &paperColor, const QColor &matteColor,
     core = NULL;
   }
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   printerForDialog = NULL;
   printDialog = NULL;
   printHDPI = printVDPI = 0;
@@ -118,7 +114,7 @@ void XpdfWidget::setup(const QColor &paperColor, const QColor &matteColor,
 }
 
 XpdfWidget::~XpdfWidget() {
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   delete printerForDialog;
   delete printDialog;
 #endif
@@ -167,7 +163,7 @@ void XpdfWidget::init(const QString &configFileName) {
       delete dir;
 #else
       globalParams = new GlobalParams(
-			     (char *)configFileName.toLocal8Bit().constData());
+			     configFileName.toLocal8Bit().constData());
       globalParams->setErrQuiet(gTrue);
       globalParams->setupBaseFonts(NULL);
 #endif
@@ -185,7 +181,7 @@ void XpdfWidget::setConfig(const QString &command) {
   init();
   try {
     fileName = new GString("(none)");
-    globalParams->parseLine((char *)command.toLocal8Bit().constData(),
+    globalParams->parseLine(const_cast<char *>(command.toLocal8Bit().constData()),
 			    fileName, 1);
     delete fileName;
   } catch (GMemException e) {
@@ -301,7 +297,7 @@ XpdfWidget::ErrorCode XpdfWidget::loadMem(const char *buffer,
 
   try {
     obj.initNull();
-    stream = new MemStream((char *)buffer, 0, bufferLength, &obj);
+    stream = new MemStream(const_cast<char *>(buffer), 0, bufferLength, &obj);
     if (password.isEmpty()) {
       passwordStr = NULL;
     } else {
@@ -1159,7 +1155,7 @@ void XpdfWidget::forceRedraw() {
   }
 }
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 
 bool XpdfWidget::okToPrint() const {
   try {
@@ -1227,7 +1223,7 @@ void XpdfWidget::setPrintDPI(int hDPI, int vDPI) {
   printVDPI = vDPI;
 }
 
-#endif // XPDFWIDGET_PRINTING
+#endif /* XPDFWIDGET_PRINTING */
 
 QImage XpdfWidget::convertPageToImage(int page, double dpi) {
   PDFDoc *doc;
@@ -1415,7 +1411,11 @@ bool XpdfWidget::okToExtractText() const {
     if (!core->getDoc()) {
       return false;
     }
+#if 0
     return (bool)core->getDoc()->okToCopy();
+#else
+	return true;
+#endif
   } catch (GMemException e) {
     return false;
   }
@@ -1424,7 +1424,7 @@ bool XpdfWidget::okToExtractText() const {
 void XpdfWidget::setTextEncoding(const QString &encodingName) {
   init();
   try {
-    globalParams->setTextEncoding((char *)encodingName.toLatin1().constData());
+    globalParams->setTextEncoding(encodingName.toLatin1().constData());
   } catch (GMemException e) {
   }
 }
@@ -1862,6 +1862,8 @@ void XpdfWidget::updateCbk(void *data, GString *fileName,
 			   const char *linkLabel) {
   XpdfWidget *xpdf = (XpdfWidget *)data;
 
+  (void) numPages;
+  (void) linkLabel;
   if (fileName) {
     if (pageNum >= 0) {
       emit xpdf->pageChange(pageNum);
@@ -1926,11 +1928,14 @@ void XpdfWidget::paintEvent(QPaintEvent *eventA) {
 }
 
 void XpdfWidget::resizeEvent(QResizeEvent *eventA) {
+  (void) eventA;
   core->resizeEvent();
   emit resized();
 }
 
 void XpdfWidget::scrollContentsBy(int dx, int dy) {
+  (void) dx;
+  (void) dy;
   core->scrollEvent();
 }
 
diff --git a/xpdf-qt/XpdfWidget.h b/xpdf-qt/XpdfWidget.h
index da92e30..ed76d1a 100644
--- a/xpdf-qt/XpdfWidget.h
+++ b/xpdf-qt/XpdfWidget.h
@@ -19,15 +19,11 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <QAbstractScrollArea>
 
 class QMutex;
 class QTimer;
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 class QPrinter;
 class QPrintDialog;
 #endif
@@ -561,7 +557,7 @@ public:
   //! Force a complete redraw.
   void forceRedraw();
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   //! Checks to see if printing is allowed.
   //! This function returns false if the currently displayed PDF file
   //! is encrypted and does not allow printing (or if no PDF file is
@@ -595,7 +591,7 @@ public:
   //! typically the same.  (There are exceptions, such as some chart
   //! printers.)
   void setPrintDPI(int hDPI, int vDPI);
-#endif // XPDFWIDGET_PRINTING
+#endif /* XPDFWIDGET_PRINTING */
 
   //! Convert a page to a color image.
   //! This function converts the page number \a page to a 24-bit RGB
@@ -848,7 +844,7 @@ signals:
   void resized();
 
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   //! This signal is called before each page is spooled, and after the
   //! last page is spooled.  It is typically used to update a print
   //! status dialog.  \a nextPage is the next page to be printed.
@@ -903,7 +899,7 @@ private:
 		     QString &targetFileName, int &targetPage,
 		     QString &targetDest);
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
   QPrinter *printerForDialog;
   QPrintDialog *printDialog;
   int printHDPI, printVDPI;
diff --git a/xpdf-qt/XpdfWidgetPrint.cc b/xpdf-qt/XpdfWidgetPrint.cc
index e57ae10..d9f2743 100644
--- a/xpdf-qt/XpdfWidgetPrint.cc
+++ b/xpdf-qt/XpdfWidgetPrint.cc
@@ -6,10 +6,10 @@
 //
 //========================================================================
 
-#if XPDFWIDGET_PRINTING
-
 #include <aconf.h>
 
+#ifdef XPDFWIDGET_PRINTING
+
 #include <stdlib.h>
 #include <QPrinter>
 #include "gfile.h"
@@ -24,6 +24,7 @@
 #elif defined(__linux__)
 #  include "PSOutputDev.h"
 #  include <cups/cups.h>
+#include "XpdfWidgetPrint.h"
 #endif
 
 #include "gmempp.h"
@@ -342,6 +343,8 @@ XpdfWidget::ErrorCode printPDF(PDFDoc *doc, QPrinter *prt,
 
   //--- get page range
 
+  (void) hDPI;
+  (void) vDPI;
   startPage = prt->fromPage();
   endPage = prt->toPage();
   if (startPage == 0) {
@@ -497,4 +500,4 @@ XpdfWidget::ErrorCode printPDF(PDFDoc *doc, QPrinter *prt,
 
 #endif
 
-#endif // XPDFWIDGET_PRINTING
+#endif /* XPDFWIDGET_PRINTING */
diff --git a/xpdf-qt/XpdfWidgetPrint.h b/xpdf-qt/XpdfWidgetPrint.h
index b48cd8f..d5bd20b 100644
--- a/xpdf-qt/XpdfWidgetPrint.h
+++ b/xpdf-qt/XpdfWidgetPrint.h
@@ -9,7 +9,7 @@
 #ifndef XPDFWIDGETPRINT_H
 #define XPDFWIDGETPRINT_H
 
-#if XPDFWIDGET_PRINTING
+#ifdef XPDFWIDGET_PRINTING
 
 #include <aconf.h>
 
@@ -19,6 +19,6 @@ extern XpdfWidget::ErrorCode printPDF(PDFDoc *doc, QPrinter *prt,
 				      int hDPI, int vDPI,
 				      XpdfWidget *widget);
 
-#endif // XPDFWIDGET_PRINTING
+#endif /* XPDFWIDGET_PRINTING */
 
-#endif // XPDFWIDGETPRINT_H
+#endif /* XPDFWIDGETPRINT_H */
diff --git a/xpdf/.gitignore b/xpdf/.gitignore
new file mode 100644
index 0000000..eb47c80
--- /dev/null
+++ b/xpdf/.gitignore
@@ -0,0 +1,9 @@
+pdfdetach
+pdffonts
+pdfimages
+pdfinfo
+pdftohtml
+pdftopng
+pdftoppm
+pdftops
+pdftotext
diff --git a/xpdf/AcroForm.cc b/xpdf/AcroForm.cc
index 1d312e9..1e14226 100644
--- a/xpdf/AcroForm.cc
+++ b/xpdf/AcroForm.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <math.h>
 #include "gmem.h"
@@ -1006,7 +1002,7 @@ void AcroFormField::drawNewAppearance(Gfx *gfx, Dict *annot,
 	      appearBuf->appendf(" {0:.4f}", borderDash[i]);
 	    }
 	    appearBuf->append("] 0 d\n");
-	    // fall through to the solid case
+	    // fall through
 	  case annotBorderSolid:
 	  case annotBorderUnderlined:
 	    appearBuf->appendf("{0:.4f} w\n", borderWidth);
@@ -1041,7 +1037,7 @@ void AcroFormField::drawNewAppearance(Gfx *gfx, Dict *annot,
 	      appearBuf->appendf(" {0:.4f}", borderDash[i]);
 	    }
 	    appearBuf->append("] 0 d\n");
-	    // fall through to the solid case
+	    // fall through
 	  case annotBorderSolid:
 	    appearBuf->appendf("{0:.4f} w\n", borderWidth);
 	    setColor(obj1.getArray(), gFalse, 0, appearBuf);
diff --git a/xpdf/AcroForm.h b/xpdf/AcroForm.h
index a92979a..7c979bb 100644
--- a/xpdf/AcroForm.h
+++ b/xpdf/AcroForm.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Form.h"
 
 class TextString;
diff --git a/xpdf/Annot.cc b/xpdf/Annot.cc
index 850c6b2..f83b66d 100644
--- a/xpdf/Annot.cc
+++ b/xpdf/Annot.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <math.h>
 #include "gmem.h"
@@ -801,6 +797,7 @@ void Annot::setLineStyle(AnnotBorderStyle *bs, double *lineWidth) {
   double w;
   int dashLength, i;
 
+  (void) bs;
   if ((w = borderStyle->getWidth()) <= 0) {
     w = 0.1;
   }
diff --git a/xpdf/Annot.h b/xpdf/Annot.h
index 6ba5ff4..3456f65 100644
--- a/xpdf/Annot.h
+++ b/xpdf/Annot.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 class XRef;
 class Catalog;
 class Gfx;
diff --git a/xpdf/Array.cc b/xpdf/Array.cc
index 2bf948e..d3191fa 100644
--- a/xpdf/Array.cc
+++ b/xpdf/Array.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stddef.h>
 #include "gmem.h"
diff --git a/xpdf/Array.h b/xpdf/Array.h
index 8d10ead..ece0d0f 100644
--- a/xpdf/Array.h
+++ b/xpdf/Array.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 #include "Object.h"
@@ -36,7 +32,7 @@ public:
   ~Array();
 
   // Reference counting.
-#if MULTITHREADED
+#ifdef MULTITHREADED
   long incRef() { return gAtomicIncrement(&ref); }
   long decRef() { return gAtomicDecrement(&ref); }
 #else
@@ -60,7 +56,7 @@ private:
   Object *elems;		// array of elements
   int size;			// size of <elems> array
   int length;			// number of elements in array
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter ref;		// reference count
 #else
   long ref;			// reference count
diff --git a/xpdf/BuiltinFont.cc b/xpdf/BuiltinFont.cc
index 01dbd11..ca65adc 100644
--- a/xpdf/BuiltinFont.cc
+++ b/xpdf/BuiltinFont.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include "gmem.h"
diff --git a/xpdf/BuiltinFont.h b/xpdf/BuiltinFont.h
index f24cbf9..5d14676 100644
--- a/xpdf/BuiltinFont.h
+++ b/xpdf/BuiltinFont.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 struct BuiltinFont;
@@ -24,7 +20,7 @@ class BuiltinFontWidths;
 
 struct BuiltinFont {
   const char *name;
-  const char **defaultBaseEnc;
+  const char *const *defaultBaseEnc;
   short missingWidth;
   short ascent;
   short descent;
diff --git a/xpdf/CMakeLists.txt b/xpdf/CMakeLists.txt
deleted file mode 100644
index 8fb3f20..0000000
--- a/xpdf/CMakeLists.txt
+++ /dev/null
@@ -1,234 +0,0 @@
-#========================================================================
-#
-# xpdf/cmake-xpdf.txt
-#
-# CMake script for the Xpdf tools.
-#
-# Copyright 2015 Glyph & Cog, LLC
-#
-#========================================================================
-
-include_directories("${PROJECT_SOURCE_DIR}")
-include_directories("${PROJECT_BINARY_DIR}")
-include_directories("${PROJECT_SOURCE_DIR}/goo")
-include_directories("${PROJECT_SOURCE_DIR}/fofi")
-include_directories("${PROJECT_SOURCE_DIR}/splash")
-if (PNG_FOUND)
-  include_directories("${PNG_INCLUDE_DIRS}")
-  add_definitions("${PNG_DEFINITIONS}")
-endif ()
-if (HAVE_LCMS)
-  include_directories("${LCMS_INCLUDE_DIR}")
-  set(COLOR_MANAGER_SOURCE "ColorManager.cc")
-else ()
-  set(COLOR_MANAGER_SOURCE "")
-endif ()
-
-add_library(xpdf_objs OBJECT
-  AcroForm.cc
-  Annot.cc
-  Array.cc
-  BuiltinFont.cc
-  BuiltinFontTables.cc
-  Catalog.cc
-  CharCodeToUnicode.cc
-  CMap.cc
-  ${COLOR_MANAGER_SOURCE}
-  Decrypt.cc
-  Dict.cc
-  Error.cc
-  FontEncodingTables.cc
-  Form.cc
-  Function.cc
-  Gfx.cc
-  GfxFont.cc
-  GfxState.cc
-  GlobalParams.cc
-  JArithmeticDecoder.cc
-  JBIG2Stream.cc
-  JPXStream.cc
-  Lexer.cc
-  Link.cc
-  NameToCharCode.cc
-  Object.cc
-  OptionalContent.cc
-  Outline.cc
-  OutputDev.cc
-  Page.cc
-  Parser.cc
-  PDF417Barcode.cc
-  PDFDoc.cc
-  PDFDocEncoding.cc
-  PSTokenizer.cc
-  SecurityHandler.cc
-  Stream.cc
-  TextString.cc
-  UnicodeMap.cc
-  UnicodeRemapping.cc
-  UnicodeTypeTable.cc
-  UTF8.cc
-  XFAForm.cc
-  XRef.cc
-  Zoox.cc
-)
-
-#--- object files needed by XpdfWidget
-
-if ((QT4_FOUND OR Qt5Widgets_FOUND)
-    AND HAVE_SPLASH AND MULTITHREADED AND USE_EXCEPTIONS)
-
-  if (HIGHLIGHTED_REGIONS)
-    set(HIGHLIGHT_SRC "HighlightFile.cc")
-  else ()
-    set(HIGHLIGHT_SRC "")
-  endif ()
-
-  add_library(xpdf_widget_objs OBJECT
-    DisplayState.cc
-    PDFCore.cc
-    PreScanOutputDev.cc
-    PSOutputDev.cc
-    SplashOutputDev.cc
-    TextOutputDev.cc
-    TileCache.cc
-    TileCompositor.cc
-    TileMap.cc
-    ${HIGHLIGHT_SRC}
-  )
-endif ()
-
-#--- pdftops
-
-if (HAVE_SPLASH)
-  add_executable(pdftops
-    $<TARGET_OBJECTS:xpdf_objs>
-    PreScanOutputDev.cc
-    PSOutputDev.cc
-    SplashOutputDev.cc
-    pdftops.cc
-  )
-  target_link_libraries(pdftops goo fofi splash
-                        ${PAPER_LIBRARY}
-                        ${FREETYPE_LIBRARY} ${FREETYPE_OTHER_LIBS}
-                        ${DTYPE_LIBRARY}
-                        ${LCMS_LIBRARY})
-else ()
-  add_executable(pdftops
-    $<TARGET_OBJECTS:xpdf_objs>
-    PreScanOutputDev.cc
-    PSOutputDev.cc
-    pdftops.cc
-  )
-  target_link_libraries(pdftops goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-endif ()
-install(TARGETS pdftops RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdftops.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- pdftotext
-
-add_executable(pdftotext
-  $<TARGET_OBJECTS:xpdf_objs>
-  TextOutputDev.cc
-  pdftotext.cc
-)
-target_link_libraries(pdftotext goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-install(TARGETS pdftotext RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdftotext.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- pdftohtml
-
-if (HAVE_SPLASH AND PNG_FOUND)
-  add_executable(pdftohtml
-    $<TARGET_OBJECTS:xpdf_objs>
-    HTMLGen.cc
-    SplashOutputDev.cc
-    TextOutputDev.cc
-    pdftohtml.cc
-  )
-  target_link_libraries(pdftohtml goo fofi splash
-                        ${PAPER_LIBRARY}
-                        ${FREETYPE_LIBRARY} ${FREETYPE_OTHER_LIBS}
-                        ${DTYPE_LIBRARY}
-                        ${LCMS_LIBRARY} ${PNG_LIBRARIES})
-  install(TARGETS pdftohtml RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-  install(FILES ${PROJECT_SOURCE_DIR}/doc/pdftohtml.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-endif ()
-
-#--- pdfinfo
-
-add_executable(pdfinfo
-  $<TARGET_OBJECTS:xpdf_objs>
-  pdfinfo.cc
-)
-target_link_libraries(pdfinfo goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-install(TARGETS pdfinfo RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdfinfo.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- pdffonts
-
-add_executable(pdffonts
-  $<TARGET_OBJECTS:xpdf_objs>
-  pdffonts.cc
-)
-target_link_libraries(pdffonts goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-install(TARGETS pdffonts RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdffonts.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- pdfdetach
-
-add_executable(pdfdetach
-  $<TARGET_OBJECTS:xpdf_objs>
-  pdfdetach.cc
-)
-target_link_libraries(pdfdetach goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-install(TARGETS pdfdetach RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdfdetach.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- pdftoppm
-
-if (HAVE_SPLASH)
-  add_executable(pdftoppm
-    $<TARGET_OBJECTS:xpdf_objs>
-    SplashOutputDev.cc
-    pdftoppm.cc
-  )
-  target_link_libraries(pdftoppm goo fofi splash
-                        ${PAPER_LIBRARY}
-                        ${FREETYPE_LIBRARY} ${FREETYPE_OTHER_LIBS}
-                        ${DTYPE_LIBRARY}
-                        ${LCMS_LIBRARY})
-  install(TARGETS pdftoppm RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-  install(FILES ${PROJECT_SOURCE_DIR}/doc/pdftoppm.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-endif ()
-
-#--- pdftopng
-
-if (HAVE_SPLASH AND PNG_FOUND)
-  add_executable(pdftopng
-    $<TARGET_OBJECTS:xpdf_objs>
-    SplashOutputDev.cc
-    pdftopng.cc
-  )
-  target_link_libraries(pdftopng goo fofi splash
-                        ${PAPER_LIBRARY}
-                        ${FREETYPE_LIBRARY} ${FREETYPE_OTHER_LIBS}
-                        ${DTYPE_LIBRARY}
-                        ${LCMS_LIBRARY} ${PNG_LIBRARIES})
-  install(TARGETS pdftopng RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-  install(FILES ${PROJECT_SOURCE_DIR}/doc/pdftopng.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-endif ()
-
-#--- pdfimages
-
-add_executable(pdfimages
-  $<TARGET_OBJECTS:xpdf_objs>
-  ImageOutputDev.cc
-  pdfimages.cc
-)
-target_link_libraries(pdfimages goo fofi ${PAPER_LIBRARY} ${LCMS_LIBRARY})
-install(TARGETS pdfimages RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-install(FILES ${PROJECT_SOURCE_DIR}/doc/pdfimages.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-
-#--- xpdfrc man page
-
-install(FILES ${PROJECT_SOURCE_DIR}/doc/xpdfrc.5 DESTINATION ${CMAKE_INSTALL_MANDIR}/man5)
diff --git a/xpdf/CMap.cc b/xpdf/CMap.cc
index 12632c5..852454e 100644
--- a/xpdf/CMap.cc
+++ b/xpdf/CMap.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -53,6 +49,7 @@ CMap *CMap::parse(CMapCache *cache, GString *collectionA, Object *obj) {
   CMap *cMap;
   GString *cMapNameA;
 
+  (void)cache;
   if (obj->isName()) {
     cMapNameA = new GString(obj->getName());
     if (!(cMap = globalParams->getCMap(collectionA, cMapNameA))) {
@@ -333,7 +330,7 @@ void CMap::freeCMapVector(CMapVectorEntry *vec) {
 }
 
 void CMap::incRefCnt() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicIncrement(&refCnt);
 #else
   ++refCnt;
@@ -343,7 +340,7 @@ void CMap::incRefCnt() {
 void CMap::decRefCnt() {
   GBool done;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   done = gAtomicDecrement(&refCnt) == 0;
 #else
   done = --refCnt == 0;
diff --git a/xpdf/CMap.h b/xpdf/CMap.h
index 55692b4..2ef9cac 100644
--- a/xpdf/CMap.h
+++ b/xpdf/CMap.h
@@ -11,14 +11,10 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "CharTypes.h"
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -84,7 +80,7 @@ private:
   int wMode;			// writing mode (0=horizontal, 1=vertical)
   CMapVectorEntry *vector;	// vector for first byte (NULL for
 				//   identity CMap)
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter refCnt;
 #else
   int refCnt;
diff --git a/xpdf/Catalog.cc b/xpdf/Catalog.cc
index 4708073..9dd6b0a 100644
--- a/xpdf/Catalog.cc
+++ b/xpdf/Catalog.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include <stddef.h>
 #include <limits.h>
@@ -106,7 +102,7 @@ Catalog::Catalog(PDFDoc *docA) {
   baseURI = NULL;
   form = NULL;
   embeddedFiles = NULL;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gInitMutex(&pageMutex);
 #endif
 
@@ -177,7 +173,9 @@ Catalog::Catalog(PDFDoc *docA) {
   // create the Form
   // (if acroForm is a null object, this will still create an AcroForm
   // if there are unattached Widget-type annots)
+#ifndef __atarist__
   form = Form::load(doc, this, &acroForm);
+#endif
 
   // get the OCProperties dictionary
   catDict.dictLookup("OCProperties", &ocProperties);
@@ -210,7 +208,7 @@ Catalog::~Catalog() {
     gfree(pages);
     gfree(pageRefs);
   }
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gDestroyMutex(&pageMutex);
 #endif
   dests.free();
@@ -234,14 +232,14 @@ Catalog::~Catalog() {
 Page *Catalog::getPage(int i) {
   Page *page;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&pageMutex);
 #endif
   if (!pages[i-1]) {
     loadPage(i);
   }
   page = pages[i-1];
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&pageMutex);
 #endif
   return page;
@@ -250,28 +248,28 @@ Page *Catalog::getPage(int i) {
 Ref *Catalog::getPageRef(int i) {
   Ref *pageRef;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&pageMutex);
 #endif
   if (!pages[i-1]) {
     loadPage(i);
   }
   pageRef = &pageRefs[i-1];
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&pageMutex);
 #endif
   return pageRef;
 }
 
 void Catalog::doneWithPage(int i) {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&pageMutex);
 #endif
   if (pages[i-1]) {
     delete pages[i-1];
     pages[i-1] = NULL;
   }
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&pageMutex);
 #endif
 }
@@ -304,7 +302,7 @@ GString *Catalog::readMetadata() {
 int Catalog::findPage(int num, int gen) {
   int i;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&pageMutex);
 #endif
   for (i = 0; i < numPages; ++i) {
@@ -312,13 +310,13 @@ int Catalog::findPage(int num, int gen) {
       loadPage(i+1);
     }
     if (pageRefs[i].num == num && pageRefs[i].gen == gen) {
-#if MULTITHREADED
+#ifdef MULTITHREADED
       gUnlockMutex(&pageMutex);
 #endif
       return i + 1;
     }
   }
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&pageMutex);
 #endif
   return 0;
diff --git a/xpdf/Catalog.h b/xpdf/Catalog.h
index 803550d..3574764 100644
--- a/xpdf/Catalog.h
+++ b/xpdf/Catalog.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 #include "CharTypes.h"
@@ -114,7 +110,7 @@ private:
   PageTreeNode *pageTree;	// the page tree
   Page **pages;			// array of pages
   Ref *pageRefs;		// object ID for each page
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GMutex pageMutex;
 #endif
   int numPages;			// number of pages
diff --git a/xpdf/CharCodeToUnicode.cc b/xpdf/CharCodeToUnicode.cc
index 0d064cf..faf77eb 100644
--- a/xpdf/CharCodeToUnicode.cc
+++ b/xpdf/CharCodeToUnicode.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <string.h>
 #include "gmem.h"
@@ -54,7 +50,7 @@ static int getCharFromFile(void *data) {
 
 //------------------------------------------------------------------------
 
-static int hexCharVals[256] = {
+static int const hexCharVals[256] = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0x
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 1x
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 2x
@@ -589,7 +585,7 @@ CharCodeToUnicode::~CharCodeToUnicode() {
 }
 
 void CharCodeToUnicode::incRefCnt() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicIncrement(&refCnt);
 #else
   ++refCnt;
@@ -599,7 +595,7 @@ void CharCodeToUnicode::incRefCnt() {
 void CharCodeToUnicode::decRefCnt() {
   GBool done;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   done = gAtomicDecrement(&refCnt) == 0;
 #else
   done = --refCnt == 0;
diff --git a/xpdf/CharCodeToUnicode.h b/xpdf/CharCodeToUnicode.h
index 5d7bea5..9ea01db 100644
--- a/xpdf/CharCodeToUnicode.h
+++ b/xpdf/CharCodeToUnicode.h
@@ -13,13 +13,9 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "CharTypes.h"
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -93,7 +89,7 @@ private:
   CharCode mapLen;
   CharCodeToUnicodeString *sMap;
   int sMapLen, sMapSize;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter refCnt;
 #else
   int refCnt;
diff --git a/xpdf/Decrypt.cc b/xpdf/Decrypt.cc
index d4f8d4e..df85342 100644
--- a/xpdf/Decrypt.cc
+++ b/xpdf/Decrypt.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
@@ -24,7 +20,7 @@ static void sha256(Guchar *msg, int msgLen, Guchar *hash);
 static void sha384(Guchar *msg, int msgLen, Guchar *hash);
 static void sha512(Guchar *msg, int msgLen, Guchar *hash);
 
-static Guchar passwordPad[32] = {
+static Guchar const passwordPad[32] = {
   0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,
   0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 
   0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 
@@ -260,6 +256,7 @@ GBool Decrypt::makeFileKey2(int encVersion, int encRevision, int keyLength,
   int len, i, j;
   GBool ok;
 
+  (void) encVersion;
   // generate file key
   buf = (Guchar *)gmalloc(72 + fileID->getLength());
   if (userPassword) {
@@ -543,7 +540,7 @@ Guchar rc4DecryptByte(Guchar *state, Guchar *x, Guchar *y, Guchar c) {
 // AES decryption
 //------------------------------------------------------------------------
 
-static Guchar sbox[256] = {
+static Guchar const sbox[256] = {
   0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
   0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
   0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
@@ -562,7 +559,7 @@ static Guchar sbox[256] = {
   0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
 };
 
-static Guchar invSbox[256] = {
+static Guchar const invSbox[256] = {
   0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
   0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
   0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
@@ -581,7 +578,7 @@ static Guchar invSbox[256] = {
   0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
 };
 
-static Guint rcon[11] = {
+static Guint const rcon[11] = {
   0x00000000, // unused
   0x01000000,
   0x02000000,
@@ -789,6 +786,7 @@ void aesKeyExpansion(DecryptAESState *s,
   Guint temp;
   int i, round;
 
+  (void) objKeyLen;
   //~ this assumes objKeyLen == 16
 
   for (i = 0; i < 4; ++i) {
@@ -908,6 +906,7 @@ static void aes256KeyExpansion(DecryptAES256State *s,
   Guint temp;
   int i, round;
 
+  (void) objKeyLen;
   //~ this assumes objKeyLen == 32
 
   for (i = 0; i < 8; ++i) {
@@ -1199,7 +1198,7 @@ void md5(Guchar *msg, int msgLen, Guchar *digest) {
 // SHA-256 hash
 //------------------------------------------------------------------------
 
-static Guint sha256K[64] = {
+static Guint const sha256K[64] = {
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
@@ -1358,7 +1357,7 @@ static void sha256(Guchar *msg, int msgLen, Guchar *hash) {
 
 typedef unsigned long long SHA512Uint64;
 
-static SHA512Uint64 sha512K[80] = {
+static SHA512Uint64 const sha512K[80] = {
   0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
   0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
   0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
diff --git a/xpdf/Decrypt.h b/xpdf/Decrypt.h
index 2b10abd..d0f3840 100644
--- a/xpdf/Decrypt.h
+++ b/xpdf/Decrypt.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "GString.h"
 #include "Object.h"
diff --git a/xpdf/Dict.cc b/xpdf/Dict.cc
index c8c2973..71ea377 100644
--- a/xpdf/Dict.cc
+++ b/xpdf/Dict.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include <string.h>
 #include "gmem.h"
diff --git a/xpdf/Dict.h b/xpdf/Dict.h
index b05f729..a118d33 100644
--- a/xpdf/Dict.h
+++ b/xpdf/Dict.h
@@ -11,11 +11,7 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 #include "Object.h"
@@ -36,7 +32,7 @@ public:
   ~Dict();
 
   // Reference counting.
-#if MULTITHREADED
+#ifdef MULTITHREADED
   long incRef() { return gAtomicIncrement(&ref); }
   long decRef() { return gAtomicDecrement(&ref); }
 #else
@@ -75,7 +71,7 @@ private:
   DictEntry **hashTab;		// hash table pointers
   int size;			// size of <entries> array
   int length;			// number of entries in dictionary
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter ref;		// reference count
 #else
   long ref;			// reference count
diff --git a/xpdf/DisplayState.cc b/xpdf/DisplayState.cc
index e0d3068..f1e8dcf 100644
--- a/xpdf/DisplayState.cc
+++ b/xpdf/DisplayState.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include "gmempp.h"
 #include "GString.h"
diff --git a/xpdf/DisplayState.h b/xpdf/DisplayState.h
index 12c8170..a078c75 100644
--- a/xpdf/DisplayState.h
+++ b/xpdf/DisplayState.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "SplashTypes.h"
 
diff --git a/xpdf/Error.cc b/xpdf/Error.cc
index 5a97505..eff6659 100644
--- a/xpdf/Error.cc
+++ b/xpdf/Error.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stddef.h>
 #include <stdarg.h>
@@ -20,7 +16,7 @@
 #include "GlobalParams.h"
 #include "Error.h"
 
-const char *errorCategoryNames[] = {
+const char *const errorCategoryNames[] = {
   "Syntax Warning",
   "Syntax Error",
   "Config Error",
diff --git a/xpdf/Error.h b/xpdf/Error.h
index 39e7613..e40e489 100644
--- a/xpdf/Error.h
+++ b/xpdf/Error.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #include "config.h"
 #include "gfile.h"
@@ -34,7 +30,7 @@ enum ErrorCategory {
   errInternal		// internal error - malfunction within the Xpdf code
 };
 
-extern const char *errorCategoryNames[];
+extern const char *const errorCategoryNames[];
 
 extern void setErrorCallback(void (*cbk)(void *data, ErrorCategory category,
 					 int pos, char *msg),
diff --git a/xpdf/FontEncodingTables.cc b/xpdf/FontEncodingTables.cc
index d4b18ab..7c4bf05 100644
--- a/xpdf/FontEncodingTables.cc
+++ b/xpdf/FontEncodingTables.cc
@@ -11,7 +11,7 @@
 #include "gmempp.h"
 #include "FontEncodingTables.h"
 
-const char *macRomanEncoding[256] = {
+const char *const macRomanEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -270,7 +270,7 @@ const char *macRomanEncoding[256] = {
   "caron"
 };
 
-const char *macExpertEncoding[256] = {
+const char *const macExpertEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -529,7 +529,7 @@ const char *macExpertEncoding[256] = {
   NULL
 };
 
-const char *winAnsiEncoding[256] = {
+const char *const winAnsiEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -788,7 +788,7 @@ const char *winAnsiEncoding[256] = {
   "ydieresis"
 };
 
-const char *standardEncoding[256] = {
+const char *const standardEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -1047,7 +1047,7 @@ const char *standardEncoding[256] = {
   NULL
 };
 
-const char *expertEncoding[256] = {
+const char *const expertEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -1306,7 +1306,7 @@ const char *expertEncoding[256] = {
   "Ydieresissmall"
 };
 
-const char *symbolEncoding[256] = {
+const char *const symbolEncoding[256] = {
   NULL,
   NULL,
   NULL,
@@ -1565,7 +1565,7 @@ const char *symbolEncoding[256] = {
   NULL
 };
 
-const char *zapfDingbatsEncoding[256] = {
+const char *const zapfDingbatsEncoding[256] = {
   NULL,
   NULL,
   NULL,
diff --git a/xpdf/FontEncodingTables.h b/xpdf/FontEncodingTables.h
index a417b32..02cf78c 100644
--- a/xpdf/FontEncodingTables.h
+++ b/xpdf/FontEncodingTables.h
@@ -9,12 +9,12 @@
 #ifndef FONTENCODINGTABLES_H
 #define FONTENCODINGTABLES_H
 
-extern const char *macRomanEncoding[];
-extern const char *macExpertEncoding[];
-extern const char *winAnsiEncoding[];
-extern const char *standardEncoding[];
-extern const char *expertEncoding[];
-extern const char *symbolEncoding[];
-extern const char *zapfDingbatsEncoding[];
+extern const char *const macRomanEncoding[];
+extern const char *const macExpertEncoding[];
+extern const char *const winAnsiEncoding[];
+extern const char *const standardEncoding[];
+extern const char *const expertEncoding[];
+extern const char *const symbolEncoding[];
+extern const char *const zapfDingbatsEncoding[];
 
 #endif
diff --git a/xpdf/Form.cc b/xpdf/Form.cc
index 681401a..b52f0fe 100644
--- a/xpdf/Form.cc
+++ b/xpdf/Form.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "GlobalParams.h"
 #include "Error.h"
diff --git a/xpdf/Form.h b/xpdf/Form.h
index 0e851fe..1900f50 100644
--- a/xpdf/Form.h
+++ b/xpdf/Form.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 class Gfx;
diff --git a/xpdf/Function.cc b/xpdf/Function.cc
index 72cadd9..50e692f 100644
--- a/xpdf/Function.cc
+++ b/xpdf/Function.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
@@ -437,6 +433,7 @@ void SampledFunction::transform(double *in, double *out) {
   }
 
   // map input values into sample array
+  e[0] = 0;
   for (i = 0; i < m; ++i) {
     x = (in[i] - domain[i][0]) * inputMul[i] + encode[i][0];
     if (x < 0 || x != x) {  // x!=x is a more portable version of isnan(x)
@@ -501,6 +498,7 @@ ExponentialFunction::ExponentialFunction(Object *funcObj, Dict *dict) {
   Object obj1, obj2;
   int i;
 
+  (void) funcObj;
   ok = gFalse;
 
   //----- initialize the generic stuff
@@ -627,6 +625,7 @@ StitchingFunction::StitchingFunction(Object *funcObj, Dict *dict,
   Object obj1, obj2;
   int i;
 
+  (void) funcObj;
   ok = gFalse;
   funcs = NULL;
   bounds = NULL;
@@ -841,7 +840,7 @@ void StitchingFunction::transform(double *in, double *out) {
 // The rest are listed here in alphabetical order.
 //
 // NB: This must be kept in sync with the psOpXXX defines above.
-static const char *psOpNames[] = {
+static const char *const psOpNames[] = {
   "abs",
   "add",
   "and",
diff --git a/xpdf/Function.h b/xpdf/Function.h
index 5cf4516..825471f 100644
--- a/xpdf/Function.h
+++ b/xpdf/Function.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 
diff --git a/xpdf/Gfx.cc b/xpdf/Gfx.cc
index 5d34eb9..136c893 100644
--- a/xpdf/Gfx.cc
+++ b/xpdf/Gfx.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <stddef.h>
@@ -93,7 +89,7 @@
 #  pragma optimize("",off)
 #endif
 
-Operator Gfx::opTab[] = {
+Operator const Gfx::opTab[] = {
   {"\"",  3, {tchkNum,    tchkNum,    tchkString},
           &Gfx::opMoveSetShowText},
   {"'",   1, {tchkString},
@@ -687,6 +683,7 @@ void Gfx::go(GBool topLevel) {
   int numArgs, i;
   int errCount;
 
+  (void) topLevel;
   // scan a sequence of objects
   opCounter = 0;
   aborted = gFalse;
@@ -774,7 +771,7 @@ void Gfx::go(GBool topLevel) {
 
 // Returns true if successful, false on error.
 GBool Gfx::execOp(Object *cmd, Object args[], int numArgs) {
-  Operator *op;
+  const Operator *op;
   char *name;
   Object *argPtr;
   int i;
@@ -828,7 +825,7 @@ GBool Gfx::execOp(Object *cmd, Object args[], int numArgs) {
   return gTrue;
 }
 
-Operator *Gfx::findOp(char *name) {
+const Operator *Gfx::findOp(const char *name) {
   int a, b, m, cmp;
 
   a = -1;
@@ -874,14 +871,19 @@ GFileOffset Gfx::getPos() {
 //------------------------------------------------------------------------
 
 void Gfx::opSave(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   saveState();
 }
 
 void Gfx::opRestore(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   restoreState();
 }
 
 void Gfx::opConcat(Object args[], int numArgs) {
+  (void) numArgs;
   state->concatCTM(args[0].getNum(), args[1].getNum(),
 		   args[2].getNum(), args[3].getNum(),
 		   args[4].getNum(), args[5].getNum());
@@ -898,6 +900,7 @@ void Gfx::opSetDash(Object args[], int numArgs) {
   double *dash;
   int i;
 
+  (void) numArgs;
   a = args[0].getArray();
   length = a->getLength();
   if (length == 0) {
@@ -914,26 +917,31 @@ void Gfx::opSetDash(Object args[], int numArgs) {
 }
 
 void Gfx::opSetFlat(Object args[], int numArgs) {
+  (void) numArgs;
   state->setFlatness((int)args[0].getNum());
   out->updateFlatness(state);
 }
 
 void Gfx::opSetLineJoin(Object args[], int numArgs) {
+  (void) numArgs;
   state->setLineJoin(args[0].getInt());
   out->updateLineJoin(state);
 }
 
 void Gfx::opSetLineCap(Object args[], int numArgs) {
+  (void) numArgs;
   state->setLineCap(args[0].getInt());
   out->updateLineCap(state);
 }
 
 void Gfx::opSetMiterLimit(Object args[], int numArgs) {
+  (void) numArgs;
   state->setMiterLimit(args[0].getNum());
   out->updateMiterLimit(state);
 }
 
 void Gfx::opSetLineWidth(Object args[], int numArgs) {
+  (void) numArgs;
   state->setLineWidth(args[0].getNum());
   out->updateLineWidth(state);
 }
@@ -951,6 +959,7 @@ void Gfx::opSetExtGState(Object args[], int numArgs) {
   double opac;
   int i;
 
+  (void) numArgs;
   if (!res->lookupGState(args[0].getName(), &obj1)) {
     return;
   }
@@ -1290,6 +1299,7 @@ void Gfx::doSoftMask(Object *str, Object *strRef, GBool alpha,
 void Gfx::opSetRenderingIntent(Object args[], int numArgs) {
   GfxRenderingIntent ri;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring rendering intent setting in cached Type 3 character");
@@ -1320,6 +1330,7 @@ GfxRenderingIntent Gfx::parseRenderingIntent(const char *name) {
 void Gfx::opSetFillGray(Object args[], int numArgs) {
   GfxColor color;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1336,6 +1347,7 @@ void Gfx::opSetFillGray(Object args[], int numArgs) {
 void Gfx::opSetStrokeGray(Object args[], int numArgs) {
   GfxColor color;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1353,6 +1365,7 @@ void Gfx::opSetFillCMYKColor(Object args[], int numArgs) {
   GfxColor color;
   int i;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1372,6 +1385,7 @@ void Gfx::opSetStrokeCMYKColor(Object args[], int numArgs) {
   GfxColor color;
   int i;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1391,6 +1405,7 @@ void Gfx::opSetFillRGBColor(Object args[], int numArgs) {
   GfxColor color;
   int i;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1410,6 +1425,7 @@ void Gfx::opSetStrokeRGBColor(Object args[], int numArgs) {
   GfxColor color;
   int i;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color setting in cached Type 3 character");
@@ -1430,6 +1446,7 @@ void Gfx::opSetFillColorSpace(Object args[], int numArgs) {
   GfxColorSpace *colorSpace;
   GfxColor color;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color space setting in cached Type 3 character");
@@ -1461,6 +1478,7 @@ void Gfx::opSetStrokeColorSpace(Object args[], int numArgs) {
   GfxColorSpace *colorSpace;
   GfxColor color;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring color space setting in cached Type 3 character");
@@ -1640,10 +1658,12 @@ void Gfx::opSetStrokeColorN(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opMoveTo(Object args[], int numArgs) {
+  (void) numArgs;
   state->moveTo(args[0].getNum(), args[1].getNum());
 }
 
 void Gfx::opLineTo(Object args[], int numArgs) {
+  (void) numArgs;
   if (!state->isCurPt()) {
     error(errSyntaxError, getPos(), "No current point in lineto");
     return;
@@ -1654,6 +1674,7 @@ void Gfx::opLineTo(Object args[], int numArgs) {
 void Gfx::opCurveTo(Object args[], int numArgs) {
   double x1, y1, x2, y2, x3, y3;
 
+  (void) numArgs;
   if (!state->isCurPt()) {
     error(errSyntaxError, getPos(), "No current point in curveto");
     return;
@@ -1670,6 +1691,7 @@ void Gfx::opCurveTo(Object args[], int numArgs) {
 void Gfx::opCurveTo1(Object args[], int numArgs) {
   double x1, y1, x2, y2, x3, y3;
 
+  (void) numArgs;
   if (!state->isCurPt()) {
     error(errSyntaxError, getPos(), "No current point in curveto1");
     return;
@@ -1686,6 +1708,7 @@ void Gfx::opCurveTo1(Object args[], int numArgs) {
 void Gfx::opCurveTo2(Object args[], int numArgs) {
   double x1, y1, x2, y2, x3, y3;
 
+  (void) numArgs;
   if (!state->isCurPt()) {
     error(errSyntaxError, getPos(), "No current point in curveto2");
     return;
@@ -1702,6 +1725,7 @@ void Gfx::opCurveTo2(Object args[], int numArgs) {
 void Gfx::opRectangle(Object args[], int numArgs) {
   double x, y, w, h;
 
+  (void) numArgs;
   x = args[0].getNum();
   y = args[1].getNum();
   w = args[2].getNum();
@@ -1714,6 +1738,8 @@ void Gfx::opRectangle(Object args[], int numArgs) {
 }
 
 void Gfx::opClosePath(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     error(errSyntaxError, getPos(), "No current point in closepath");
     return;
@@ -1726,10 +1752,14 @@ void Gfx::opClosePath(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opEndPath(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   doEndPath();
 }
 
 void Gfx::opStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in stroke");
     return;
@@ -1747,6 +1777,8 @@ void Gfx::opStroke(Object args[], int numArgs) {
 }
 
 void Gfx::opCloseStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in closepath/stroke");
     return;
@@ -1765,6 +1797,8 @@ void Gfx::opCloseStroke(Object args[], int numArgs) {
 }
 
 void Gfx::opFill(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in fill");
     return;
@@ -1782,6 +1816,8 @@ void Gfx::opFill(Object args[], int numArgs) {
 }
 
 void Gfx::opEOFill(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in eofill");
     return;
@@ -1799,6 +1835,8 @@ void Gfx::opEOFill(Object args[], int numArgs) {
 }
 
 void Gfx::opFillStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in fill/stroke");
     return;
@@ -1821,6 +1859,8 @@ void Gfx::opFillStroke(Object args[], int numArgs) {
 }
 
 void Gfx::opCloseFillStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in closepath/fill/stroke");
     return;
@@ -1844,6 +1884,8 @@ void Gfx::opCloseFillStroke(Object args[], int numArgs) {
 }
 
 void Gfx::opEOFillStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in eofill/stroke");
     return;
@@ -1866,6 +1908,8 @@ void Gfx::opEOFillStroke(Object args[], int numArgs) {
 }
 
 void Gfx::opCloseEOFillStroke(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (!state->isCurPt()) {
     //error(errSyntaxError, getPos(), "No path in closepath/eofill/stroke");
     return;
@@ -2338,6 +2382,7 @@ void Gfx::opShFill(Object args[], int numArgs) {
   GfxState *savedState;
   double xMin, yMin, xMax, yMax;
 
+  (void) numArgs;
   if (state->getInCachedT3Char()) {
     error(errSyntaxWarning, getPos(),
 	  "Ignoring shaded fill in cached Type 3 character");
@@ -3543,10 +3588,14 @@ void Gfx::doEndPath() {
 //------------------------------------------------------------------------
 
 void Gfx::opClip(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   clip = clipNormal;
 }
 
 void Gfx::opEOClip(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   clip = clipEO;
 }
 
@@ -3555,6 +3604,8 @@ void Gfx::opEOClip(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opBeginText(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   state->setTextMat(1, 0, 0, 1, 0, 0);
   state->textMoveTo(0, 0);
   out->updateTextMat(state);
@@ -3563,6 +3614,8 @@ void Gfx::opBeginText(Object args[], int numArgs) {
 }
 
 void Gfx::opEndText(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   out->endTextObject(state);
 }
 
@@ -3571,11 +3624,13 @@ void Gfx::opEndText(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opSetCharSpacing(Object args[], int numArgs) {
+  (void) numArgs;
   state->setCharSpace(args[0].getNum());
   out->updateCharSpace(state);
 }
 
 void Gfx::opSetFont(Object args[], int numArgs) {
+  (void) numArgs;
   doSetFont(res->lookupFont(args[0].getName()), args[1].getNum());
 }
 
@@ -3596,25 +3651,30 @@ void Gfx::doSetFont(GfxFont *font, double size) {
 }
 
 void Gfx::opSetTextLeading(Object args[], int numArgs) {
+  (void) numArgs;
   state->setLeading(args[0].getNum());
 }
 
 void Gfx::opSetTextRender(Object args[], int numArgs) {
+  (void) numArgs;
   state->setRender(args[0].getInt());
   out->updateRender(state);
 }
 
 void Gfx::opSetTextRise(Object args[], int numArgs) {
+  (void) numArgs;
   state->setRise(args[0].getNum());
   out->updateRise(state);
 }
 
 void Gfx::opSetWordSpacing(Object args[], int numArgs) {
+  (void) numArgs;
   state->setWordSpace(args[0].getNum());
   out->updateWordSpace(state);
 }
 
 void Gfx::opSetHorizScaling(Object args[], int numArgs) {
+  (void) numArgs;
   state->setHorizScaling(args[0].getNum());
   out->updateHorizScaling(state);
   fontChanged = gTrue;
@@ -3627,6 +3687,7 @@ void Gfx::opSetHorizScaling(Object args[], int numArgs) {
 void Gfx::opTextMove(Object args[], int numArgs) {
   double tx, ty;
 
+  (void) numArgs;
   tx = state->getLineX() + args[0].getNum();
   ty = state->getLineY() + args[1].getNum();
   state->textMoveTo(tx, ty);
@@ -3636,6 +3697,7 @@ void Gfx::opTextMove(Object args[], int numArgs) {
 void Gfx::opTextMoveSet(Object args[], int numArgs) {
   double tx, ty;
 
+  (void) numArgs;
   tx = state->getLineX() + args[0].getNum();
   ty = args[1].getNum();
   state->setLeading(-ty);
@@ -3645,6 +3707,7 @@ void Gfx::opTextMoveSet(Object args[], int numArgs) {
 }
 
 void Gfx::opSetTextMatrix(Object args[], int numArgs) {
+  (void) numArgs;
   state->setTextMat(args[0].getNum(), args[1].getNum(),
 		    args[2].getNum(), args[3].getNum(),
 		    args[4].getNum(), args[5].getNum());
@@ -3657,6 +3720,8 @@ void Gfx::opSetTextMatrix(Object args[], int numArgs) {
 void Gfx::opTextNextLine(Object args[], int numArgs) {
   double tx, ty;
 
+  (void) args;
+  (void) numArgs;
   tx = state->getLineX();
   ty = state->getLineY() - state->getLeading();
   state->textMoveTo(tx, ty);
@@ -3668,6 +3733,7 @@ void Gfx::opTextNextLine(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opShowText(Object args[], int numArgs) {
+  (void) numArgs;
   if (!state->getFont()) {
     error(errSyntaxError, getPos(), "No font in show");
     return;
@@ -3688,6 +3754,7 @@ void Gfx::opShowText(Object args[], int numArgs) {
 void Gfx::opMoveShowText(Object args[], int numArgs) {
   double tx, ty;
 
+  (void) numArgs;
   if (!state->getFont()) {
     error(errSyntaxError, getPos(), "No font in move/show");
     return;
@@ -3712,6 +3779,7 @@ void Gfx::opMoveShowText(Object args[], int numArgs) {
 void Gfx::opMoveSetShowText(Object args[], int numArgs) {
   double tx, ty;
 
+  (void) numArgs;
   if (!state->getFont()) {
     error(errSyntaxError, getPos(), "No font in move/set/show");
     return;
@@ -3743,6 +3811,7 @@ void Gfx::opShowSpaceText(Object args[], int numArgs) {
   int wMode;
   int i;
 
+  (void) numArgs;
   if (!state->getFont()) {
     error(errSyntaxError, getPos(), "No font in show/space");
     return;
@@ -4041,10 +4110,11 @@ void Gfx::opXObject(Object args[], int numArgs) {
   char *name;
   Object obj1, obj2, obj3, refObj;
   GBool ocSaved, oc;
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   Object opiDict;
 #endif
 
+  (void) numArgs;
   if (!ocState && !out->needCharCount()) {
     return;
   }
@@ -4066,10 +4136,10 @@ void Gfx::opXObject(Object args[], int numArgs) {
   }
   obj2.free();
 
-#if USE_EXCEPTIONS
+#ifdef USE_EXCEPTIONS
   try {
 #endif
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
     obj1.streamGetDict()->lookup("OPI", &opiDict);
     if (opiDict.isDict()) {
       out->opiBegin(state, opiDict.getDict());
@@ -4106,13 +4176,13 @@ void Gfx::opXObject(Object args[], int numArgs) {
 	    "XObject subtype is missing or wrong type");
     }
     obj2.free();
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
     if (opiDict.isDict()) {
       out->opiEnd(state, opiDict.getDict());
     }
     opiDict.free();
 #endif
-#if USE_EXCEPTIONS
+#ifdef USE_EXCEPTIONS
   } catch (GMemException e) {
     obj1.free();
     throw;
@@ -4818,6 +4888,8 @@ void Gfx::opBeginImage(Object args[], int numArgs) {
   GBool haveLength;
   int c1, c2, c3;
 
+  (void) args;
+  (void) numArgs;
   // NB: this function is run even if ocState is false -- doImage() is
   // responsible for skipping over the inline image data
 
@@ -4919,10 +4991,14 @@ Stream *Gfx::buildImageStream(GBool *haveLength) {
 }
 
 void Gfx::opImageData(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   error(errInternal, getPos(), "Got 'ID' operator");
 }
 
 void Gfx::opEndImage(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   error(errInternal, getPos(), "Got 'EI' operator");
 }
 
@@ -4931,10 +5007,12 @@ void Gfx::opEndImage(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opSetCharWidth(Object args[], int numArgs) {
+  (void) numArgs;
   out->type3D0(state, args[0].getNum(), args[1].getNum());
 }
 
 void Gfx::opSetCacheDevice(Object args[], int numArgs) {
+  (void) numArgs;
   state->setInCachedT3Char(gTrue);
   out->type3D1(state, args[0].getNum(), args[1].getNum(),
 	       args[2].getNum(), args[3].getNum(),
@@ -4946,10 +5024,14 @@ void Gfx::opSetCacheDevice(Object args[], int numArgs) {
 //------------------------------------------------------------------------
 
 void Gfx::opBeginIgnoreUndef(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   ++ignoreUndef;
 }
 
 void Gfx::opEndIgnoreUndef(Object args[], int numArgs) {
+  (void) args;
+  (void) numArgs;
   if (ignoreUndef > 0)
     --ignoreUndef;
 }
@@ -4998,6 +5080,8 @@ void Gfx::opEndMarkedContent(Object args[], int numArgs) {
   GfxMarkedContent *mc;
   GfxMarkedContentKind mcKind;
 
+  (void) args;
+  (void) numArgs;
   if (markedContentStack->getLength() > 0) {
     mc = (GfxMarkedContent *)
              markedContentStack->del(markedContentStack->getLength() - 1);
diff --git a/xpdf/Gfx.h b/xpdf/Gfx.h
index 9d17582..46635e6 100644
--- a/xpdf/Gfx.h
+++ b/xpdf/Gfx.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "gfile.h"
 #include "GfxState.h"
@@ -210,12 +206,12 @@ private:
     (*abortCheckCbk)(void *data);
   void *abortCheckCbkData;
 
-  static Operator opTab[];	// table of operators
+  static Operator const opTab[];	// table of operators
 
   GBool checkForContentStreamLoop(Object *ref);
   void go(GBool topLevel);
   GBool execOp(Object *cmd, Object args[], int numArgs);
-  Operator *findOp(char *name);
+  const Operator *findOp(const char *name);
   GBool checkArg(Object *arg, TchkType type);
   GFileOffset getPos();
 
diff --git a/xpdf/GfxFont.cc b/xpdf/GfxFont.cc
index 640cf81..e4ca68b 100644
--- a/xpdf/GfxFont.cc
+++ b/xpdf/GfxFont.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -43,7 +39,7 @@ struct Base14FontMapEntry {
   const char *base14Name;
 };
 
-static Base14FontMapEntry base14FontMap[] = {
+static Base14FontMapEntry const base14FontMap[] = {
   { "Arial",                        "Helvetica" },
   { "Arial,Bold",                   "Helvetica-Bold" },
   { "Arial,BoldItalic",             "Helvetica-BoldOblique" },
@@ -115,7 +111,7 @@ static Base14FontMapEntry base14FontMap[] = {
 
 // index: {fixed:0, sans-serif:4, serif:8} + bold*2 + italic
 // NB: must be in same order as psSubstFonts in PSOutputDev.cc
-static const char *base14SubstFonts[14] = {
+static const char *const base14SubstFonts[14] = {
   "Courier",
   "Courier-Oblique",
   "Courier-Bold",
@@ -418,6 +414,7 @@ void GfxFont::readFontDescriptor(XRef *xref, Dict *fontDict) {
   double t, t2;
   int i;
 
+  (void) xref;
   // assume Times-Roman by default (for substitution purposes)
   flags = fontSerif;
 
@@ -869,7 +866,7 @@ Gfx8BitFont::Gfx8BitFont(XRef *xref, char *tagA, Ref idA, GString *nameA,
 {
   GString *name2;
   BuiltinFont *builtinFont;
-  const char **baseEnc;
+  const char *const *baseEnc;
   char *buf;
   int len;
   FoFiType1 *ffT1;
@@ -1055,7 +1052,7 @@ Gfx8BitFont::Gfx8BitFont(XRef *xref, char *tagA, Ref idA, GString *nameA,
 	  embFontName = new GString(ffT1->getName());
 	}
 	if (!baseEnc) {
-	  baseEnc = (const char **)ffT1->getEncoding();
+	  baseEnc = const_cast<const char **>(ffT1->getEncoding());
 	  baseEncFromFontFile = gTrue;
 	}
       }
@@ -1071,7 +1068,7 @@ Gfx8BitFont::Gfx8BitFont(XRef *xref, char *tagA, Ref idA, GString *nameA,
 	  embFontName = new GString(ffT1C->getName());
 	}
 	if (!baseEnc) {
-	  baseEnc = (const char **)ffT1C->getEncoding();
+	  baseEnc = const_cast<const char **>(ffT1C->getEncoding());
 	  baseEncFromFontFile = gTrue;
 	}
       }
@@ -1093,7 +1090,7 @@ Gfx8BitFont::Gfx8BitFont(XRef *xref, char *tagA, Ref idA, GString *nameA,
 
   // copy the base encoding
   for (i = 0; i < 256; ++i) {
-    enc[i] = (char *)baseEnc[i];
+    enc[i] = const_cast<char *>(baseEnc[i]);
     if ((encFree[i] = (char)baseEncFromFontFile) && enc[i]) {
       enc[i] = copyString(baseEnc[i]);
     }
@@ -1106,7 +1103,7 @@ Gfx8BitFont::Gfx8BitFont(XRef *xref, char *tagA, Ref idA, GString *nameA,
   if (type == fontType1C && embFontID.num >= 0 && baseEncFromFontFile) {
     for (i = 0; i < 256; ++i) {
       if (!enc[i] && standardEncoding[i]) {
-	enc[i] = (char *)standardEncoding[i];
+	enc[i] = const_cast<char *>(standardEncoding[i]);
 	encFree[i] = gFalse;
       }
     }
@@ -1378,6 +1375,7 @@ int Gfx8BitFont::getNextChar(char *s, int len, CharCode *code,
 			     double *dx, double *dy, double *ox, double *oy) {
   CharCode c;
 
+  (void) len;
   *code = c = (CharCode)(*s & 0xff);
   *uLen = ctu->mapToUnicode(c, u, uSize);
   *dx = widths[c];
diff --git a/xpdf/GfxFont.h b/xpdf/GfxFont.h
index b2d8637..2ab0cfb 100644
--- a/xpdf/GfxFont.h
+++ b/xpdf/GfxFont.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "GString.h"
 #include "Object.h"
@@ -288,7 +284,7 @@ public:
 
 private:
 
-  Base14FontMapEntry *base14;	// for Base-14 fonts only; NULL otherwise
+  const Base14FontMapEntry *base14;	// for Base-14 fonts only; NULL otherwise
   char *enc[256];		// char code --> char name
   char encFree[256];		// boolean for each char name: if set,
 				//   the string is malloc'ed
diff --git a/xpdf/GfxState.cc b/xpdf/GfxState.cc
index 9a43608..144546c 100644
--- a/xpdf/GfxState.cc
+++ b/xpdf/GfxState.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include <math.h>
 #include <string.h>
@@ -49,7 +45,7 @@ struct GfxBlendModeInfo {
   GfxBlendMode mode;
 };
 
-static GfxBlendModeInfo gfxBlendModeNames[] = {
+static GfxBlendModeInfo const gfxBlendModeNames[] = {
   { "Normal",     gfxBlendNormal },
   { "Compatible", gfxBlendNormal },
   { "Multiply",   gfxBlendMultiply },
@@ -76,7 +72,7 @@ static GfxBlendModeInfo gfxBlendModeNames[] = {
 
 // NB: This must match the GfxColorSpaceMode enum defined in
 // GfxState.h
-static const char *gfxColorSpaceModeNames[] = {
+static const char *const gfxColorSpaceModeNames[] = {
   "DeviceGray",
   "CalGray",
   "DeviceRGB",
@@ -185,6 +181,7 @@ void GfxColorSpace::getDefaultRanges(double *decodeLow, double *decodeRange,
 				     int maxImgPixel) {
   int i;
 
+  (void) maxImgPixel;
   for (i = 0; i < getNComps(); ++i) {
     decodeLow[i] = 0;
     decodeRange[i] = 1;
@@ -219,16 +216,19 @@ GfxColorSpace *GfxDeviceGrayColorSpace::copy() {
 
 void GfxDeviceGrayColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				      GfxRenderingIntent ri) {
+  (void) ri;
   *gray = clip01(color->c[0]);
 }
 
 void GfxDeviceGrayColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				     GfxRenderingIntent ri) {
+  (void) ri;
   rgb->r = rgb->g = rgb->b = clip01(color->c[0]);
 }
 
 void GfxDeviceGrayColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				      GfxRenderingIntent ri) {
+  (void) ri;
   cmyk->c = cmyk->m = cmyk->y = 0;
   cmyk->k = clip01(gfxColorComp1 - color->c[0]);
 }
@@ -271,6 +271,7 @@ GfxColorSpace *GfxCalGrayColorSpace::parse(Array *arr, int recursion) {
   GfxCalGrayColorSpace *cs;
   Object obj1, obj2, obj3;
 
+  (void) recursion;
   if (arr->getLength() < 2) {
     error(errSyntaxError, -1, "Bad CalGray color space");
     return NULL;
@@ -318,16 +319,19 @@ GfxColorSpace *GfxCalGrayColorSpace::parse(Array *arr, int recursion) {
 
 void GfxCalGrayColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				   GfxRenderingIntent ri) {
+  (void) ri;
   *gray = clip01(color->c[0]);
 }
 
 void GfxCalGrayColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				  GfxRenderingIntent ri) {
+  (void) ri;
   rgb->r = rgb->g = rgb->b = clip01(color->c[0]);
 }
 
 void GfxCalGrayColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				   GfxRenderingIntent ri) {
+  (void) ri;
   cmyk->c = cmyk->m = cmyk->y = 0;
   cmyk->k = clip01(gfxColorComp1 - color->c[0]);
 }
@@ -358,6 +362,7 @@ GfxColorSpace *GfxDeviceRGBColorSpace::copy() {
 
 void GfxDeviceRGBColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				     GfxRenderingIntent ri) {
+  (void) ri;
   *gray = clip01((GfxColorComp)(0.3  * color->c[0] +
 				0.59 * color->c[1] +
 				0.11 * color->c[2] + 0.5));
@@ -365,6 +370,7 @@ void GfxDeviceRGBColorSpace::getGray(GfxColor *color, GfxGray *gray,
 
 void GfxDeviceRGBColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				    GfxRenderingIntent ri) {
+  (void) ri;
   rgb->r = clip01(color->c[0]);
   rgb->g = clip01(color->c[1]);
   rgb->b = clip01(color->c[2]);
@@ -374,6 +380,7 @@ void GfxDeviceRGBColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				     GfxRenderingIntent ri) {
   GfxColorComp c, m, y, k;
 
+  (void) ri;
   c = clip01(gfxColorComp1 - color->c[0]);
   m = clip01(gfxColorComp1 - color->c[1]);
   y = clip01(gfxColorComp1 - color->c[2]);
@@ -439,6 +446,7 @@ GfxColorSpace *GfxCalRGBColorSpace::parse(Array *arr, int recursion) {
   Object obj1, obj2, obj3;
   int i;
 
+  (void) recursion;
   if (arr->getLength() < 2) {
     error(errSyntaxError, -1, "Bad CalRGB color space");
     return NULL;
@@ -505,6 +513,7 @@ GfxColorSpace *GfxCalRGBColorSpace::parse(Array *arr, int recursion) {
 
 void GfxCalRGBColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				  GfxRenderingIntent ri) {
+  (void) ri;
   *gray = clip01((GfxColorComp)(0.299 * color->c[0] +
 				0.587 * color->c[1] +
 				0.114 * color->c[2] + 0.5));
@@ -512,6 +521,7 @@ void GfxCalRGBColorSpace::getGray(GfxColor *color, GfxGray *gray,
 
 void GfxCalRGBColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				 GfxRenderingIntent ri) {
+  (void) ri;
   rgb->r = clip01(color->c[0]);
   rgb->g = clip01(color->c[1]);
   rgb->b = clip01(color->c[2]);
@@ -521,6 +531,7 @@ void GfxCalRGBColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				  GfxRenderingIntent ri) {
   GfxColorComp c, m, y, k;
 
+  (void) ri;
   c = clip01(gfxColorComp1 - color->c[0]);
   m = clip01(gfxColorComp1 - color->c[1]);
   y = clip01(gfxColorComp1 - color->c[2]);
@@ -565,6 +576,7 @@ GfxColorSpace *GfxDeviceCMYKColorSpace::copy() {
 
 void GfxDeviceCMYKColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				      GfxRenderingIntent ri) {
+  (void) ri;
   *gray = clip01((GfxColorComp)(gfxColorComp1 - color->c[3]
 				- 0.3  * color->c[0]
 				- 0.59 * color->c[1]
@@ -575,6 +587,7 @@ void GfxDeviceCMYKColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				     GfxRenderingIntent ri) {
   double c, m, y, k, c1, m1, y1, k1, r, g, b, x;
 
+  (void) ri;
   c = colToDbl(color->c[0]);
   m = colToDbl(color->c[1]);
   y = colToDbl(color->c[2]);
@@ -636,6 +649,7 @@ void GfxDeviceCMYKColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 
 void GfxDeviceCMYKColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				      GfxRenderingIntent ri) {
+  (void) ri;
   cmyk->c = clip01(color->c[0]);
   cmyk->m = clip01(color->c[1]);
   cmyk->y = clip01(color->c[2]);
@@ -658,7 +672,7 @@ void GfxDeviceCMYKColorSpace::getDefaultColor(GfxColor *color) {
 
 // This is the inverse of MatrixLMN in Example 4.10 from the PostScript
 // Language Reference, Third Edition.
-static double xyzrgb[3][3] = {
+static double const xyzrgb[3][3] = {
   {  3.240449, -1.537136, -0.498531 },
   { -0.969265,  1.876011,  0.041556 },
   {  0.055643, -0.204026,  1.057229 }
@@ -698,6 +712,7 @@ GfxColorSpace *GfxLabColorSpace::parse(Array *arr, int recursion) {
   GfxLabColorSpace *cs;
   Object obj1, obj2, obj3;
 
+  (void) recursion;
   if (arr->getLength() < 2) {
     error(errSyntaxError, -1, "Bad Lab color space");
     return NULL;
@@ -783,7 +798,7 @@ void GfxLabColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
   double t1, t2;
   double r, g, b;
 
-
+  (void) ri;
   // convert L*a*b* to CIE 1931 XYZ color space
   t1 = (colToDbl(color->c[0]) + 16) / 116;
   t2 = t1 + colToDbl(color->c[1]) / 500;
@@ -861,6 +876,7 @@ void GfxLabColorSpace::getDefaultColor(GfxColor *color) {
 
 void GfxLabColorSpace::getDefaultRanges(double *decodeLow, double *decodeRange,
 					int maxImgPixel) {
+  (void) maxImgPixel;
   decodeLow[0] = 0;
   decodeRange[0] = 100;
   decodeLow[1] = aMin;
@@ -1611,16 +1627,22 @@ GfxColorSpace *GfxPatternColorSpace::parse(Array *arr,
 
 void GfxPatternColorSpace::getGray(GfxColor *color, GfxGray *gray,
 				   GfxRenderingIntent ri) {
+  (void) color;
+  (void) ri;
   *gray = 0;
 }
 
 void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb,
 				  GfxRenderingIntent ri) {
+  (void) color;
+  (void) ri;
   rgb->r = rgb->g = rgb->b = 0;
 }
 
 void GfxPatternColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 				   GfxRenderingIntent ri) {
+  (void) color;
+  (void) ri;
   cmyk->c = cmyk->m = cmyk->y = 0;
   cmyk->k = 1;
 }
@@ -1628,6 +1650,7 @@ void GfxPatternColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk,
 
 
 void GfxPatternColorSpace::getDefaultColor(GfxColor *color) {
+  (void) color;
   // not used
 }
 
diff --git a/xpdf/GfxState.h b/xpdf/GfxState.h
index 8e5d3b0..2a7ad2e 100644
--- a/xpdf/GfxState.h
+++ b/xpdf/GfxState.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 #include "Function.h"
diff --git a/xpdf/GlobalParams.cc b/xpdf/GlobalParams.cc
index e40558e..91ac091 100644
--- a/xpdf/GlobalParams.cc
+++ b/xpdf/GlobalParams.cc
@@ -8,17 +8,13 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include <stdio.h>
 #include <ctype.h>
 #ifdef _WIN32
-#  include <shlobj.h>
+#include <shlobj.h>
 #endif
-#if HAVE_PAPER_H
+#ifdef HAVE_PAPER_H
 #include <paper.h>
 #endif
 #include "gmem.h"
@@ -43,7 +39,7 @@
 #  define strncasecmp strnicmp
 #endif
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #  define lockGlobalParams            gLockMutex(&mutex)
 #  define lockUnicodeMapCache         gLockMutex(&unicodeMapCacheMutex)
 #  define lockCMapCache               gLockMutex(&cMapCacheMutex)
@@ -70,6 +66,12 @@
 
 //------------------------------------------------------------------------
 
+#ifdef USE_PRIVATE_FONTDIR
+#define PRIVATE_FONTDIR "fonts\\"
+#else
+#define PRIVATE_FONTDIR ""
+#endif
+
 static struct {
   const char *name;
   const char *t1FileName;
@@ -78,32 +80,33 @@ static struct {
   const char *macFontName;	// font name inside .dfont or .ttc
   const char *obliqueFont;	// name of font to oblique
   double obliqueFactor;		// oblique sheer factor
-} displayFontTab[] = {
-  {"Courier",               "n022003l.pfb", "cour.ttf",    "Courier",      "Courier",                NULL,             0},
-  {"Courier-Bold",          "n022004l.pfb", "courbd.ttf",  "Courier",      "Courier Bold",           NULL,             0},
-  {"Courier-BoldOblique",   "n022024l.pfb", "courbi.ttf",  "Courier",      "Courier Bold Oblique",   "Courier-Bold",   0.212557},
-  {"Courier-Oblique",       "n022023l.pfb", "couri.ttf",   "Courier",      "Courier Oblique",        "Courier",        0.212557},
-  {"Helvetica",             "n019003l.pfb", "arial.ttf",   "Helvetica",    "Helvetica",              NULL,             0},
-  {"Helvetica-Bold",        "n019004l.pfb", "arialbd.ttf", "Helvetica",    "Helvetica-Bold",         NULL,             0},
-  {"Helvetica-BoldOblique", "n019024l.pfb", "arialbi.ttf", "Helvetica",    "Helvetica Bold Oblique", "Helvetica-Bold", 0.212557},
-  {"Helvetica-Oblique",     "n019023l.pfb", "ariali.ttf",  "Helvetica",    "Helvetica Oblique",      "Helvetica",      0.212557},
-  {"Symbol",                "s050000l.pfb", NULL,          "Symbol",       "Symbol",                 NULL,             0},
-  {"Times-Bold",            "n021004l.pfb", "timesbd.ttf", "Times",        "Times-Bold",             NULL,             0},
-  {"Times-BoldItalic",      "n021024l.pfb", "timesbi.ttf", "Times",        "Times-BoldItalic",       NULL,             0},
-  {"Times-Italic",          "n021023l.pfb", "timesi.ttf",  "Times",        "Times-Italic",           NULL,             0},
-  {"Times-Roman",           "n021003l.pfb", "times.ttf",   "Times",        "Times-Roman",            NULL,             0},
-  {"ZapfDingbats",          "d050000l.pfb", NULL,          "ZapfDingbats", "Zapf Dingbats",          NULL,             0},
-  {NULL}
+} const displayFontTab[] = {
+  {"Courier",               PRIVATE_FONTDIR "n022003l.pfb", "cour.ttf",    "Courier",      "Courier",                NULL,             0},
+  {"Courier-Bold",          PRIVATE_FONTDIR "n022004l.pfb", "courbd.ttf",  "Courier",      "Courier Bold",           NULL,             0},
+  {"Courier-BoldOblique",   PRIVATE_FONTDIR "n022024l.pfb", "courbi.ttf",  "Courier",      "Courier Bold Oblique",   "Courier-Bold",   0.212557},
+  {"Courier-Oblique",       PRIVATE_FONTDIR "n022023l.pfb", "couri.ttf",   "Courier",      "Courier Oblique",        "Courier",        0.212557},
+  {"Helvetica",             PRIVATE_FONTDIR "n019003l.pfb", "arial.ttf",   "Helvetica",    "Helvetica",              NULL,             0},
+  {"Helvetica-Bold",        PRIVATE_FONTDIR "n019004l.pfb", "arialbd.ttf", "Helvetica",    "Helvetica-Bold",         NULL,             0},
+  {"Helvetica-BoldOblique", PRIVATE_FONTDIR "n019024l.pfb", "arialbi.ttf", "Helvetica",    "Helvetica Bold Oblique", "Helvetica-Bold", 0.212557},
+  {"Helvetica-Oblique",     PRIVATE_FONTDIR "n019023l.pfb", "ariali.ttf",  "Helvetica",    "Helvetica Oblique",      "Helvetica",      0.212557},
+  {"Symbol",                PRIVATE_FONTDIR "s050000l.pfb", NULL,          "Symbol",       "Symbol",                 NULL,             0},
+  {"Times-Bold",            PRIVATE_FONTDIR "n021004l.pfb", "timesbd.ttf", "Times",        "Times-Bold",             NULL,             0},
+  {"Times-BoldItalic",      PRIVATE_FONTDIR "n021024l.pfb", "timesbi.ttf", "Times",        "Times-BoldItalic",       NULL,             0},
+  {"Times-Italic",          PRIVATE_FONTDIR "n021023l.pfb", "timesi.ttf",  "Times",        "Times-Italic",           NULL,             0},
+  {"Times-Roman",           PRIVATE_FONTDIR "n021003l.pfb", "times.ttf",   "Times",        "Times-Roman",            NULL,             0},
+  {"ZapfDingbats",          PRIVATE_FONTDIR "d050000l.pfb", NULL,          "ZapfDingbats", "Zapf Dingbats",          NULL,             0},
+  {NULL, 0, 0, 0, 0, 0, 0}
 };
 
 #ifdef _WIN32
-static const char *displayFontDirs[] = {
+static const char *const displayFontDirs[] = {
   "c:/windows/fonts",
   "c:/winnt/fonts",
   NULL
 };
 #else
-static const char *displayFontDirs[] = {
+static const char *const displayFontDirs[] = {
+#ifndef USE_PRIVATE_FONTDIR
   "/usr/share/ghostscript/fonts",
   "/usr/local/share/ghostscript/fonts",
   "/usr/share/fonts/default/Type1",
@@ -111,6 +114,7 @@ static const char *displayFontDirs[] = {
   "/usr/share/fonts/type1/gsfonts",
 #if defined(__sun) && defined(__SVR4)
   "/usr/sfw/share/ghostscript/fonts",
+#endif
 #endif
   NULL
 };
@@ -515,7 +519,7 @@ GlobalParams::GlobalParams(const char *cfgFileName) {
   FILE *f;
   int i;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gInitMutex(&mutex);
   gInitMutex(&unicodeMapCacheMutex);
   gInitMutex(&cMapCacheMutex);
@@ -555,7 +559,7 @@ GlobalParams::GlobalParams(const char *cfgFileName) {
   ccFontFiles = new GHash(gTrue);
   base14SysFonts = new GHash(gTrue);
   sysFonts = new SysFontList();
-#if HAVE_PAPER_H
+#ifdef HAVE_PAPER_H
   char *paperName;
   const struct paper *paperType;
   paperinit();
@@ -1566,6 +1570,7 @@ GBool GlobalParams::parseKey(GString *modKeyStr, GString *contextStr,
   char *p0;
   int btn;
 
+  (void) tokens;
   *mods = xpdfKeyModNone;
   p0 = modKeyStr->getCString();
   while (1) {
@@ -1887,7 +1892,7 @@ GlobalParams::~GlobalParams() {
   delete unicodeMapCache;
   delete cMapCache;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gDestroyMutex(&mutex);
   gDestroyMutex(&unicodeMapCacheMutex);
   gDestroyMutex(&cMapCacheMutex);
@@ -2204,7 +2209,7 @@ UnicodeRemapping *GlobalParams::getUnicodeRemapping() {
 }
 
 GString *GlobalParams::findFontFile(GString *fontName) {
-  static const char *exts[] = { ".pfa", ".pfb", ".ttf", ".ttc", ".otf" };
+  static const char *const exts[] = { ".pfa", ".pfb", ".ttf", ".ttc", ".otf" };
   GString *path, *dir;
 #ifdef _WIN32
   GString *fontNameU;
diff --git a/xpdf/GlobalParams.h b/xpdf/GlobalParams.h
index 12c24b0..0bb2805 100644
--- a/xpdf/GlobalParams.h
+++ b/xpdf/GlobalParams.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #ifdef _WIN32
 #  include <windows.h>
@@ -22,7 +18,7 @@
 #include "gtypes.h"
 #include "CharTypes.h"
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -554,7 +550,7 @@ private:
   UnicodeMapCache *unicodeMapCache;
   CMapCache *cMapCache;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GMutex mutex;
   GMutex unicodeMapCacheMutex;
   GMutex cMapCacheMutex;
diff --git a/xpdf/HTMLGen.cc b/xpdf/HTMLGen.cc
index d6cbc24..cd5eff4 100644
--- a/xpdf/HTMLGen.cc
+++ b/xpdf/HTMLGen.cc
@@ -22,10 +22,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <png.h>
 #include "gmem.h"
@@ -55,7 +51,7 @@ struct FontStyleTagInfo {
 
 // NB: these are compared, in order, against the tail of the font
 // name, so "BoldItalic" must come before "Italic", etc.
-static FontStyleTagInfo fontStyleTags[] = {
+static FontStyleTagInfo const fontStyleTags[] = {
   {"Roman",                    5, gFalse, gFalse},
   {"Regular",                  7, gFalse, gFalse},
   {"Condensed",                9, gFalse, gFalse},
@@ -79,7 +75,7 @@ struct StandardFontInfo {
   GBool serif;
 };
 
-static StandardFontInfo standardFonts[] = {
+static StandardFontInfo const standardFonts[] = {
   {"Arial",                    gFalse, gFalse},
   {"Courier",                  gTrue,  gFalse},
   {"Futura",                   gFalse, gFalse},
@@ -99,7 +95,7 @@ struct SubstFontInfo {
 };
 
 // index: {fixed:8, serif:4, sans-serif:0} + bold*2 + italic
-static SubstFontInfo substFonts[16] = {
+static SubstFontInfo const substFonts[16] = {
   {0.833},
   {0.833},
   {0.889},
@@ -118,7 +114,7 @@ static SubstFontInfo substFonts[16] = {
 // Glyph list.
 #define privateUnicodeMapStart 0xf6f9
 #define privateUnicodeMapEnd   0xf7ff
-static int
+static int const
 privateUnicodeMap[privateUnicodeMapEnd - privateUnicodeMapStart + 1] = {
   0x0141, 0x0152, 0,      0,      0x0160, 0,      0x017d,         // f6f9
   0,      0,      0,      0,      0,      0,      0,      0,      // f700
@@ -162,7 +158,7 @@ enum VerticalAlignment {
   vertAlignTop
 };
 
-static const char *vertAlignNames[] = {
+static const char *const vertAlignNames[] = {
   "baseline",
   "sub",
   "super",
@@ -595,8 +591,8 @@ void HTMLGen::appendUTF8(Unicode u, GString *s) {
 GString *HTMLGen::getFontDefn(TextFontInfo *font, double *scale) {
   GString *fontName;
   char *fontName2;
-  FontStyleTagInfo *fst;
-  StandardFontInfo *sf;
+  const FontStyleTagInfo *fst;
+  const StandardFontInfo *sf;
   GBool fixedWidth, serif, bold, italic;
   double s;
   int n, i;
diff --git a/xpdf/HTMLGen.h b/xpdf/HTMLGen.h
index e870d8e..9838ec9 100644
--- a/xpdf/HTMLGen.h
+++ b/xpdf/HTMLGen.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 class GString;
 class PDFDoc;
 class TextOutputDev;
diff --git a/xpdf/ImageOutputDev.cc b/xpdf/ImageOutputDev.cc
index 1fb32be..2f3236e 100644
--- a/xpdf/ImageOutputDev.cc
+++ b/xpdf/ImageOutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -44,6 +40,7 @@ ImageOutputDev::~ImageOutputDev() {
 }
 
 void ImageOutputDev::startPage(int pageNum, GfxState *state) {
+  (void) state;
   curPageNum = pageNum;
 }
 
@@ -54,6 +51,20 @@ void ImageOutputDev::tilingPatternFill(GfxState *state, Gfx *gfx,
 				       double *mat, double *bbox,
 				       int x0, int y0, int x1, int y1,
 				       double xStep, double yStep) {
+  (void) state;
+  (void) gfx;
+  (void) strRef;
+  (void) paintType;
+  (void) tilingType;
+  (void) resDict;
+  (void) mat;
+  (void) bbox;
+  (void) x0;
+  (void) x1;
+  (void) y0;
+  (void) y1;
+  (void) xStep;
+  (void) yStep;
   // do nothing -- this avoids the potentially slow loop in Gfx.cc
 }
 
@@ -64,6 +75,9 @@ void ImageOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
   char buf[4096];
   int size, n, i;
 
+  (void) ref;
+  (void) invert;
+  (void) interpolate;
   // dump raw file
   if (dumpRaw && !inlineImg) {
 
@@ -163,6 +177,9 @@ void ImageOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
   char buf[4096];
   int size, n, i, j;
 
+  (void) ref;
+  (void) maskColors;
+  (void) interpolate;
   csMode = colorMap->getColorSpace()->getMode();
   if (csMode == csIndexed) {
     csMode = ((GfxIndexedColorSpace *)colorMap->getColorSpace())
@@ -367,6 +384,7 @@ void ImageOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
 					 int maskWidth, int maskHeight,
 					 GfxImageColorMap *maskColorMap,
 					 double *matte, GBool interpolate) {
+  (void) matte;
   drawImage(state, ref, str, width, height, colorMap,
 	    NULL, gFalse, interpolate);
   drawImage(state, ref, maskStr, maskWidth, maskHeight, maskColorMap,
diff --git a/xpdf/ImageOutputDev.h b/xpdf/ImageOutputDev.h
index 3cdae45..e426659 100644
--- a/xpdf/ImageOutputDev.h
+++ b/xpdf/ImageOutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #include "gtypes.h"
 #include "OutputDev.h"
diff --git a/xpdf/JArithmeticDecoder.cc b/xpdf/JArithmeticDecoder.cc
index 3d10cb4..5f00967 100644
--- a/xpdf/JArithmeticDecoder.cc
+++ b/xpdf/JArithmeticDecoder.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "Object.h"
 #include "Stream.h"
@@ -55,7 +51,7 @@ void JArithmeticDecoderStats::setEntry(Guint cx, int i, int mps) {
 // JArithmeticDecoder
 //------------------------------------------------------------------------
 
-Guint JArithmeticDecoder::qeTab[47] = {
+Guint const JArithmeticDecoder::qeTab[47] = {
   0x56010000, 0x34010000, 0x18010000, 0x0AC10000,
   0x05210000, 0x02210000, 0x56010000, 0x54010000,
   0x48010000, 0x38010000, 0x30010000, 0x24010000,
@@ -70,19 +66,19 @@ Guint JArithmeticDecoder::qeTab[47] = {
   0x00050000, 0x00010000, 0x56010000
 };
 
-int JArithmeticDecoder::nmpsTab[47] = {
+int const JArithmeticDecoder::nmpsTab[47] = {
    1,  2,  3,  4,  5, 38,  7,  8,  9, 10, 11, 12, 13, 29, 15, 16,
   17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
   33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 45, 46
 };
 
-int JArithmeticDecoder::nlpsTab[47] = {
+int const JArithmeticDecoder::nlpsTab[47] = {
    1,  6,  9, 12, 29, 33,  6, 14, 14, 14, 17, 18, 20, 21, 14, 14,
   15, 16, 17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46
 };
 
-int JArithmeticDecoder::switchTab[47] = {
+int const JArithmeticDecoder::switchTab[47] = {
   1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
diff --git a/xpdf/JArithmeticDecoder.h b/xpdf/JArithmeticDecoder.h
index c0f773f..12c5faa 100644
--- a/xpdf/JArithmeticDecoder.h
+++ b/xpdf/JArithmeticDecoder.h
@@ -13,10 +13,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 class Stream;
@@ -93,10 +89,10 @@ private:
   int decodeIntBit(JArithmeticDecoderStats *stats);
   void byteIn();
 
-  static Guint qeTab[47];
-  static int nmpsTab[47];
-  static int nlpsTab[47];
-  static int switchTab[47];
+  static Guint const qeTab[47];
+  static int const nmpsTab[47];
+  static int const nlpsTab[47];
+  static int const switchTab[47];
 
   Guint buf0, buf1;
   Guint c, a;
diff --git a/xpdf/JBIG2Stream.cc b/xpdf/JBIG2Stream.cc
index d3c9b6f..062e370 100644
--- a/xpdf/JBIG2Stream.cc
+++ b/xpdf/JBIG2Stream.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <limits.h>
 #include "gmempp.h"
@@ -25,8 +21,8 @@
 
 //------------------------------------------------------------------------
 
-static int contextSize[4] = { 16, 13, 10, 10 };
-static int refContextSize[2] = { 13, 10 };
+static int const contextSize[4] = { 16, 13, 10, 10 };
+static int const refContextSize[2] = { 13, 10 };
 
 //------------------------------------------------------------------------
 // JBIG2HuffmanTable
@@ -43,7 +39,7 @@ struct JBIG2HuffmanTable {
   Guint prefix;
 };
 
-JBIG2HuffmanTable huffTableA[] = {
+static JBIG2HuffmanTable const huffTableA[] = {
   {     0, 1,  4,              0x000 },
   {    16, 2,  8,              0x002 },
   {   272, 3, 16,              0x006 },
@@ -51,7 +47,7 @@ JBIG2HuffmanTable huffTableA[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableB[] = {
+static JBIG2HuffmanTable const huffTableB[] = {
   {     0, 1,  0,              0x000 },
   {     1, 2,  0,              0x002 },
   {     2, 3,  0,              0x006 },
@@ -62,7 +58,7 @@ JBIG2HuffmanTable huffTableB[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableC[] = {
+static JBIG2HuffmanTable const huffTableC[] = {
   {     0, 1,  0,              0x000 },
   {     1, 2,  0,              0x002 },
   {     2, 3,  0,              0x006 },
@@ -75,7 +71,7 @@ JBIG2HuffmanTable huffTableC[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableD[] = {
+static JBIG2HuffmanTable const huffTableD[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  0,              0x006 },
@@ -85,7 +81,7 @@ JBIG2HuffmanTable huffTableD[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableE[] = {
+static JBIG2HuffmanTable const huffTableE[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  0,              0x006 },
@@ -97,7 +93,7 @@ JBIG2HuffmanTable huffTableE[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableF[] = {
+static JBIG2HuffmanTable const huffTableF[] = {
   {     0, 2,  7,              0x000 },
   {   128, 3,  7,              0x002 },
   {   256, 3,  8,              0x003 },
@@ -115,7 +111,7 @@ JBIG2HuffmanTable huffTableF[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableG[] = {
+static JBIG2HuffmanTable const huffTableG[] = {
   {  -512, 3,  8,              0x000 },
   {   256, 3,  8,              0x001 },
   {   512, 3,  9,              0x002 },
@@ -134,7 +130,7 @@ JBIG2HuffmanTable huffTableG[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableH[] = {
+static JBIG2HuffmanTable const huffTableH[] = {
   {     0, 2,  1,              0x000 },
   {     0, 2, jbig2HuffmanOOB, 0x001 },
   {     4, 3,  4,              0x004 },
@@ -159,7 +155,7 @@ JBIG2HuffmanTable huffTableH[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableI[] = {
+static JBIG2HuffmanTable const huffTableI[] = {
   {     0, 2, jbig2HuffmanOOB, 0x000 },
   {    -1, 3,  1,              0x002 },
   {     1, 3,  1,              0x003 },
@@ -185,7 +181,7 @@ JBIG2HuffmanTable huffTableI[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableJ[] = {
+static JBIG2HuffmanTable const huffTableJ[] = {
   {    -2, 2,  2,              0x000 },
   {     6, 2,  6,              0x001 },
   {     0, 2, jbig2HuffmanOOB, 0x002 },
@@ -210,7 +206,7 @@ JBIG2HuffmanTable huffTableJ[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableK[] = {
+static JBIG2HuffmanTable const huffTableK[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  1,              0x002 },
   {     4, 4,  0,              0x00c },
@@ -227,7 +223,7 @@ JBIG2HuffmanTable huffTableK[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableL[] = {
+static JBIG2HuffmanTable const huffTableL[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  1,              0x006 },
@@ -244,7 +240,7 @@ JBIG2HuffmanTable huffTableL[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableM[] = {
+static JBIG2HuffmanTable const huffTableM[] = {
   {     1, 1,  0,              0x000 },
   {     2, 3,  0,              0x004 },
   {     7, 3,  3,              0x005 },
@@ -261,7 +257,7 @@ JBIG2HuffmanTable huffTableM[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableN[] = {
+static JBIG2HuffmanTable const huffTableN[] = {
   {     0, 1,  0,              0x000 },
   {    -2, 3,  0,              0x004 },
   {    -1, 3,  0,              0x005 },
@@ -270,7 +266,7 @@ JBIG2HuffmanTable huffTableN[] = {
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableO[] = {
+static JBIG2HuffmanTable const huffTableO[] = {
   {     0, 1,  0,              0x000 },
   {    -1, 3,  0,              0x004 },
   {     1, 3,  0,              0x005 },
@@ -301,7 +297,7 @@ public:
   void reset();
 
   // Returns false for OOB, otherwise sets *<x> and returns true.
-  GBool decodeInt(int *x, JBIG2HuffmanTable *table);
+  GBool decodeInt(int *x, const JBIG2HuffmanTable *table);
 
   Guint readBits(Guint n);
   Guint readBit();
@@ -335,7 +331,7 @@ void JBIG2HuffmanDecoder::reset() {
 }
 
 //~ optimize this
-GBool JBIG2HuffmanDecoder::decodeInt(int *x, JBIG2HuffmanTable *table) {
+GBool JBIG2HuffmanDecoder::decodeInt(int *x, const JBIG2HuffmanTable *table) {
   Guint i, len, prefix;
 
   i = 0;
@@ -486,7 +482,7 @@ void JBIG2MMRDecoder::reset() {
 }
 
 int JBIG2MMRDecoder::get2DCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
 
   if (bufLen == 0) {
     buf = str->getChar() & 0xff;
@@ -516,7 +512,7 @@ int JBIG2MMRDecoder::get2DCode() {
 }
 
 int JBIG2MMRDecoder::getWhiteCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
   Guint code;
 
   if (bufLen == 0) {
@@ -561,7 +557,7 @@ int JBIG2MMRDecoder::getWhiteCode() {
 }
 
 int JBIG2MMRDecoder::getBlackCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
   Guint code;
 
   if (bufLen == 0) {
@@ -1281,10 +1277,13 @@ int JBIG2Stream::getBlock(char *blk, int size) {
 }
 
 GString *JBIG2Stream::getPSFilter(int psLevel, const char *indent) {
+  (void) psLevel;
+  (void) indent;
   return NULL;
 }
 
 GBool JBIG2Stream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -1488,10 +1487,10 @@ void JBIG2Stream::readSegments() {
 }
 
 GBool JBIG2Stream::readSymbolDictSeg(Guint segNum, Guint length,
-				     Guint *refSegs, Guint nRefSegs) {
+				     const Guint *refSegs, Guint nRefSegs) {
   JBIG2SymbolDict *symbolDict;
-  JBIG2HuffmanTable *huffDHTable, *huffDWTable;
-  JBIG2HuffmanTable *huffBMSizeTable, *huffAggInstTable;
+  const JBIG2HuffmanTable *huffDHTable, *huffDWTable;
+  const JBIG2HuffmanTable *huffBMSizeTable, *huffAggInstTable;
   JBIG2Segment *seg;
   GList *codeTables;
   JBIG2SymbolDict *inputSymbolDict;
@@ -1509,6 +1508,7 @@ GBool JBIG2Stream::readSymbolDictSeg(Guint segNum, Guint length,
   int run, cnt;
   Guint i, j, k;
 
+  (void) length;
   symWidths = NULL;
 
   // symbol dictionary flags
@@ -1925,13 +1925,13 @@ GBool JBIG2Stream::readSymbolDictSeg(Guint segNum, Guint length,
 
 void JBIG2Stream::readTextRegionSeg(Guint segNum, GBool imm,
 				    GBool lossless, Guint length,
-				    Guint *refSegs, Guint nRefSegs) {
+				    const Guint *refSegs, Guint nRefSegs) {
   JBIG2Bitmap *bitmap;
   JBIG2HuffmanTable runLengthTab[36];
   JBIG2HuffmanTable *symCodeTab;
-  JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable;
-  JBIG2HuffmanTable *huffRDWTable, *huffRDHTable;
-  JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable;
+  const JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable;
+  const JBIG2HuffmanTable *huffRDWTable, *huffRDHTable;
+  const JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable;
   JBIG2Segment *seg;
   GList *codeTables;
   JBIG2SymbolDict *symbolDict;
@@ -1947,6 +1947,8 @@ void JBIG2Stream::readTextRegionSeg(Guint segNum, GBool imm,
   Guint i, k, kk;
   int j;
 
+  (void) lossless;
+  (void) length;
   // region segment info field
   if (!readULong(&w) || !readULong(&h) ||
       !readULong(&x) || !readULong(&y) ||
@@ -2246,14 +2248,14 @@ JBIG2Bitmap *JBIG2Stream::readTextRegion(GBool huff, GBool refine,
 					 Guint defPixel, Guint combOp,
 					 Guint transposed, Guint refCorner,
 					 int sOffset,
-					 JBIG2HuffmanTable *huffFSTable,
-					 JBIG2HuffmanTable *huffDSTable,
-					 JBIG2HuffmanTable *huffDTTable,
-					 JBIG2HuffmanTable *huffRDWTable,
-					 JBIG2HuffmanTable *huffRDHTable,
-					 JBIG2HuffmanTable *huffRDXTable,
-					 JBIG2HuffmanTable *huffRDYTable,
-					 JBIG2HuffmanTable *huffRSizeTable,
+					 const JBIG2HuffmanTable *huffFSTable,
+					 const JBIG2HuffmanTable *huffDSTable,
+					 const JBIG2HuffmanTable *huffDTTable,
+					 const JBIG2HuffmanTable *huffRDWTable,
+					 const JBIG2HuffmanTable *huffRDHTable,
+					 const JBIG2HuffmanTable *huffRDXTable,
+					 const JBIG2HuffmanTable *huffRDYTable,
+					 const JBIG2HuffmanTable *huffRSizeTable,
 					 Guint templ,
 					 int *atx, int *aty) {
   JBIG2Bitmap *bitmap;
@@ -2520,6 +2522,8 @@ void JBIG2Stream::readHalftoneRegionSeg(Guint segNum, GBool imm,
   int gridX, gridY, xx, yy, bit, j;
   Guint bpp, m, n, i;
 
+  (void) length;
+  (void) lossless;
   // region segment info field
   if (!readULong(&w) || !readULong(&h) ||
       !readULong(&x) || !readULong(&y) ||
@@ -2678,6 +2682,7 @@ void JBIG2Stream::readGenericRegionSeg(Guint segNum, GBool imm,
   Guint flags, mmr, templ, tpgdOn;
   int atx[4], aty[4];
 
+  (void) lossless;
   // region segment info field
   if (!readULong(&w) || !readULong(&h) ||
       !readULong(&x) || !readULong(&y) ||
@@ -3581,6 +3586,8 @@ void JBIG2Stream::readGenericRefinementRegionSeg(Guint segNum, GBool imm,
   int atx[2], aty[2];
   JBIG2Segment *seg;
 
+  (void) lossless;
+  (void) length;
   // region segment info field
   if (!readULong(&w) || !readULong(&h) ||
       !readULong(&x) || !readULong(&y) ||
@@ -3847,6 +3854,7 @@ JBIG2Bitmap *JBIG2Stream::readGenericRefinementRegion(int w, int h,
 void JBIG2Stream::readPageInfoSeg(Guint length) {
   Guint xRes, yRes, flags, striping;
 
+  (void) length;
   if (!readULong(&pageW) || !readULong(&pageH) ||
       !readULong(&xRes) || !readULong(&yRes) ||
       !readUByte(&flags) || !readUWord(&striping)) {
@@ -3896,6 +3904,7 @@ void JBIG2Stream::readCodeTableSeg(Guint segNum, Guint length) {
   int lowVal, highVal, val;
   Guint huffTabSize, i;
 
+  (void) length;
   if (!readUByte(&flags) || !readLong(&lowVal) || !readLong(&highVal)) {
     goto eofError;
   }
diff --git a/xpdf/JBIG2Stream.h b/xpdf/JBIG2Stream.h
index 17181d7..62cbc02 100644
--- a/xpdf/JBIG2Stream.h
+++ b/xpdf/JBIG2Stream.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 #include "Stream.h"
@@ -49,10 +45,10 @@ private:
 
   void readSegments();
   GBool readSymbolDictSeg(Guint segNum, Guint length,
-			  Guint *refSegs, Guint nRefSegs);
+			  const Guint *refSegs, Guint nRefSegs);
   void readTextRegionSeg(Guint segNum, GBool imm,
 			 GBool lossless, Guint length,
-			 Guint *refSegs, Guint nRefSegs);
+			 const Guint *refSegs, Guint nRefSegs);
   JBIG2Bitmap *readTextRegion(GBool huff, GBool refine,
 			      int w, int h,
 			      Guint numInstances,
@@ -64,14 +60,14 @@ private:
 			      Guint defPixel, Guint combOp,
 			      Guint transposed, Guint refCorner,
 			      int sOffset,
-			      JBIG2HuffmanTable *huffFSTable,
-			      JBIG2HuffmanTable *huffDSTable,
-			      JBIG2HuffmanTable *huffDTTable,
-			      JBIG2HuffmanTable *huffRDWTable,
-			      JBIG2HuffmanTable *huffRDHTable,
-			      JBIG2HuffmanTable *huffRDXTable,
-			      JBIG2HuffmanTable *huffRDYTable,
-			      JBIG2HuffmanTable *huffRSizeTable,
+			      const JBIG2HuffmanTable *huffFSTable,
+			      const JBIG2HuffmanTable *huffDSTable,
+			      const JBIG2HuffmanTable *huffDTTable,
+			      const JBIG2HuffmanTable *huffRDWTable,
+			      const JBIG2HuffmanTable *huffRDHTable,
+			      const JBIG2HuffmanTable *huffRDXTable,
+			      const JBIG2HuffmanTable *huffRDYTable,
+			      const JBIG2HuffmanTable *huffRSizeTable,
 			      Guint templ,
 			      int *atx, int *aty);
   void readPatternDictSeg(Guint segNum, Guint length);
diff --git a/xpdf/JPXStream.cc b/xpdf/JPXStream.cc
index 79a7c51..ad31b1c 100644
--- a/xpdf/JPXStream.cc
+++ b/xpdf/JPXStream.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <limits.h>
 #include "gmem.h"
 #include "gmempp.h"
@@ -61,7 +57,7 @@
 // where subband = 0 for HL
 //               = 1 for LH and LL
 //               = 2 for HH
-static Guint sigPropContext[3][3][5][3] = {
+static Guint const sigPropContext[3][3][5][3] = {
   {{{ 0, 0, 0 },   // horiz=0, vert=0, diag=0
     { 1, 1, 3 },   // horiz=0, vert=0, diag=1
     { 2, 2, 6 },   // horiz=0, vert=0, diag=2
@@ -115,7 +111,7 @@ static Guint sigPropContext[3][3][5][3] = {
 // where horiz/vert are offset by 2 (i.e., range is -2 .. 2)
 // and k = 0 for the context
 //       = 1 for the xor bit
-static Guint signContext[5][5][2] = {
+static Guint const signContext[5][5][2] = {
   {{ 13, 1 },  // horiz=-2, vert=-2
    { 13, 1 },  // horiz=-2, vert=-1
    { 12, 1 },  // horiz=-2, vert= 0
@@ -464,10 +460,13 @@ void JPXStream::fillReadBuf() {
 }
 
 GString *JPXStream::getPSFilter(int psLevel, const char *indent) {
+  (void) psLevel;
+  (void) indent;
   return NULL;
 }
 
 GBool JPXStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -908,6 +907,7 @@ JPXDecodeResult JPXStream::readCodestream(Guint len) {
   Guint precinctSize;
   Guint segLen, capabilities, comp, i, j, r;
 
+  (void) len;
   //----- main header
   haveSIZ = haveCOD = haveQCD = haveSOT = gFalse;
   do {
@@ -1846,6 +1846,7 @@ GBool JPXStream::readTilePart() {
 	return gFalse;
       }
 #endif
+      break;
     case 0x58:			// PLT - packet length, tile-part header
       // skipped
       cover(41);
@@ -2451,6 +2452,9 @@ GBool JPXStream::readCodeBlockData(JPXTileComp *tileComp,
   int segSym;
   Guint n, i, x, y0, y1;
 
+  (void) resLevel;
+  (void) precinct;
+  (void) subband;
   if (res > tileComp->nDecompLevels - reduction) {
     // skip the codeblock data
     if (tileComp->codeBlockStyle & 0x04) {
@@ -2848,7 +2852,7 @@ void JPXStream::inverseTransform(JPXTileComp *tileComp) {
 	      cover(96);
 	      if (tileComp->transform == 0) {
 		cover(97);
-		val &= -1 << (fracBits - tileComp->prec);
+		val &= ~0U << (fracBits - tileComp->prec);
 	      }
 	    } else {
 	      cover(98);
@@ -2970,7 +2974,7 @@ void JPXStream::inverseTransformLevel(JPXTileComp *tileComp,
 	      if (qStyle == 0) {
 		cover(76);
 		if (tileComp->transform == 0) {
-		  val &= -1 << (fracBits - tileComp->prec);
+		  val &= ~0U << (fracBits - tileComp->prec);
 		}
 	      } else {
 		cover(77);
@@ -3390,7 +3394,7 @@ GBool JPXStream::readNBytes(int nBytes, GBool signd, int *x) {
   }
   if (signd) {
     if (y & (1 << (8 * nBytes - 1))) {
-      y |= -1 << (8 * nBytes);
+      y |= ~0U << (8 * nBytes);
     }
   }
   *x = y;
diff --git a/xpdf/JPXStream.h b/xpdf/JPXStream.h
index f1a66f5..1838aa9 100644
--- a/xpdf/JPXStream.h
+++ b/xpdf/JPXStream.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 #include "Stream.h"
diff --git a/xpdf/Lexer.cc b/xpdf/Lexer.cc
index 05e9df9..edabcf9 100644
--- a/xpdf/Lexer.cc
+++ b/xpdf/Lexer.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
@@ -24,7 +20,7 @@
 
 // A '1' in this array means the character is white space.  A '1' or
 // '2' means the character ends a name or command.
-static char specialChars[256] = {
+static char const specialChars[256] = {
   1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,   // 0x
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 1x
   1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,   // 2x
diff --git a/xpdf/Lexer.h b/xpdf/Lexer.h
index d481c2c..458a585 100644
--- a/xpdf/Lexer.h
+++ b/xpdf/Lexer.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Object.h"
 #include "Stream.h"
 
diff --git a/xpdf/Link.cc b/xpdf/Link.cc
index 900f79d..60f2086 100644
--- a/xpdf/Link.cc
+++ b/xpdf/Link.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include <string.h>
 #include "gmem.h"
diff --git a/xpdf/Link.h b/xpdf/Link.h
index 480496a..d615544 100644
--- a/xpdf/Link.h
+++ b/xpdf/Link.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Object.h"
 
 class GString;
diff --git a/xpdf/Makefile.am b/xpdf/Makefile.am
new file mode 100644
index 0000000..0ca51a6
--- /dev/null
+++ b/xpdf/Makefile.am
@@ -0,0 +1,159 @@
+noinst_LIBRARIES = libxpdf.a libxpdf_widget.a
+
+bin_PROGRAMS = pdftops pdftotext pdfinfo pdffonts pdfdetach pdfimages
+if HAVE_LIBPNG
+if HAVE_FREETYPE
+bin_PROGRAMS += pdftohtml pdftopng
+endif
+endif
+if HAVE_FREETYPE
+bin_PROGRAMS += pdftoppm
+endif
+
+AM_CPPFLAGS = -I$(top_builddir) -I$(srcdir) -I$(top_srcdir)/goo -I$(top_srcdir)/fofi -I$(top_srcdir)/splash
+AM_CPPFLAGS += $(PNG_CFLAGS)
+AM_CPPFLAGS += $(LCMS_CFLAGS)
+AM_CPPFLAGS += $(FREETYPE2_CFLAGS)
+
+libxpdf_a_SOURCES = \
+	config.h \
+	AcroForm.cc AcroForm.h \
+	Annot.cc Annot.h \
+	Array.cc Array.h \
+	BuiltinFont.cc BuiltinFont.h \
+	BuiltinFontTables.cc BuiltinFontTables.h \
+	CMap.cc CMap.h \
+	Catalog.cc Catalog.h \
+	CharCodeToUnicode.cc CharCodeToUnicode.h \
+	CharTypes.h \
+	CompactFontTables.h \
+	Decrypt.cc Decrypt.h \
+	Dict.cc Dict.h \
+	Error.cc Error.h ErrorCodes.h \
+	FontEncodingTables.cc FontEncodingTables.h \
+	Form.cc Form.h \
+	Function.cc Function.h \
+	Gfx.cc Gfx.h \
+	GfxFont.cc GfxFont.h \
+	GfxState.cc GfxState.h \
+	GlobalParams.cc GlobalParams.h \
+	JArithmeticDecoder.cc JArithmeticDecoder.h \
+	JBIG2Stream.cc JBIG2Stream.h \
+	JPXStream.cc JPXStream.h \
+	Lexer.cc Lexer.h \
+	Link.cc Link.h \
+	NameToCharCode.cc NameToCharCode.h NameToUnicodeTable.h \
+	Object.cc Object.h \
+	OptionalContent.cc OptionalContent.h \
+	Outline.cc Outline.h \
+	OutputDev.cc OutputDev.h \
+	PDF417Barcode.cc PDF417Barcode.h \
+	PDFDoc.cc PDFDoc.h \
+	PDFDocEncoding.cc PDFDocEncoding.h \
+	PSTokenizer.cc PSTokenizer.h \
+	Page.cc Page.h \
+	Parser.cc Parser.h \
+	SecurityHandler.cc SecurityHandler.h \
+	Stream.cc Stream.h Stream-CCITT.h \
+	TextOutputDev.cc TextOutputDev.h \
+	TextString.cc TextString.h \
+	UTF8.cc UTF8.h \
+	UnicodeMap.cc UnicodeMap.h UnicodeMapTables.h \
+	UnicodeRemapping.cc UnicodeRemapping.h \
+	UnicodeTypeTable.cc UnicodeTypeTable.h \
+	XFAForm.cc XFAForm.h \
+	XRef.cc XRef.h \
+	Zoox.cc Zoox.h \
+	$(empty)
+
+if HAVE_LCMS
+libxpdf_a_SOURCES += ColorManager.cc ColorManager.h
+endif
+
+
+libxpdf_widget_a_SOURCES =
+if HAVE_QT
+if MULTITHREADED
+if USE_EXCEPTIONS
+libxpdf_widget_a_SOURCES += \
+	DisplayState.cc DisplayState.h \
+	PDFCore.cc PDFCore.h \
+	PreScanOutputDev.cc PreScanOutputDev.h \
+	TileCache.cc TileCache.h \
+	TileCompositor.cc TileCompositor.h \
+	TileMap.cc TileMap.h \
+	$(empty)
+if HAVE_FREETYPE
+libxpdf_widget_a_SOURCES += \
+	PSOutputDev.cc PSOutputDev.h \
+	SplashOutputDev.cc SplashOutputDev.h \
+	$(empty)
+endif
+if HIGHLIGHTED_REGIONS
+libxpdf_widget_a_SOURCES += HighlightFile.cc HighlightFile.h
+endif
+if XPDFWIDGET_PRINTING
+if OS_WIN32
+libxpdf_widget_a_SOURCES += GDIOutputDev.cc GDIOutputDev.h
+libxpdf_widget_a_SOURCES += WinPDFPrinter.cc WinPDFPrinter.h
+endif
+endif
+endif
+endif
+endif
+
+pdftops_SOURCES = pdftops.cc \
+	PreScanOutputDev.cc PreScanOutputDev.h \
+	PSOutputDev.cc PSOutputDev.h \
+	SplashOutputDev.cc SplashOutputDev.h \
+	$(empty)
+pdftops_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi
+pdftops_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a
+if HAVE_FREETYPE
+pdftops_LDADD += -L../splash -lsplash
+pdftops_DEPENDENCIES += ../splash/libsplash.a
+endif
+pdftops_LDADD += $(LCMS_LIBS) $(FREETYPE2_LIBS) $(PNG_LIBS)
+
+pdffonts_SOURCES = pdffonts.cc
+pdffonts_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi
+pdffonts_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a
+pdffonts_LDADD += $(LCMS_LIBS)
+
+pdfdetach_SOURCES = pdfdetach.cc
+pdfdetach_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi
+pdfdetach_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a
+pdfdetach_LDADD += $(LCMS_LIBS)
+
+pdftoppm_SOURCES = pdftoppm.cc \
+	SplashOutputDev.cc SplashOutputDev.h
+pdftoppm_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi -L../splash -lsplash
+pdftoppm_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a ../splash/libsplash.a
+pdftoppm_LDADD += $(LCMS_LIBS) $(FREETYPE2_LIBS)
+
+pdftopng_SOURCES = pdftopng.cc \
+	SplashOutputDev.cc SplashOutputDev.h
+pdftopng_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi -L../splash -lsplash
+pdftopng_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a ../splash/libsplash.a
+pdftopng_LDADD += $(LCMS_LIBS) $(FREETYPE2_LIBS) $(PNG_LIBS)
+
+pdfinfo_SOURCES = pdfinfo.cc
+pdfinfo_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi
+pdfinfo_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a
+pdfinfo_LDADD += $(LCMS_LIBS)
+
+pdftohtml_SOURCES = pdftohtml.cc HTMLGen.cc HTMLGen.h \
+	SplashOutputDev.cc SplashOutputDev.h
+pdftohtml_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi -L../splash -lsplash
+pdftohtml_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a ../splash/libsplash.a
+pdftohtml_LDADD += $(LCMS_LIBS) $(FREETYPE2_LIBS) $(PNG_LIBS)
+
+pdftotext_SOURCES = pdftotext.cc
+pdftotext_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi -L../splash -lsplash
+pdftotext_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a ../splash/libsplash.a
+pdftotext_LDADD += $(LCMS_LIBS) $(FREETYPE2_LIBS)
+
+pdfimages_SOURCES = pdfimages.cc ImageOutputDev.cc ImageOutputDev.h
+pdfimages_LDADD = -L. -lxpdf -L../goo -lgoo -L../fofi -lfofi
+pdfimages_DEPENDENCIES = libxpdf.a ../goo/libgoo.a ../fofi/libfofi.a
+pdfimages_LDADD += $(LCMS_LIBS)
diff --git a/xpdf/NameToCharCode.cc b/xpdf/NameToCharCode.cc
index f846d8e..0088986 100644
--- a/xpdf/NameToCharCode.cc
+++ b/xpdf/NameToCharCode.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
diff --git a/xpdf/NameToCharCode.h b/xpdf/NameToCharCode.h
index 6548133..cf2170b 100644
--- a/xpdf/NameToCharCode.h
+++ b/xpdf/NameToCharCode.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "CharTypes.h"
 
 struct NameToCharCodeEntry;
diff --git a/xpdf/NameToUnicodeTable.h b/xpdf/NameToUnicodeTable.h
index 5000bd3..7d3fca5 100644
--- a/xpdf/NameToUnicodeTable.h
+++ b/xpdf/NameToUnicodeTable.h
@@ -9,7 +9,7 @@
 static struct {
   Unicode u;
   const char *name;
-} nameToUnicodeTab[] = {
+} const nameToUnicodeTab[] = {
   {0x0021, "!"},
   {0x0023, "#"},
   {0x0024, "$"},
diff --git a/xpdf/Object.cc b/xpdf/Object.cc
index c223074..39eafb6 100644
--- a/xpdf/Object.cc
+++ b/xpdf/Object.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include "gmempp.h"
 #include "Object.h"
@@ -25,7 +21,7 @@
 // Object
 //------------------------------------------------------------------------
 
-const char *objTypeNames[numObjTypes] = {
+static const char *const objTypeNames[numObjTypes] = {
   "boolean",
   "integer",
   "real",
@@ -43,7 +39,7 @@ const char *objTypeNames[numObjTypes] = {
 };
 
 #ifdef DEBUG_MEM
-#if MULTITHREADED
+#ifdef MULTITHREADED
 GAtomicCounter Object::numAlloc[numObjTypes] =
 #else
 long Object::numAlloc[numObjTypes] =
@@ -101,7 +97,7 @@ Object *Object::copy(Object *obj) {
     break;
   }
 #ifdef DEBUG_MEM
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicIncrement(&numAlloc[type]);
 #else
   ++numAlloc[type];
@@ -143,7 +139,7 @@ void Object::free() {
     break;
   }
 #ifdef DEBUG_MEM
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicDecrement(&numAlloc[type]);
 #else
   --numAlloc[type];
@@ -239,4 +235,5 @@ void Object::memCheck(FILE *f) {
     }
   }
 #endif
+  (void) f;
 }
diff --git a/xpdf/Object.h b/xpdf/Object.h
index cb63651..0f30297 100644
--- a/xpdf/Object.h
+++ b/xpdf/Object.h
@@ -11,17 +11,13 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #include <string.h>
 #include "gtypes.h"
 #include "gmem.h"
 #include "gfile.h"
 #include "GString.h"
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -72,7 +68,7 @@ enum ObjType {
 //------------------------------------------------------------------------
 
 #ifdef DEBUG_MEM
-#  if MULTITHREADED
+#  ifdef MULTITHREADED
 #    define initObj(t) gAtomicIncrement(&numAlloc[type = t])
 #  else
 #    define initObj(t) ++numAlloc[type = t]
@@ -217,7 +213,7 @@ private:
   };
 
 #ifdef DEBUG_MEM
-#if MULTITHREADED
+#ifdef MULTITHREADED
   static GAtomicCounter		// number of each type of object
     numAlloc[numObjTypes];	//   currently allocated
 #else
diff --git a/xpdf/OptionalContent.cc b/xpdf/OptionalContent.cc
index 6188856..2974e3e 100644
--- a/xpdf/OptionalContent.cc
+++ b/xpdf/OptionalContent.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "GString.h"
 #include "GList.h"
diff --git a/xpdf/OptionalContent.h b/xpdf/OptionalContent.h
index f00ef29..f4eb1e9 100644
--- a/xpdf/OptionalContent.h
+++ b/xpdf/OptionalContent.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 #include "CharTypes.h"
diff --git a/xpdf/Outline.cc b/xpdf/Outline.cc
index 9593956..09e3b75 100644
--- a/xpdf/Outline.cc
+++ b/xpdf/Outline.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmem.h"
 #include "gmempp.h"
 #include "GString.h"
diff --git a/xpdf/Outline.h b/xpdf/Outline.h
index e9bce83..80943ab 100644
--- a/xpdf/Outline.h
+++ b/xpdf/Outline.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Object.h"
 #include "CharTypes.h"
 
diff --git a/xpdf/OutputDev.cc b/xpdf/OutputDev.cc
index adec372..a94a966 100644
--- a/xpdf/OutputDev.cc
+++ b/xpdf/OutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include "gmempp.h"
 #include "Object.h"
@@ -79,12 +75,24 @@ void OutputDev::updateAll(GfxState *state) {
 GBool OutputDev::beginType3Char(GfxState *state, double x, double y,
 				double dx, double dy,
 				CharCode code, Unicode *u, int uLen) {
+  (void) state;
+  (void) x;
+  (void) y;
+  (void) dx;
+  (void) dy;
+  (void) code;
+  (void) u;
+  (void) uLen;
   return gFalse;
 }
 
 void OutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
 			      int width, int height, GBool invert,
 			      GBool inlineImg, GBool interpolate) {
+  (void) state;
+  (void) ref;
+  (void) invert;
+  (void) interpolate;
   if (inlineImg) {
     str->reset();
     str->discardChars(height * ((width + 7) / 8));
@@ -102,6 +110,10 @@ void OutputDev::setSoftMaskFromImageMask(GfxState *state,
 void OutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 			  int width, int height, GfxImageColorMap *colorMap,
 			  int *maskColors, GBool inlineImg, GBool interpolate) {
+  (void) state;
+  (void) ref;
+  (void) maskColors;
+  (void) interpolate;
   if (inlineImg) {
     str->reset();
     str->discardChars(height * ((width * colorMap->getNumPixelComps() *
@@ -116,6 +128,10 @@ void OutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,
 				Stream *maskStr,
 				int maskWidth, int maskHeight,
 				GBool maskInvert, GBool interpolate) {
+  (void) maskStr;
+  (void) maskWidth;
+  (void) maskHeight;
+  (void) maskInvert;
   drawImage(state, ref, str, width, height, colorMap, NULL, gFalse,
 	    interpolate);
 }
@@ -127,11 +143,16 @@ void OutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
 				    int maskWidth, int maskHeight,
 				    GfxImageColorMap *maskColorMap,
 				    double *matte, GBool interpolate) {
+  (void) maskStr;
+  (void) maskWidth;
+  (void) maskHeight;
+  (void) maskColorMap;
+  (void) matte;
   drawImage(state, ref, str, width, height, colorMap, NULL, gFalse,
 	    interpolate);
 }
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
 void OutputDev::opiBegin(GfxState *state, Dict *opiDict) {
 }
 
diff --git a/xpdf/OutputDev.h b/xpdf/OutputDev.h
index f53dab1..11aa7a8 100644
--- a/xpdf/OutputDev.h
+++ b/xpdf/OutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "CharTypes.h"
 
@@ -98,10 +94,14 @@ public:
 			       GBool printing,
 			       GBool (*abortCheckCbk)(void *data) = NULL,
 			       void *abortCheckCbkData = NULL)
-    { return gTrue; }
+    { (void) page; (void) hDPI; (void) vDPI;
+      (void) rotate; (void) useMediaBox; (void) crop;
+      (void) sliceX; (void) sliceY; (void) sliceW; (void) sliceH;
+      (void) printing; (void) abortCheckCbk; (void) abortCheckCbkData;
+      return gTrue; }
 
   // Start a page.
-  virtual void startPage(int pageNum, GfxState *state) {}
+  virtual void startPage(int pageNum, GfxState *state) { (void) pageNum; (void) state; }
 
   // End a page.
   virtual void endPage() {}
@@ -117,86 +117,92 @@ public:
   double *getDefICTM() { return defICTM; }
 
   //----- save/restore graphics state
-  virtual void saveState(GfxState *state) {}
-  virtual void restoreState(GfxState *state) {}
+  virtual void saveState(GfxState *state) {(void) state;}
+  virtual void restoreState(GfxState *state) {(void) state;}
 
   //----- update graphics state
   virtual void updateAll(GfxState *state);
   virtual void updateCTM(GfxState *state, double m11, double m12,
-			 double m21, double m22, double m31, double m32) {}
-  virtual void updateLineDash(GfxState *state) {}
-  virtual void updateFlatness(GfxState *state) {}
-  virtual void updateLineJoin(GfxState *state) {}
-  virtual void updateLineCap(GfxState *state) {}
-  virtual void updateMiterLimit(GfxState *state) {}
-  virtual void updateLineWidth(GfxState *state) {}
-  virtual void updateStrokeAdjust(GfxState *state) {}
-  virtual void updateFillColorSpace(GfxState *state) {}
-  virtual void updateStrokeColorSpace(GfxState *state) {}
-  virtual void updateFillColor(GfxState *state) {}
-  virtual void updateStrokeColor(GfxState *state) {}
-  virtual void updateBlendMode(GfxState *state) {}
-  virtual void updateFillOpacity(GfxState *state) {}
-  virtual void updateStrokeOpacity(GfxState *state) {}
-  virtual void updateFillOverprint(GfxState *state) {}
-  virtual void updateStrokeOverprint(GfxState *state) {}
-  virtual void updateOverprintMode(GfxState *state) {}
-  virtual void updateRenderingIntent(GfxState *state) {}
-  virtual void updateTransfer(GfxState *state) {}
+			 double m21, double m22, double m31, double m32) {(void) state; (void)m11; (void)m12; (void)m21; (void)m22; (void)m31; (void)m32; }
+  virtual void updateLineDash(GfxState *state) {(void) state;}
+  virtual void updateFlatness(GfxState *state) {(void) state;}
+  virtual void updateLineJoin(GfxState *state) {(void) state;}
+  virtual void updateLineCap(GfxState *state) {(void) state;}
+  virtual void updateMiterLimit(GfxState *state) {(void) state;}
+  virtual void updateLineWidth(GfxState *state) {(void) state;}
+  virtual void updateStrokeAdjust(GfxState *state) {(void) state;}
+  virtual void updateFillColorSpace(GfxState *state) {(void) state;}
+  virtual void updateStrokeColorSpace(GfxState *state) {(void) state;}
+  virtual void updateFillColor(GfxState *state) {(void) state;}
+  virtual void updateStrokeColor(GfxState *state) {(void) state;}
+  virtual void updateBlendMode(GfxState *state) {(void) state;}
+  virtual void updateFillOpacity(GfxState *state) {(void) state;}
+  virtual void updateStrokeOpacity(GfxState *state) {(void) state;}
+  virtual void updateFillOverprint(GfxState *state) {(void) state;}
+  virtual void updateStrokeOverprint(GfxState *state) {(void) state;}
+  virtual void updateOverprintMode(GfxState *state) {(void) state;}
+  virtual void updateRenderingIntent(GfxState *state) {(void) state;}
+  virtual void updateTransfer(GfxState *state) {(void) state;}
 
   //----- update text state
-  virtual void updateFont(GfxState *state) {}
-  virtual void updateTextMat(GfxState *state) {}
-  virtual void updateCharSpace(GfxState *state) {}
-  virtual void updateRender(GfxState *state) {}
-  virtual void updateRise(GfxState *state) {}
-  virtual void updateWordSpace(GfxState *state) {}
-  virtual void updateHorizScaling(GfxState *state) {}
-  virtual void updateTextPos(GfxState *state) {}
-  virtual void updateTextShift(GfxState *state, double shift) {}
-  virtual void saveTextPos(GfxState *state) {}
-  virtual void restoreTextPos(GfxState *state) {}
+  virtual void updateFont(GfxState *state) {(void) state;}
+  virtual void updateTextMat(GfxState *state) {(void) state;}
+  virtual void updateCharSpace(GfxState *state) {(void) state;}
+  virtual void updateRender(GfxState *state) {(void) state;}
+  virtual void updateRise(GfxState *state) {(void) state;}
+  virtual void updateWordSpace(GfxState *state) {(void) state;}
+  virtual void updateHorizScaling(GfxState *state) {(void) state;}
+  virtual void updateTextPos(GfxState *state) {(void) state;}
+  virtual void updateTextShift(GfxState *state, double shift) {(void) state; (void)shift;}
+  virtual void saveTextPos(GfxState *state) {(void) state;}
+  virtual void restoreTextPos(GfxState *state) {(void) state;}
 
   //----- path painting
-  virtual void stroke(GfxState *state) {}
-  virtual void fill(GfxState *state) {}
-  virtual void eoFill(GfxState *state) {}
+  virtual void stroke(GfxState *state) {(void) state;}
+  virtual void fill(GfxState *state) {(void) state;}
+  virtual void eoFill(GfxState *state) {(void) state;}
   virtual void tilingPatternFill(GfxState *state, Gfx *gfx, Object *strRef,
 				 int paintType, int tilingType, Dict *resDict,
 				 double *mat, double *bbox,
 				 int x0, int y0, int x1, int y1,
-				 double xStep, double yStep) {}
+				 double xStep, double yStep) {(void) state; (void) gfx; (void)strRef; (void) paintType; (void) tilingType;
+				 (void) resDict; (void) mat; (void) bbox;
+				 (void) x0; (void) y0; (void) x1; (void) y1;
+				 (void) xStep; (void) yStep; }
   virtual GBool functionShadedFill(GfxState *state,
 				   GfxFunctionShading *shading)
-    { return gFalse; }
+    { (void) state; (void) shading; return gFalse; }
   virtual GBool axialShadedFill(GfxState *state, GfxAxialShading *shading)
-    { return gFalse; }
+    { (void) state; (void) shading; return gFalse; }
   virtual GBool radialShadedFill(GfxState *state, GfxRadialShading *shading)
-    { return gFalse; }
+    { (void) state; (void) shading; return gFalse; }
 
   //----- path clipping
-  virtual void clip(GfxState *state) {}
-  virtual void eoClip(GfxState *state) {}
-  virtual void clipToStrokePath(GfxState *state) {}
+  virtual void clip(GfxState *state) {(void) state;}
+  virtual void eoClip(GfxState *state) {(void) state;}
+  virtual void clipToStrokePath(GfxState *state) {(void) state;}
 
   //----- text drawing
-  virtual void beginStringOp(GfxState *state) {}
-  virtual void endStringOp(GfxState *state) {}
-  virtual void beginString(GfxState *state, GString *s) {}
-  virtual void endString(GfxState *state) {}
+  virtual void beginStringOp(GfxState *state) {(void) state;}
+  virtual void endStringOp(GfxState *state) {(void) state;}
+  virtual void beginString(GfxState *state, GString *s) {(void) state; (void) s;}
+  virtual void endString(GfxState *state) {(void) state;}
   virtual void drawChar(GfxState *state, double x, double y,
 			double dx, double dy,
 			double originX, double originY,
-			CharCode code, int nBytes, Unicode *u, int uLen) {}
-  virtual void drawString(GfxState *state, GString *s) {}
+			CharCode code, int nBytes, Unicode *u, int uLen) {(void) state;
+			(void) x; (void) y; (void) dx; (void) dy;
+			(void) originX; (void) originY;
+			(void) code; (void) nBytes; (void) u; (void) uLen; }
+  virtual void drawString(GfxState *state, GString *s) {(void) state; (void) s;}
   virtual GBool beginType3Char(GfxState *state, double x, double y,
 			       double dx, double dy,
 			       CharCode code, Unicode *u, int uLen);
-  virtual void endType3Char(GfxState *state) {}
-  virtual void endTextObject(GfxState *state) {}
-  virtual void incCharCount(int nChars) {}
-  virtual void beginActualText(GfxState *state, Unicode *u, int uLen) {}
-  virtual void endActualText(GfxState *state) {}
+  virtual void endType3Char(GfxState *state) { (void) state;}
+  virtual void endTextObject(GfxState *state) { (void) state;}
+  virtual void incCharCount(int nChars) { (void) nChars;}
+  virtual void beginActualText(GfxState *state, Unicode *u, int uLen) { (void) state; (void) u; (void) uLen; }
+  virtual void endActualText(GfxState *state) { (void) state;}
 
   //----- image drawing
   virtual void drawImageMask(GfxState *state, Object *ref, Stream *str,
@@ -222,39 +228,43 @@ public:
 				   GfxImageColorMap *maskColorMap,
 				   double *matte, GBool interpolate);
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   //----- OPI functions
   virtual void opiBegin(GfxState *state, Dict *opiDict);
   virtual void opiEnd(GfxState *state, Dict *opiDict);
 #endif
 
   //----- Type 3 font operators
-  virtual void type3D0(GfxState *state, double wx, double wy) {}
+  virtual void type3D0(GfxState *state, double wx, double wy) { (void) state; (void) wx; (void) wy;}
   virtual void type3D1(GfxState *state, double wx, double wy,
-		       double llx, double lly, double urx, double ury) {}
+		       double llx, double lly, double urx, double ury) {(void) state;
+		       (void) wx; (void) wy; (void) llx; (void) lly; (void) urx; (void) ury;}
 
   //----- form XObjects
-  virtual void drawForm(Ref id) {}
+  virtual void drawForm(Ref id) {(void) id;}
 
   //----- PostScript XObjects
-  virtual void psXObject(Stream *psStream, Stream *level1Stream) {}
+  virtual void psXObject(Stream *psStream, Stream *level1Stream) {(void) psStream; (void) level1Stream; }
 
   //----- transparency groups and soft masks
   virtual void beginTransparencyGroup(GfxState *state, double *bbox,
 				      GfxColorSpace *blendingColorSpace,
 				      GBool isolated, GBool knockout,
-				      GBool forSoftMask) {}
-  virtual void endTransparencyGroup(GfxState *state) {}
-  virtual void paintTransparencyGroup(GfxState *state, double *bbox) {}
+				      GBool forSoftMask) {(void) state;
+				      (void) bbox; (void) blendingColorSpace; (void) isolated;
+				      (void) knockout; (void) forSoftMask; }
+  virtual void endTransparencyGroup(GfxState *state) {(void) state;}
+  virtual void paintTransparencyGroup(GfxState *state, double *bbox) {(void) state;(void) bbox;}
   virtual void setSoftMask(GfxState *state, double *bbox, GBool alpha,
-			   Function *transferFunc, GfxColor *backdropColor) {}
-  virtual void clearSoftMask(GfxState *state) {}
+			   Function *transferFunc, GfxColor *backdropColor) {(void) state;
+			   (void) bbox; (void) alpha; (void) transferFunc; (void) backdropColor; }
+  virtual void clearSoftMask(GfxState *state) {(void) state;}
 
   //----- links
-  virtual void processLink(Link *link) {}
+  virtual void processLink(Link *link) {(void) link;}
 
 #if 1 //~tmp: turn off anti-aliasing temporarily
-  virtual void setInShading(GBool sh) {}
+  virtual void setInShading(GBool sh) {(void) sh; }
 #endif
 
 private:
diff --git a/xpdf/PDF417Barcode.cc b/xpdf/PDF417Barcode.cc
index 0dd35ee..33f784b 100644
--- a/xpdf/PDF417Barcode.cc
+++ b/xpdf/PDF417Barcode.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <math.h>
 #include "gtypes.h"
 #include "GString.h"
@@ -54,7 +50,7 @@
 
 // textCompaction[char][submode] = base-30 value
 //                                 or 30 if char isn't available
-static char textCompaction[128][4] = {
+static char const textCompaction[128][4] = {
   { 30, 30, 30, 30 },  //   0
   { 30, 30, 30, 30 },  //   1
   { 30, 30, 30, 30 },  //   2
@@ -185,31 +181,31 @@ static char textCompaction[128][4] = {
   { 30, 30, 30, 30 }   // 127
 };
 
-static int errorCorrectionCoeffLevel0[2] = {
+static int const errorCorrectionCoeffLevel0[2] = {
   27, 917
 };
 
-static int errorCorrectionCoeffLevel1[4] = {
+static int const errorCorrectionCoeffLevel1[4] = {
   522, 568, 723, 809
 };
 
-static int errorCorrectionCoeffLevel2[8] = {
+static int const errorCorrectionCoeffLevel2[8] = {
   237, 308, 436, 284, 646, 653, 428, 379
 };
 
-static int errorCorrectionCoeffLevel3[16] = {
+static int const errorCorrectionCoeffLevel3[16] = {
   274, 562, 232, 755, 599, 524, 801, 132,
   295, 116, 442, 428, 295,  42, 176,  65
 };
 
-static int errorCorrectionCoeffLevel4[32] = {
+static int const errorCorrectionCoeffLevel4[32] = {
   361, 575, 922, 525, 176, 586, 640, 321,
   536, 742, 677, 742, 687, 284, 193, 517,
   273, 494, 263, 147, 593, 800, 571, 320,
   803, 133, 231, 390, 685, 330,  63, 410
 };
 
-static int errorCorrectionCoeffLevel5[64] = {
+static int const errorCorrectionCoeffLevel5[64] = {
   539, 422,   6,  93, 862, 771, 453, 106,
   610, 287, 107, 505, 733, 877, 381, 612,
   723, 476, 462, 172, 430, 609, 858, 822,
@@ -220,7 +216,7 @@ static int errorCorrectionCoeffLevel5[64] = {
   840, 629,   4, 381, 843, 623, 264, 543
 };
 
-static int errorCorrectionCoeffLevel6[128] = {
+static int const errorCorrectionCoeffLevel6[128] = {
   521, 310, 864, 547, 858, 580, 296, 379,
    53, 779, 897, 444, 400, 925, 749, 415,
   822,  93, 217, 208, 928, 244, 583, 620,
@@ -239,7 +235,7 @@ static int errorCorrectionCoeffLevel6[128] = {
   834, 315, 550,  86, 801,   4, 108, 539
 };
 
-static int errorCorrectionCoeffLevel7[256] = {
+static int const errorCorrectionCoeffLevel7[256] = {
   524, 894,  75, 766, 882, 857,  74, 204,
    82, 586, 708, 250, 905, 786, 138, 720,
   858, 194, 311, 913, 275, 190, 375, 850,
@@ -274,7 +270,7 @@ static int errorCorrectionCoeffLevel7[256] = {
   307, 159, 924, 558, 648,  55, 497,  10
 };
 
-static int errorCorrectionCoeffLevel8[512] = {
+static int const errorCorrectionCoeffLevel8[512] = {
   352,  77, 373, 504,  35, 599, 428, 207,
   409, 574, 118, 498, 285, 380, 350, 492,
   197, 265, 920, 155, 914, 299, 229, 643,
@@ -341,7 +337,7 @@ static int errorCorrectionCoeffLevel8[512] = {
   675, 410, 389, 244,  31, 121, 303, 263
 };
 
-static int *errorCorrectionCoeff[maxErrorCorrectionLevel + 1] = {
+static const int *const errorCorrectionCoeff[maxErrorCorrectionLevel + 1] = {
   errorCorrectionCoeffLevel0,
   errorCorrectionCoeffLevel1,
   errorCorrectionCoeffLevel2,
@@ -354,15 +350,15 @@ static int *errorCorrectionCoeff[maxErrorCorrectionLevel + 1] = {
 };
 
 #define startPatternLength 8
-static char startPattern[startPatternLength] = {8,1,1,1,1,1,1,3};
+static char const startPattern[startPatternLength] = {8,1,1,1,1,1,1,3};
 
 #define stopPatternLength 9
-static char stopPattern[stopPatternLength] = {7,1,1,3,1,1,1,2,1};
+static char const stopPattern[stopPatternLength] = {7,1,1,3,1,1,1,2,1};
 
 #define patternLength 8
 
 // patterns[codeword][cluster][element] = element (bar or space) width
-static char patterns[929][3][patternLength] = {
+static char const patterns[929][3][patternLength] = {
   {{3,1,1,1,1,1,3,6}, {5,1,1,1,1,1,2,5}, {2,1,1,1,1,1,5,5}},
   {{4,1,1,1,1,1,4,4}, {6,1,1,1,1,1,3,3}, {3,1,1,1,1,1,6,3}},
   {{5,1,1,1,1,1,5,2}, {4,1,1,1,1,2,1,6}, {1,1,1,1,1,2,4,6}},
@@ -1319,7 +1315,7 @@ static void drawBarcode(int *codewords, int totalLength,
 			double moduleWidth, double moduleHeight,
 			double fieldWidth, double fieldHeight,
 			GString *appearBuf);
-static void drawPattern(int &x, int y, char *pattern, int length,
+static void drawPattern(int &x, int y, const char *pattern, int length,
 			GString *appearBuf);
 
 //------------------------------------------------------------------------
@@ -1866,6 +1862,7 @@ static void drawBarcode(int *codewords, int totalLength,
   double x0 = 0.5 * (fieldWidth - w);
   double y0 = 0.5 * (fieldHeight - h);
 
+  (void) totalLength;
   appearBuf->append("0 g q\n");
   appearBuf->appendf("{0:.4f} 0 0 {1:.4f} {2:.4f} {3:.4f} cm\n",
 		     moduleWidth, moduleHeight, x0, y0);
@@ -1905,7 +1902,7 @@ static void drawBarcode(int *codewords, int totalLength,
   appearBuf->append("Q\n");
 }
 
-static void drawPattern(int &x, int y, char *pattern, int length,
+static void drawPattern(int &x, int y, const char *pattern, int length,
 			GString *appearBuf) {
   for (int i = 0; i < length; ++i) {
     if (!(i & 1)) {
diff --git a/xpdf/PDF417Barcode.h b/xpdf/PDF417Barcode.h
index 8166865..c86f1df 100644
--- a/xpdf/PDF417Barcode.h
+++ b/xpdf/PDF417Barcode.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 class GString;
 
 // Draw a PDF417 barcode:
diff --git a/xpdf/PDFCore.cc b/xpdf/PDFCore.cc
index 70919f4..5764320 100644
--- a/xpdf/PDFCore.cc
+++ b/xpdf/PDFCore.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <math.h>
 #include "gmempp.h"
 #include "GString.h"
@@ -1043,7 +1039,7 @@ void PDFCore::setLinearSelection(int page, TextPosition *pos0,
   int wx0, wy0, wx1, wy1;
   int sx, sy, colIdx;
 
-
+  (void)page;
   // if selection rectangle is empty, clear the selection
   if (*pos0 == *pos1) {
     clearSelection();
diff --git a/xpdf/PDFCore.h b/xpdf/PDFCore.h
index 0fa089f..f1a7ffe 100644
--- a/xpdf/PDFCore.h
+++ b/xpdf/PDFCore.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdlib.h>
 #include "SplashTypes.h"
 #include "CharTypes.h"
diff --git a/xpdf/PDFDoc.cc b/xpdf/PDFDoc.cc
index 95879a8..1e08419 100644
--- a/xpdf/PDFDoc.cc
+++ b/xpdf/PDFDoc.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
diff --git a/xpdf/PDFDoc.h b/xpdf/PDFDoc.h
index e7005b1..2a435ef 100644
--- a/xpdf/PDFDoc.h
+++ b/xpdf/PDFDoc.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #include "XRef.h"
 #include "Catalog.h"
diff --git a/xpdf/PDFDocEncoding.cc b/xpdf/PDFDocEncoding.cc
index c4eef7c..cf38606 100644
--- a/xpdf/PDFDocEncoding.cc
+++ b/xpdf/PDFDocEncoding.cc
@@ -9,7 +9,7 @@
 #include "gmempp.h"
 #include "PDFDocEncoding.h"
 
-Unicode pdfDocEncoding[256] = {
+Unicode const pdfDocEncoding[256] = {
   0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, // 00
   0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
   0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, // 10
diff --git a/xpdf/PDFDocEncoding.h b/xpdf/PDFDocEncoding.h
index 3259d3e..7300a6c 100644
--- a/xpdf/PDFDocEncoding.h
+++ b/xpdf/PDFDocEncoding.h
@@ -11,6 +11,6 @@
 
 #include "CharTypes.h"
 
-extern Unicode pdfDocEncoding[256];
+extern Unicode const pdfDocEncoding[256];
 
 #endif
diff --git a/xpdf/PSOutputDev.cc b/xpdf/PSOutputDev.cc
index 15a2a23..3592873 100644
--- a/xpdf/PSOutputDev.cc
+++ b/xpdf/PSOutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stddef.h>
 #include <stdarg.h>
@@ -42,7 +38,7 @@
 #include "CharCodeToUnicode.h"
 #include "Form.h"
 #include "TextString.h"
-#if HAVE_SPLASH
+#ifdef HAVE_SPLASH
 #  include "Splash.h"
 #  include "SplashBitmap.h"
 #  include "SplashOutputDev.h"
@@ -54,6 +50,8 @@
 #define M_PI 3.14159265358979323846
 #endif
 
+static char const hexChars[17] = "0123456789abcdef";
+
 //------------------------------------------------------------------------
 // PostScript prolog and setup
 //------------------------------------------------------------------------
@@ -65,7 +63,7 @@
 //      ^   ^----- n=psLevel_, g=psLevel_Gray, s=psLevel_Sep
 //      +----- 1=psLevel1__, 2=psLevel2__, 3=psLevel3__
 
-static const char *prolog[] = {
+static const char *const prolog[] = {
   "/xpdf 75 dict def xpdf begin",
   "% PDF special state",
   "/pdfDictSize 15 def",
@@ -765,7 +763,7 @@ static const char *prolog[] = {
   NULL
 };
 
-static const char *minLineWidthProlog[] = {
+static const char *const minLineWidthProlog[] = {
   "/pdfDist { dup dtransform dup mul exch dup mul add 0.5 mul sqrt } def",
   "/pdfIDist { dup idtransform dup mul exch dup mul add 0.5 mul sqrt } def",
   "/pdfMinLineDist pdfMinLineWidth pdfDist def",
@@ -778,7 +776,7 @@ static const char *minLineWidthProlog[] = {
   NULL
 };
 
-static const char *cmapProlog[] = {
+static const char *const cmapProlog[] = {
   "/CIDInit /ProcSet findresource begin",
   "10 dict begin",
   "  begincmap",
@@ -833,7 +831,7 @@ struct PSSubstFont {
 };
 
 // NB: must be in same order as base14SubstFonts in GfxFont.cc
-static PSSubstFont psBase14SubstFonts[14] = {
+static PSSubstFont const psBase14SubstFonts[14] = {
   {"Courier",               0.600},
   {"Courier-Oblique",       0.600},
   {"Courier-Bold",          0.600},
@@ -985,8 +983,8 @@ public:
     { return (bufIdx >= bufSize && !fillBuf()) ? EOF : buf[bufIdx++]; }
   virtual int lookChar()
     { return (bufIdx >= bufSize && !fillBuf()) ? EOF : buf[bufIdx]; }
-  virtual GString *getPSFilter(int psLevel, const char *indent) { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gTrue; }
+  virtual GString *getPSFilter(int psLevel, const char *indent) { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gTrue; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -1084,8 +1082,8 @@ public:
     { return (bufIdx >= width && !fillBuf()) ? EOF : buf[bufIdx++]; }
   virtual int lookChar()
     { return (bufIdx >= width && !fillBuf()) ? EOF : buf[bufIdx]; }
-  virtual GString *getPSFilter(int psLevel, const char *indent) { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gTrue; }
+  virtual GString *getPSFilter(int psLevel, const char *indent) { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gTrue; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -1167,8 +1165,8 @@ public:
     { return (bufIdx >= bufSize && !fillBuf()) ? EOF : buf[bufIdx++]; }
   virtual int lookChar()
     { return (bufIdx >= bufSize && !fillBuf()) ? EOF : buf[bufIdx]; }
-  virtual GString *getPSFilter(int psLevel, const char *indent) { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gTrue; }
+  virtual GString *getPSFilter(int psLevel, const char *indent) { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gTrue; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -1457,7 +1455,7 @@ void PSOutputDev::init(PSOutputFunc outputFuncA, void *outputStreamA,
   processColors = 0;
   inType3Char = gFalse;
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   // initialize OPI nesting levels
   opi13Nest = 0;
   opi20Nest = 0;
@@ -1680,7 +1678,7 @@ void PSOutputDev::writeHeader(PDFRectangle *mediaBox, PDFRectangle *cropBox,
 
 void PSOutputDev::writeXpdfProcset() {
   GBool lev1, lev2, lev3, nonSep, gray, sep;
-  const char **p;
+  const char *const *p;
   const char *q;
   double w;
 
@@ -1812,7 +1810,7 @@ void PSOutputDev::writeDocSetup(Catalog *catalog) {
 	writePSFmt("{0:d} {1:d} pdfSetupPaper\n", paperWidth, paperHeight);
       }
     }
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
     if (globalParams->getPSOPI()) {
       writePS("/opiMatrix matrix currentmatrix def\n");
     }
@@ -2232,7 +2230,7 @@ void PSOutputDev::setupFont(GfxFont *font, Dict *parentResDict) {
     writePSFmt("/F{0:d}_{1:d} /{2:t} {3:.6g} {4:.6g}\n",
 	       font->getID()->num, font->getID()->gen, fi->ff->psName, xs, ys);
     for (i = 0; i < 256; i += 8) {
-      writePS((char *)((i == 0) ? "[ " : "  "));
+      writePS(i == 0 ? "[ " : "  ");
       for (j = 0; j < 8; ++j) {
 	if (font->getType() == fontTrueType &&
 	    !subst &&
@@ -2243,7 +2241,7 @@ void PSOutputDev::setupFont(GfxFont *font, Dict *parentResDict) {
 	  charName = ((Gfx8BitFont *)font)->getCharName(i+j);
 	}
 	writePS("/");
-	writePSName(charName ? charName : (char *)".notdef");
+	writePSName(charName ? charName : ".notdef");
 	// the empty name is legal in PDF and PostScript, but PostScript
 	// uses a double-slash (//...) for "immediately evaluated names",
 	// so we need to add a space character here
@@ -2251,7 +2249,7 @@ void PSOutputDev::setupFont(GfxFont *font, Dict *parentResDict) {
 	  writePS(" ");
 	}
       }
-      writePS((i == 256-8) ? (char *)"]\n" : (char *)"\n");
+      writePS((i == 256-8) ? "]\n" : "\n");
     }
     writePS("pdfMakeFont\n");
   }
@@ -2356,7 +2354,6 @@ PSFontFileInfo *PSOutputDev::setupEmbeddedType1Font(GfxFont *font, Ref *id) {
 
 PSFontFileInfo *PSOutputDev::setupExternalType1Font(GfxFont *font,
 						    GString *fileName) {
-  static char hexChar[17] = "0123456789abcdef";
   GString *psName;
   PSFontFileInfo *ff;
   FILE *fontFile;
@@ -2412,8 +2409,8 @@ PSFontFileInfo *PSOutputDev::setupExternalType1Font(GfxFont *font,
 	  if ((c = fgetc(fontFile)) == EOF) {
 	    break;
 	  }
-	  writePSChar(hexChar[(c >> 4) & 0x0f]);
-	  writePSChar(hexChar[c & 0x0f]);
+	  writePSChar(hexChars[(c >> 4) & 0x0f]);
+	  writePSChar(hexChars[c & 0x0f]);
 	  if (i % 32 == 31) {
 	    writePSChar('\n');
 	  }
@@ -3537,7 +3534,6 @@ GString *PSOutputDev::asciiHexDecodeType1EexecSection(GString *in) {
 }
 
 GBool PSOutputDev::fixType1EexecSection(GString *binSection, GString *out) {
-  static char hexChars[17] = "0123456789abcdef";
   Guchar buf[16], buf2[16];
   Guchar byte;
   int r, i, j;
@@ -3602,7 +3598,6 @@ GString *PSOutputDev::copyType1PFA(Guchar *font, int fontSize) {
 // The Type 1 cleanup code failed -- assume it's a valid PFB-format
 // font, decode the PFB blocks, and copy them to the output.
 GString *PSOutputDev::copyType1PFB(Guchar *font, int fontSize) {
-  static char hexChars[17] = "0123456789abcdef";
   GString *out;
   Guchar *p;
   int remain, len, i, j;
@@ -3930,7 +3925,7 @@ void PSOutputDev::setupImage(Ref id, Stream *str, GBool mask,
   // write the data into the array
   str->reset();
   line = col = 0;
-  writePS((char *)(useASCIIHex ? "dup 0 <" : "dup 0 <~"));
+  writePS(useASCIIHex ? "dup 0 <" : "dup 0 <~");
   do {
     do {
       c = str->getChar();
@@ -3960,13 +3955,13 @@ void PSOutputDev::setupImage(Ref id, Stream *str, GBool mask,
     // chunks are 1 or 4 bytes each, so we have to stop at 232
     // but make it 225 just to be safe
     if (col > 225) {
-      writePS((char *)(useASCIIHex ? "> put\n" : "~> put\n"));
+      writePS(useASCIIHex ? "> put\n" : "~> put\n");
       ++line;
-      writePSFmt((char *)(useASCIIHex ? "dup {0:d} <" : "dup {0:d} <~"), line);
+      writePSFmt(useASCIIHex ? "dup {0:d} <" : "dup {0:d} <~", line);
       col = 0;
     }
   } while (c != (useASCIIHex ? '>' : '~') && c != EOF);
-  writePS((char *)(useASCIIHex ? "> put\n" : "~> put\n"));
+  writePS(useASCIIHex ? "> put\n" : "~> put\n");
   if (useLZW || useRLE) {
     ++line;
     writePSFmt("{0:d} <> put\n", line);
@@ -4103,7 +4098,7 @@ GBool PSOutputDev::checkPageSlice(Page *page, double hDPI, double vDPI,
 				  GBool (*abortCheckCbk)(void *data),
 				  void *abortCheckCbkData) {
   int pg;
-#if HAVE_SPLASH
+#ifdef HAVE_SPLASH
   GBool mono;
   GBool useLZW;
   double dpi;
@@ -4123,13 +4118,15 @@ GBool PSOutputDev::checkPageSlice(Page *page, double hDPI, double vDPI,
   int w, h, x, y, comp, i, n;
 #endif
 
+  (void) hDPI;
+  (void) vDPI;
   pg = page->getNum();
   if (!(pg >= firstPage && pg <= lastPage &&
 	rasterizePage[pg - firstPage])) {
     return gTrue;
   }
 
-#if HAVE_SPLASH
+#ifdef HAVE_SPLASH
   // get the rasterization parameters
   dpi = globalParams->getPSRasterResolution();
   mono = globalParams->getPSRasterMono() ||
@@ -4164,7 +4161,7 @@ GBool PSOutputDev::checkPageSlice(Page *page, double hDPI, double vDPI,
     splashOut = new SplashOutputDev(splashModeMono8, 1, gFalse,
 				    paperColor, gFalse,
 				    globalParams->getAntialiasPrinting());
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   } else if (level == psLevel1Sep) {
     paperColor[0] = paperColor[1] = paperColor[2] = paperColor[3] = 0;
     splashOut = new SplashOutputDev(splashModeCMYK8, 1, gFalse,
@@ -4343,13 +4340,13 @@ GBool PSOutputDev::checkPageSlice(Page *page, double hDPI, double vDPI,
 
   return gFalse;
 
-#else // HAVE_SPLASH
+#else /* HAVE_SPLASH */
 
   error(errSyntaxWarning, -1,
 	"PDF page uses transparency and PSOutputDev was built without"
 	" the Splash rasterizer - output may not be correct");
   return gTrue;
-#endif // HAVE_SPLASH
+#endif /* HAVE_SPLASH */
 }
 
 void PSOutputDev::startPage(int pageNum, GfxState *state) {
@@ -4609,6 +4606,7 @@ void PSOutputDev::saveState(GfxState *state) {
   //   q  q AAA Q BBB Q     (where AAA and BBB are sequences of operations)
   // and transform them to:
   //   q AAA Q q BBB Q
+  (void) state;
   if (noStateChanges) {
     // any non-NULL pointer will work here
     saveStack->append(this);
@@ -4620,6 +4618,7 @@ void PSOutputDev::saveState(GfxState *state) {
 }
 
 void PSOutputDev::restoreState(GfxState *state) {
+  (void) state;
   if (saveStack->getLength()) {
     writePS("Q\n");
     if (saveStack->del(saveStack->getLength() - 1)) {
@@ -4633,6 +4632,7 @@ void PSOutputDev::restoreState(GfxState *state) {
 
 void PSOutputDev::updateCTM(GfxState *state, double m11, double m12,
 			    double m21, double m22, double m31, double m32) {
+  (void) state;
   if (m11 == 1 && m12 == 0 && m21 == 0 && m22 == 1 && m31 == 0 && m32 == 0) {
     return;
   }
@@ -5060,11 +5060,13 @@ void PSOutputDev::updateTextShift(GfxState *state, double shift) {
 }
 
 void PSOutputDev::saveTextPos(GfxState *state) {
+  (void) state;
   writePS("currentpoint\n");
   noStateChanges = gFalse;
 }
 
 void PSOutputDev::restoreTextPos(GfxState *state) {
+  (void) state;
   writePS("m\n");
   noStateChanges = gFalse;
 }
@@ -5118,6 +5120,8 @@ void PSOutputDev::tilingPatternFillL1(GfxState *state, Gfx *gfx,
   PDFRectangle box;
   Gfx *gfx2;
 
+  (void) state;
+  (void) tilingType;
   // define a Type 3 font
   writePS("8 dict begin\n");
   writePS("/FontType 3 def\n");
@@ -5189,6 +5193,7 @@ void PSOutputDev::tilingPatternFillL2(GfxState *state, Gfx *gfx,
   PDFRectangle box;
   Gfx *gfx2;
 
+  (void) state;
   // switch to pattern space
   writePSFmt("gsave [{0:.6g} {1:.6g} {2:.6g} {3:.6g} {4:.6g} {5:.6g}] concat\n",
 	     mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);
@@ -5244,6 +5249,7 @@ GBool PSOutputDev::functionShadedFill(GfxState *state,
   double *mat;
   int i;
 
+  (void) state;
   if (level == psLevel2Sep || level == psLevel3Sep) {
     if (shading->getColorSpace()->getMode() != csDeviceCMYK) {
       return gFalse;
@@ -5872,6 +5878,7 @@ void PSOutputDev::drawString(GfxState *state, GString *s) {
 }
 
 void PSOutputDev::endTextObject(GfxState *state) {
+  (void) state;
   if (haveTextClip) {
     writePS("Tclip\n");
     haveTextClip = gFalse;
@@ -5884,6 +5891,7 @@ void PSOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
 				GBool inlineImg, GBool interpolate) {
   int len;
 
+  (void) interpolate;
   len = height * ((width + 7) / 8);
   switch (level) {
   case psLevel1:
@@ -5912,6 +5920,7 @@ void PSOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 			    GBool interpolate) {
   int len;
 
+  (void) interpolate;
   len = height * ((width * colorMap->getNumPixelComps() *
 		   colorMap->getBits() + 7) / 8);
   switch (level) {
@@ -5948,6 +5957,7 @@ void PSOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,
 				  GBool maskInvert, GBool interpolate) {
   int len;
 
+  (void) interpolate;
   len = height * ((width * colorMap->getNumPixelComps() *
 		   colorMap->getBits() + 7) / 8);
   switch (level) {
@@ -6096,6 +6106,9 @@ void PSOutputDev::doImageL1Sep(GfxState *state, GfxImageColorMap *colorMap,
   GfxCMYK cmyk;
   int x, y, i, comp;
 
+  (void) invert;
+  (void) inlineImg;
+  (void) len;
   // width, height, matrix, bits per component
   writePSFmt("{0:d} {1:d} 8 [{2:d} 0 0 {3:d} 0 {4:d}] pdfIm1Sep\n",
 	     width, height,
@@ -6201,7 +6214,7 @@ void PSOutputDev::doImageL2(Object *ref, GfxState *state,
       }
       str2->reset();
       col = 0;
-      writePS((char *)(useASCIIHex ? "[<" : "[<~"));
+      writePS(useASCIIHex ? "[<" : "[<~");
       do {
 	do {
 	  c = str2->getChar();
@@ -6231,11 +6244,11 @@ void PSOutputDev::doImageL2(Object *ref, GfxState *state,
 	// chunks are 1 or 5 bytes each, so we have to stop at 245
 	// but make it 240 just to be safe
 	if (col > 240) {
-	  writePS((char *)(useASCIIHex ? ">\n<" : "~>\n<~"));
+	  writePS(useASCIIHex ? ">\n<" : "~>\n<~");
 	  col = 0;
 	}
       } while (c != (useASCIIHex ? '>' : '~') && c != EOF);
-      writePS((char *)(useASCIIHex ? ">\n" : "~>\n"));
+      writePS(useASCIIHex ? ">\n" : "~>\n");
       // add an extra entry because the LZWDecode/RunLengthDecode
       // filter may read past the end
       writePS("<>]\n");
@@ -6393,7 +6406,7 @@ void PSOutputDev::doImageL2(Object *ref, GfxState *state,
 
     // end of image dictionary
     writePS(">>\n");
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
     if (opi13Nest) {
       if (inlineImg) {
 	// this can't happen -- OPI dictionaries are in XObjects
@@ -6440,7 +6453,7 @@ void PSOutputDev::doImageL2(Object *ref, GfxState *state,
     // add newline and trailer to the end
     writePSChar('\n');
     writePS("%-EOD-\n");
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
     if (opi13Nest) {
       writePS("%%EndData\n");
     }
@@ -6897,7 +6910,7 @@ void PSOutputDev::doImageL3(Object *ref, GfxState *state,
       }
       str2->reset();
       col = 0;
-      writePS((char *)(useASCIIHex ? "[<" : "[<~"));
+      writePS(useASCIIHex ? "[<" : "[<~");
       do {
 	do {
 	  c = str2->getChar();
@@ -6927,11 +6940,11 @@ void PSOutputDev::doImageL3(Object *ref, GfxState *state,
 	// chunks are 1 or 5 bytes each, so we have to stop at 245
 	// but make it 240 just to be safe
 	if (col > 240) {
-	  writePS((char *)(useASCIIHex ? ">\n<" : "~>\n<~"));
+	  writePS(useASCIIHex ? ">\n<" : "~>\n<~");
 	  col = 0;
 	}
       } while (c != (useASCIIHex ? '>' : '~') && c != EOF);
-      writePS((char *)(useASCIIHex ? ">\n" : "~>\n"));
+      writePS(useASCIIHex ? ">\n" : "~>\n");
       // add an extra entry because the LZWDecode/RunLengthDecode
       // filter may read past the end
       writePS("<>]\n");
@@ -7219,6 +7232,8 @@ void PSOutputDev::dumpColorSpaceL2(GfxState *state, GfxColorSpace *colorSpace,
 void PSOutputDev::dumpDeviceGrayColorSpace(GfxDeviceGrayColorSpace *cs,
 					   GBool genXform, GBool updateColors,
 					   GBool map01) {
+  (void) cs;
+  (void) map01;
   writePS("/DeviceGray");
   if (genXform) {
     writePS(" {}");
@@ -7231,6 +7246,7 @@ void PSOutputDev::dumpDeviceGrayColorSpace(GfxDeviceGrayColorSpace *cs,
 void PSOutputDev::dumpCalGrayColorSpace(GfxCalGrayColorSpace *cs,
 					GBool genXform, GBool updateColors,
 					GBool map01) {
+  (void) map01;
   writePS("[/CIEBasedA <<\n");
   writePSFmt(" /DecodeA {{{0:.4g} exp}} bind\n", cs->getGamma());
   writePSFmt(" /MatrixA [{0:.4g} {1:.4g} {2:.4g}]\n",
@@ -7251,6 +7267,8 @@ void PSOutputDev::dumpCalGrayColorSpace(GfxCalGrayColorSpace *cs,
 void PSOutputDev::dumpDeviceRGBColorSpace(GfxDeviceRGBColorSpace *cs,
 					  GBool genXform, GBool updateColors,
 					  GBool map01) {
+  (void) cs;
+  (void) map01;
   writePS("/DeviceRGB");
   if (genXform) {
     writePS(" {}");
@@ -7263,6 +7281,7 @@ void PSOutputDev::dumpDeviceRGBColorSpace(GfxDeviceRGBColorSpace *cs,
 void PSOutputDev::dumpCalRGBColorSpace(GfxCalRGBColorSpace *cs,
 				       GBool genXform, GBool updateColors,
 				       GBool map01) {
+  (void) map01;
   writePS("[/CIEBasedABC <<\n");
   writePSFmt(" /DecodeABC [{{{0:.4g} exp}} bind {{{1:.4g} exp}} bind {{{2:.4g} exp}} bind]\n",
 	     cs->getGammaR(), cs->getGammaG(), cs->getGammaB());
@@ -7286,6 +7305,8 @@ void PSOutputDev::dumpCalRGBColorSpace(GfxCalRGBColorSpace *cs,
 void PSOutputDev::dumpDeviceCMYKColorSpace(GfxDeviceCMYKColorSpace *cs,
 					   GBool genXform, GBool updateColors,
 					   GBool map01) {
+  (void) cs;
+  (void) map01;
   writePS("/DeviceCMYK");
   if (genXform) {
     writePS(" {}");
@@ -7342,6 +7363,7 @@ void PSOutputDev::dumpICCBasedColorSpace(GfxState *state,
 					 GBool map01) {
   // there is no transform function to the alternate color space, so
   // we can use it directly
+  (void) map01;
   dumpColorSpaceL2(state, cs->getAlt(), genXform, updateColors, gFalse);
 }
 
@@ -7362,6 +7384,7 @@ void PSOutputDev::dumpIndexedColorSpace(GfxState *state,
   int byte;
   int i, j, k;
 
+  (void) map01;
   baseCS = cs->getBase();
   writePS("[/Indexed ");
   dumpColorSpaceL2(state, baseCS, gFalse, updateColors, gTrue);
@@ -7438,6 +7461,7 @@ void PSOutputDev::dumpSeparationColorSpace(GfxState *state,
 					   GfxSeparationColorSpace *cs,
 					   GBool genXform, GBool updateColors,
 					   GBool map01) {
+  (void) map01;
   writePS("[/Separation ");
   writePSString(cs->getName());
   writePS(" ");
@@ -7471,6 +7495,7 @@ void PSOutputDev::dumpDeviceNColorSpaceL3(GfxState *state,
   GString *tint;
   int i;
 
+  (void) map01;
   writePS("[/DeviceN [\n");
   for (i = 0; i < cs->getNComps(); ++i) {
     writePSString(cs->getColorantName(i));
@@ -7603,7 +7628,7 @@ GString *PSOutputDev::createDeviceNTintFunc(GfxDeviceNColorSpace *cs) {
   return tint;
 }
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
 void PSOutputDev::opiBegin(GfxState *state, Dict *opiDict) {
   Object dict;
 
@@ -8030,9 +8055,10 @@ GBool PSOutputDev::getFileSpec(Object *fileSpec, Object *fileName) {
   }
   return gFalse;
 }
-#endif // OPI_SUPPORT
+#endif /* OPI_SUPPORT */
 
 void PSOutputDev::type3D0(GfxState *state, double wx, double wy) {
+  (void) state;
   writePSFmt("{0:.6g} {1:.6g} setcharwidth\n", wx, wy);
   writePS("q\n");
   t3NeedsRestore = gTrue;
@@ -8041,6 +8067,7 @@ void PSOutputDev::type3D0(GfxState *state, double wx, double wy) {
 
 void PSOutputDev::type3D1(GfxState *state, double wx, double wy,
 			  double llx, double lly, double urx, double ury) {
+  (void) state;
   if (t3String) {
     error(errSyntaxError, -1, "Multiple 'd1' operators in Type 3 CharProc");
     return;
@@ -8266,9 +8293,9 @@ void PSOutputDev::writePSFmt(const char *fmt, ...) {
 
   va_start(args, fmt);
   if (t3String) {
-    t3String->appendfv((char *)fmt, args);
+    t3String->appendfv(fmt, args);
   } else {
-    buf = GString::formatv((char *)fmt, args);
+    buf = GString::formatv(fmt, args);
     (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
     delete buf;
   }
diff --git a/xpdf/PSOutputDev.h b/xpdf/PSOutputDev.h
index 66057a7..cdcd7af 100644
--- a/xpdf/PSOutputDev.h
+++ b/xpdf/PSOutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stddef.h>
 #include "config.h"
 #include "Object.h"
@@ -241,7 +237,7 @@ public:
 			       Stream *maskStr, int maskWidth, int maskHeight,
 			       GBool maskInvert, GBool interpolate);
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   //----- OPI functions
   virtual void opiBegin(GfxState *state, Dict *opiDict);
   virtual void opiEnd(GfxState *state, Dict *opiDict);
@@ -408,7 +404,7 @@ private:
 			       GBool genXform, GBool updateColors,
 			       GBool map01);
   GString *createDeviceNTintFunc(GfxDeviceNColorSpace *cs);
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   void opiBegin20(GfxState *state, Dict *dict);
   void opiBegin13(GfxState *state, Dict *dict);
   void opiTransform(GfxState *state, double x0, double y0,
@@ -498,7 +494,7 @@ private:
   GBool t3Cacheable;		// cleared if char is not cacheable
   GBool t3NeedsRestore;		// set if a 'q' operator was issued
 
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   int opi13Nest;		// nesting level of OPI 1.3 objects
   int opi20Nest;		// nesting level of OPI 2.0 objects
 #endif
diff --git a/xpdf/PSTokenizer.cc b/xpdf/PSTokenizer.cc
index bbdb0ec..dbf0a79 100644
--- a/xpdf/PSTokenizer.cc
+++ b/xpdf/PSTokenizer.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include "gmempp.h"
@@ -21,7 +17,7 @@
 
 // A '1' in this array means the character is white space.  A '1' or
 // '2' means the character ends a name or command.
-static char specialChars[256] = {
+static char const specialChars[256] = {
   1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,   // 0x
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 1x
   1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,   // 2x
diff --git a/xpdf/PSTokenizer.h b/xpdf/PSTokenizer.h
index 4d5ee97..3f3c8f4 100644
--- a/xpdf/PSTokenizer.h
+++ b/xpdf/PSTokenizer.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 //------------------------------------------------------------------------
diff --git a/xpdf/Page.cc b/xpdf/Page.cc
index fa1c201..9e70e85 100644
--- a/xpdf/Page.cc
+++ b/xpdf/Page.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include "gmempp.h"
 #include "GlobalParams.h"
diff --git a/xpdf/Page.h b/xpdf/Page.h
index ee30a1a..2d8b13f 100644
--- a/xpdf/Page.h
+++ b/xpdf/Page.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Object.h"
 
 class Dict;
diff --git a/xpdf/Parser.cc b/xpdf/Parser.cc
index 87e3fc5..04e887d 100644
--- a/xpdf/Parser.cc
+++ b/xpdf/Parser.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stddef.h>
 #include <string.h>
 #include "gmempp.h"
diff --git a/xpdf/Parser.h b/xpdf/Parser.h
index bfe5a52..6e175eb 100644
--- a/xpdf/Parser.h
+++ b/xpdf/Parser.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Lexer.h"
 
 //------------------------------------------------------------------------
diff --git a/xpdf/PreScanOutputDev.cc b/xpdf/PreScanOutputDev.cc
index d6f4033..aabe472 100644
--- a/xpdf/PreScanOutputDev.cc
+++ b/xpdf/PreScanOutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <math.h>
 #include "gmempp.h"
 #include "GlobalParams.h"
@@ -33,6 +29,8 @@ PreScanOutputDev::~PreScanOutputDev() {
 }
 
 void PreScanOutputDev::startPage(int pageNum, GfxState *state) {
+	(void) pageNum;
+	(void) state;
 }
 
 void PreScanOutputDev::endPage() {
@@ -68,6 +66,13 @@ void PreScanOutputDev::tilingPatternFill(GfxState *state, Gfx *gfx,
 					 double *mat, double *bbox,
 					 int x0, int y0, int x1, int y1,
 					 double xStep, double yStep) {
+  (void) tilingType;
+  (void) x0;
+  (void) y0;
+  (void) x1;
+  (void) y1;
+  (void) xStep;
+  (void) yStep;
   if (paintType == 1) {
     gfx->drawForm(strRef, resDict, mat, bbox);
   } else {
@@ -121,10 +126,12 @@ GBool PreScanOutputDev::radialShadedFill(GfxState *state,
 void PreScanOutputDev::clip(GfxState *state) {
   //~ check for a rectangle "near" the edge of the page;
   //~   else set gdi to false
+  (void) state;
 }
 
 void PreScanOutputDev::eoClip(GfxState *state) {
   //~ see clip()
+  (void) state;
 }
 
 void PreScanOutputDev::beginStringOp(GfxState *state) {
@@ -162,21 +169,36 @@ void PreScanOutputDev::beginStringOp(GfxState *state) {
 }
 
 void PreScanOutputDev::endStringOp(GfxState *state) {
+  (void) state;
 }
 
 GBool PreScanOutputDev::beginType3Char(GfxState *state, double x, double y,
 				       double dx, double dy,
 				       CharCode code, Unicode *u, int uLen) {
   // return false so all Type 3 chars get rendered (no caching)
+  (void) state;
+  (void) x;
+  (void) y;
+  (void) dx;
+  (void) dy;
+  (void) code;
+  (void) u;
+  (void) uLen;
   return gFalse;
 }
 
 void PreScanOutputDev::endType3Char(GfxState *state) {
+  (void) state;
 }
 
 void PreScanOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
 				     int width, int height, GBool invert,
 				     GBool inlineImg, GBool interpolate) {
+  (void) state;
+  (void) ref;
+  (void) invert;
+  (void) inlineImg;
+  (void) interpolate;
   check(state, state->getFillColorSpace(), state->getFillColor(),
 	state->getFillOpacity(), state->getBlendMode());
   if (state->getFillColorSpace()->getMode() == csPattern) {
@@ -198,6 +220,14 @@ void PreScanOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 				 GBool interpolate) {
   GfxColorSpace *colorSpace;
 
+  (void) ref;
+  (void) str;
+  (void) width;
+  (void) height;
+  (void) colorMap;
+  (void) maskColors;
+  (void) inlineImg;
+  (void) interpolate;
   colorSpace = colorMap->getColorSpace();
   if (colorSpace->getMode() == csIndexed) {
     colorSpace = ((GfxIndexedColorSpace *)colorSpace)->getBase();
@@ -234,6 +264,16 @@ void PreScanOutputDev::drawMaskedImage(GfxState *state, Object *ref,
 				       GBool maskInvert, GBool interpolate) {
   GfxColorSpace *colorSpace;
 
+  (void) ref;
+  (void) str;
+  (void) width;
+  (void) height;
+  (void) colorMap;
+  (void) maskStr;
+  (void) maskWidth;
+  (void) maskHeight;
+  (void) maskInvert;
+  (void) interpolate;
   colorSpace = colorMap->getColorSpace();
   if (colorSpace->getMode() == csIndexed) {
     colorSpace = ((GfxIndexedColorSpace *)colorSpace)->getBase();
@@ -264,6 +304,18 @@ void PreScanOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
 					   double *matte, GBool interpolate) {
   GfxColorSpace *colorSpace;
 
+  (void) state;
+  (void) ref;
+  (void) str;
+  (void) width;
+  (void) height;
+  (void) colorMap;
+  (void) maskStr;
+  (void) maskWidth;
+  (void) maskHeight;
+  (void) maskColorMap;
+  (void) matte;
+  (void) interpolate;
   colorSpace = colorMap->getColorSpace();
   if (colorSpace->getMode() == csIndexed) {
     colorSpace = ((GfxIndexedColorSpace *)colorSpace)->getBase();
@@ -282,6 +334,12 @@ void PreScanOutputDev::beginTransparencyGroup(
 			   GfxColorSpace *blendingColorSpace,
 			   GBool isolated, GBool knockout,
 			   GBool forSoftMask) {
+  (void) state;
+  (void) bbox;
+  (void) blendingColorSpace;
+  (void) isolated;
+  (void) knockout;
+  (void) forSoftMask;
   transparency = gTrue;
   gdi = gFalse;
 }
diff --git a/xpdf/PreScanOutputDev.h b/xpdf/PreScanOutputDev.h
index 882d8ef..ef2641c 100644
--- a/xpdf/PreScanOutputDev.h
+++ b/xpdf/PreScanOutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "GfxState.h"
 #include "OutputDev.h"
diff --git a/xpdf/SecurityHandler.cc b/xpdf/SecurityHandler.cc
index 4a7d095..2a139a0 100644
--- a/xpdf/SecurityHandler.cc
+++ b/xpdf/SecurityHandler.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmempp.h"
 #include "GString.h"
 #include "PDFDoc.h"
diff --git a/xpdf/SecurityHandler.h b/xpdf/SecurityHandler.h
index 6346233..05e58cf 100644
--- a/xpdf/SecurityHandler.h
+++ b/xpdf/SecurityHandler.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "Object.h"
 
diff --git a/xpdf/SplashOutputDev.cc b/xpdf/SplashOutputDev.cc
index df2e2b2..3279347 100644
--- a/xpdf/SplashOutputDev.cc
+++ b/xpdf/SplashOutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include <math.h>
 #include <limits.h>
@@ -58,7 +54,7 @@ extern "C" int unlink(char *filename);
 
 // Map StrokeAdjustMode (from GlobalParams) to SplashStrokeAdjustMode
 // (for Splash).
-static SplashStrokeAdjustMode mapStrokeAdjustMode[3] = {
+static SplashStrokeAdjustMode const mapStrokeAdjustMode[3] = {
   splashStrokeAdjustOff,
   splashStrokeAdjustNormal,
   splashStrokeAdjustCAD
@@ -321,7 +317,7 @@ static void splashOutBlendHue(SplashColorPtr src, SplashColorPtr dest,
     setLum(r0, g0, b0, getLum(dest[0], dest[1], dest[2]),
 	   &blend[0], &blend[1], &blend[2]);
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     // NB: inputs have already been converted to additive mode
     setSat(src[0], src[1], src[2], getSat(dest[0], dest[1], dest[2]),
@@ -351,7 +347,7 @@ static void splashOutBlendSaturation(SplashColorPtr src, SplashColorPtr dest,
     setLum(r0, g0, b0, getLum(dest[0], dest[1], dest[2]),
 	   &blend[0], &blend[1], &blend[2]);
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     // NB: inputs have already been converted to additive mode
     setSat(dest[0], dest[1], dest[2], getSat(src[0], src[1], src[2]),
@@ -377,7 +373,7 @@ static void splashOutBlendColor(SplashColorPtr src, SplashColorPtr dest,
     setLum(src[0], src[1], src[2], getLum(dest[0], dest[1], dest[2]),
 	   &blend[0], &blend[1], &blend[2]);
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     // NB: inputs have already been converted to additive mode
     setLum(src[0], src[1], src[2], getLum(dest[0], dest[1], dest[2]),
@@ -402,7 +398,7 @@ static void splashOutBlendLuminosity(SplashColorPtr src, SplashColorPtr dest,
     setLum(dest[0], dest[1], dest[2], getLum(src[0], src[1], src[2]),
 	   &blend[0], &blend[1], &blend[2]);
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     // NB: inputs have already been converted to additive mode
     setLum(dest[0], dest[1], dest[2], getLum(src[0], src[1], src[2]),
@@ -414,7 +410,7 @@ static void splashOutBlendLuminosity(SplashColorPtr src, SplashColorPtr dest,
 }
 
 // NB: This must match the GfxBlendMode enum defined in GfxState.h.
-SplashBlendFunc splashOutBlendFuncs[] = {
+static SplashBlendFunc const splashOutBlendFuncs[] = {
   NULL,
   &splashOutBlendMultiply,
   &splashOutBlendScreen,
@@ -718,7 +714,7 @@ void SplashOutputDev::startDoc(XRef *xrefA) {
     delete fontEngine;
   }
   fontEngine = new SplashFontEngine(
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
 				    globalParams->getEnableFreeType(),
 				    globalParams->getDisableFreeTypeHinting()
 				      ? splashFTNoHinting : 0,
@@ -738,6 +734,7 @@ void SplashOutputDev::startPage(int pageNum, GfxState *state) {
   SplashCoord mat[6];
   SplashColor color;
 
+  (void) pageNum;
   if (state) {
     setupScreenParams(state->getHDPI(), state->getVDPI());
     w = (int)(state->getPageWidth() + 0.5);
@@ -786,7 +783,7 @@ void SplashOutputDev::startPage(int pageNum, GfxState *state) {
   case splashModeBGR8:
     color[0] = color[1] = color[2] = 0;
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     color[0] = color[1] = color[2] = color[3] = 0;
     break;
@@ -816,6 +813,7 @@ void SplashOutputDev::endPage() {
 }
 
 void SplashOutputDev::saveState(GfxState *state) {
+  (void) state;
   splash->saveState();
   if (t3GlyphStack && !t3GlyphStack->haveDx) {
     t3GlyphStack->doNotCache = gTrue;
@@ -825,6 +823,7 @@ void SplashOutputDev::saveState(GfxState *state) {
 }
 
 void SplashOutputDev::restoreState(GfxState *state) {
+  (void) state;
   splash->restoreState();
   needFontUpdate = gTrue;
   if (t3GlyphStack && !t3GlyphStack->haveDx) {
@@ -853,6 +852,12 @@ void SplashOutputDev::updateCTM(GfxState *state, double m11, double m12,
   double *ctm;
   SplashCoord mat[6];
 
+  (void) m11;
+  (void) m12;
+  (void) m21;
+  (void) m22;
+  (void) m31;
+  (void) m32;
   ctm = state->getCTM();
   mat[0] = (SplashCoord)ctm[0];
   mat[1] = (SplashCoord)ctm[1];
@@ -888,6 +893,7 @@ void SplashOutputDev::updateFlatness(GfxState *state) {
       // with a fairly small flatness value
   splash->setFlatness(state->getFlatness());
 #endif
+  (void) state;
 }
 
 void SplashOutputDev::updateLineJoin(GfxState *state) {
@@ -907,6 +913,7 @@ void SplashOutputDev::updateLineWidth(GfxState *state) {
 }
 
 void SplashOutputDev::updateStrokeAdjust(GfxState *state) {
+  (void) state;
 #if 0 // the SA parameter supposedly defaults to false, but Acrobat
       // apparently hardwires it to true
   if (state->getStrokeAdjust()) {
@@ -925,7 +932,7 @@ void SplashOutputDev::updateStrokeAdjust(GfxState *state) {
 void SplashOutputDev::updateFillColor(GfxState *state) {
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
 
@@ -940,7 +947,7 @@ void SplashOutputDev::updateFillColor(GfxState *state) {
     state->getFillRGB(&rgb);
     splash->setFillPattern(getColor(&rgb));
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     state->getFillCMYK(&cmyk);
     splash->setFillPattern(getColor(&cmyk));
@@ -952,7 +959,7 @@ void SplashOutputDev::updateFillColor(GfxState *state) {
 void SplashOutputDev::updateStrokeColor(GfxState *state) {
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
 
@@ -967,7 +974,7 @@ void SplashOutputDev::updateStrokeColor(GfxState *state) {
     state->getStrokeRGB(&rgb);
     splash->setStrokePattern(getColor(&rgb));
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     state->getStrokeCMYK(&cmyk);
     splash->setStrokePattern(getColor(&cmyk));
@@ -991,7 +998,7 @@ SplashPattern *SplashOutputDev::getColor(GfxRGB *rgb) {
   return new SplashSolidColor(color);
 }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 SplashPattern *SplashOutputDev::getColor(GfxCMYK *cmyk) {
   SplashColor color;
 
@@ -1025,7 +1032,7 @@ void SplashOutputDev::getColor(GfxRGB *rgb, SplashColorPtr color) {
   color[2] = colToByte(b);
 }
 
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 void SplashOutputDev::getColor(GfxCMYK *cmyk, SplashColorPtr color) {
   color[0] = colToByte(cmyk->c);
   color[1] = colToByte(cmyk->m);
@@ -1041,7 +1048,7 @@ void SplashOutputDev::setOverprintMask(GfxState *state,
 				       GBool overprintFlag,
 				       int overprintMode,
 				       GfxColor *singleColor) {
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   Guint mask;
   GfxCMYK cmyk;
 
@@ -1138,6 +1145,7 @@ void SplashOutputDev::updateTransfer(GfxState *state) {
 }
 
 void SplashOutputDev::updateFont(GfxState *state) {
+  (void) state;
   needFontUpdate = gTrue;
 }
 
@@ -1151,7 +1159,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
   FoFiTrueType *ff;
   Ref embRef;
   Object refObj, strObj;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf;
   FILE *extFontFile;
 #else
@@ -1172,7 +1180,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
 
   needFontUpdate = gFalse;
   font = NULL;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   fontBuf = NULL;
 #else
   tmpFileName = NULL;
@@ -1217,7 +1225,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
     // embedded font
     if (fontLoc->locType == gfxFontLocEmbedded) {
       gfxFont->getEmbeddedFontID(&embRef);
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
       fontBuf = new GString();
       refObj.initRef(embRef.num, embRef.gen);
       refObj.fetch(xref, &strObj);
@@ -1262,7 +1270,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
 
     // external font
     } else { // gfxFontLocExternal
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
       if (!(extFontFile = fopen(fontLoc->path->getCString(), "rb"))) {
 	error(errSyntaxError, -1, "Couldn't open external font file '{0:t}'",
 	      fontLoc->path);
@@ -1291,13 +1299,13 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
     case fontType1:
       if (!(fontFile = fontEngine->loadType1Font(
 		   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 		   fontBuf,
 #else
 		   fileName->getCString(),
 		   fileName == tmpFileName,
 #endif
-		   (const char **)((Gfx8BitFont *)gfxFont)->getEncoding()))) {
+		   const_cast<const char **>(((Gfx8BitFont *)gfxFont)->getEncoding())))) {
 	error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1308,13 +1316,13 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
     case fontType1C:
       if (!(fontFile = fontEngine->loadType1CFont(
 		   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 		   fontBuf,
 #else
 		   fileName->getCString(),
 		   fileName == tmpFileName,
 #endif
-		   (const char **)((Gfx8BitFont *)gfxFont)->getEncoding()))) {
+		   const_cast<const char **>(((Gfx8BitFont *)gfxFont)->getEncoding())))) {
 	error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1325,13 +1333,13 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
     case fontType1COT:
       if (!(fontFile = fontEngine->loadOpenTypeT1CFont(
 		   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 		   fontBuf,
 #else
 		   fileName->getCString(),
 		   fileName == tmpFileName,
 #endif
-		   (const char **)((Gfx8BitFont *)gfxFont)->getEncoding()))) {
+		   const_cast<const char **>(((Gfx8BitFont *)gfxFont)->getEncoding())))) {
 	error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1341,7 +1349,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       break;
     case fontTrueType:
     case fontTrueTypeOT:
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
       if ((ff = FoFiTrueType::make(fontBuf->getCString(), fontBuf->getLength(),
 				   fontNum))) {
 #else
@@ -1367,7 +1375,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       }
       if (!(fontFile = fontEngine->loadTrueTypeFont(
 			   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			   fontBuf,
 #else
 			   fileName->getCString(),
@@ -1397,7 +1405,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       }
       if (!(fontFile = fontEngine->loadCIDFont(
 			   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			   fontBuf,
 #else
 			   fileName->getCString(),
@@ -1425,7 +1433,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       } else if (globalParams->getMapExtTrueTypeFontsViaUnicode()) {
 	// create a CID-to-GID mapping, via Unicode
 	if ((ctu = ((GfxCIDFont *)gfxFont)->getToUnicode())) {
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 	  if ((ff = FoFiTrueType::make(fontBuf->getCString(),
 				       fontBuf->getLength(), fontNum))) {
 #else
@@ -1468,7 +1476,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       }
       if (!(fontFile = fontEngine->loadOpenTypeCFFFont(
 			   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			   fontBuf,
 #else
 			   fileName->getCString(),
@@ -1497,7 +1505,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
 		 !((GfxCIDFont *)gfxFont)->usesIdentityEncoding()) {
 	// create a CID-to-GID mapping, via Unicode
 	if ((ctu = ((GfxCIDFont *)gfxFont)->getToUnicode())) {
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 	  if ((ff = FoFiTrueType::make(fontBuf->getCString(),
 				       fontBuf->getLength(), fontNum))) {
 #else
@@ -1540,7 +1548,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
       }
       if (!(fontFile = fontEngine->loadTrueTypeFont(
 			   id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 			   fontBuf,
 #else
 			   fileName->getCString(),
@@ -1624,7 +1632,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
   mat[2] = m21;  mat[3] = m22;
   font = fontEngine->getFont(fontFile, mat, splash->getMatrix());
 
-#if !LOAD_FONTS_FROM_MEM
+#ifndef LOAD_FONTS_FROM_MEM
   if (tmpFileName) {
     delete tmpFileName;
   }
@@ -1634,7 +1642,7 @@ void SplashOutputDev::doUpdateFont(GfxState *state) {
  err2:
   delete id;
  err1:
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   if (fontBuf) {
     delete fontBuf;
   }
@@ -1711,6 +1719,7 @@ void SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfx,
   int ixMin, ixMax, iyMin, iyMax, ix, iy, x, y;
   int i;
 
+  (void) paintType;
   // Notes:
   // - PTM = pattern matrix = transform from pattern space to default
   //         user space (default for most recent page or form)
@@ -2653,7 +2662,7 @@ void SplashOutputDev::computeShadingColor(GfxState *state,
 					  SplashColorPtr sColor) {
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
 
@@ -2667,7 +2676,7 @@ void SplashOutputDev::computeShadingColor(GfxState *state,
     state->getFillRGB(&rgb);
     getColor(&rgb, sColor);
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     state->getFillCMYK(&cmyk);
     getColor(&cmyk, sColor);
@@ -2714,6 +2723,7 @@ SplashPath *SplashOutputDev::convertPath(GfxState *state, GfxPath *path,
   GfxSubpath *subpath;
   int n, i, j;
 
+  (void) state;
   n = dropEmptySubpaths ? 1 : 0;
   sPath = new SplashPath();
   for (i = 0; i < path->getNumSubpaths(); ++i) {
@@ -2757,6 +2767,11 @@ void SplashOutputDev::drawChar(GfxState *state, double x, double y,
   double m[4];
   GBool horiz;
 
+  (void) dx;
+  (void) dy;
+  (void) nBytes;
+  (void) u;
+  (void) uLen;
   if (skipHorizText || skipRotatedText) {
     state->getFontTransMat(&m[0], &m[1], &m[2], &m[3]);
     horiz = m[0] > 0 && fabs(m[1]) < 0.001 &&
@@ -2868,6 +2883,12 @@ GBool SplashOutputDev::beginType3Char(GfxState *state, double x, double y,
   double x1, y1, xMin, yMin, xMax, yMax, xt, yt;
   int render, i, j;
 
+  (void) x;
+  (void) y;
+  (void) dx;
+  (void) dy;
+  (void) u;
+  (void) uLen;
   if (skipHorizText || skipRotatedText) {
     state->getFontTransMat(&m[0], &m[1], &m[2], &m[3]);
     horiz = m[0] > 0 && fabs(m[1]) < 0.001 &&
@@ -3025,6 +3046,9 @@ void SplashOutputDev::endType3Char(GfxState *state) {
 }
 
 void SplashOutputDev::type3D0(GfxState *state, double wx, double wy) {
+  (void) state;
+  (void) wx;
+  (void) wy;
   if (!t3GlyphStack) {
     error(errSyntaxError, -1,
 	  "Encountered d0 operator outside of Type 3 CharProc");
@@ -3041,6 +3065,8 @@ void SplashOutputDev::type3D1(GfxState *state, double wx, double wy,
   double xt, yt, xMin, xMax, yMin, yMax, x1, y1;
   int i, j;
 
+  (void) wx;
+  (void) wy;
   if (!t3GlyphStack) {
     error(errSyntaxError, -1,
 	  "Encountered d1 operator outside of Type 3 CharProc");
@@ -3163,6 +3189,7 @@ void SplashOutputDev::drawType3Glyph(GfxState *state, T3FontCache *t3Font,
 				     T3FontCacheTag *tag, Guchar *data) {
   SplashGlyphBitmap glyph;
 
+  (void) tag;
   setOverprintMask(state, state->getFillColorSpace(),
 		   state->getFillOverprint(), state->getOverprintMode(),
 		   state->getFillColor());
@@ -3177,6 +3204,7 @@ void SplashOutputDev::drawType3Glyph(GfxState *state, T3FontCache *t3Font,
 }
 
 void SplashOutputDev::endTextObject(GfxState *state) {
+  (void) state;
   if (textClipPath) {
     splash->clipToPath(textClipPath, gFalse);
     delete textClipPath;
@@ -3215,6 +3243,7 @@ void SplashOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
   SplashCoord mat[6];
   SplashOutImageMaskData imgMaskData;
 
+  (void) ref;
   if (state->getFillColorSpace()->isNonMarking()) {
     return;
   }
@@ -3265,6 +3294,8 @@ void SplashOutputDev::setSoftMaskFromImageMask(GfxState *state,
   Splash *maskSplash;
   SplashColor maskColor;
 
+  (void) ref;
+  (void) inlineImg;
   ctm = state->getCTM();
   mat[0] = ctm[0];
   mat[1] = ctm[1];
@@ -3314,6 +3345,7 @@ GBool SplashOutputDev::imageSrc(void *data, SplashColorPtr colorLine,
   SplashColorPtr q, col;
   int x;
 
+  (void) alphaLine;
   if (imgData->y == imgData->height ||
       !(p = imgData->imgStr->getLine())) {
     memset(colorLine, 0,
@@ -3338,7 +3370,7 @@ GBool SplashOutputDev::imageSrc(void *data, SplashColorPtr colorLine,
 	*q++ = col[2];
       }
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       for (x = 0, q = colorLine; x < imgData->width; ++x, ++p) {
 	col = &imgData->lookup[4 * *p];
@@ -3362,7 +3394,7 @@ GBool SplashOutputDev::imageSrc(void *data, SplashColorPtr colorLine,
       imgData->colorMap->getRGBByteLine(p, colorLine, imgData->width,
 					imgData->ri);
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       imgData->colorMap->getCMYKByteLine(p, colorLine, imgData->width,
 					 imgData->ri);
@@ -3410,7 +3442,7 @@ GBool SplashOutputDev::alphaImageSrc(void *data, SplashColorPtr colorLine,
 	*q++ = col[2];
       }
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       for (x = 0, p = p0, q = colorLine; x < imgData->width; ++x, ++p) {
 	col = &imgData->lookup[4 * *p];
@@ -3434,7 +3466,7 @@ GBool SplashOutputDev::alphaImageSrc(void *data, SplashColorPtr colorLine,
       imgData->colorMap->getRGBByteLine(p0, colorLine, imgData->width,
 					imgData->ri);
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       imgData->colorMap->getCMYKByteLine(p0, colorLine, imgData->width,
 					 imgData->ri);
@@ -3472,12 +3504,13 @@ void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
   SplashImageSource src;
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   Guchar pix;
   int n, i;
 
+  (void) ref;
   setOverprintMask(state, colorMap->getColorSpace(),
 		   state->getFillOverprint(), state->getOverprintMode(),
 		   NULL);
@@ -3535,7 +3568,7 @@ void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 	imgData.lookup[3*i+2] = colToByte(rgb.b);
       }
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       imgData.lookup = (SplashColorPtr)gmallocn(n, 4);
       for (i = 0; i < n; ++i) {
@@ -3588,7 +3621,7 @@ GBool SplashOutputDev::maskedImageSrc(void *data, SplashColorPtr colorLine,
   SplashOutMaskedImageData *imgData = (SplashOutMaskedImageData *)data;
   Guchar *p, *aq;
   SplashColorPtr q, col;
-  static Guchar bitToByte[2] = {0x00, 0xff};
+  static Guchar const bitToByte[2] = {0x00, 0xff};
   Guchar *maskPtr;
   int maskShift;
   int x;
@@ -3639,7 +3672,7 @@ GBool SplashOutputDev::maskedImageSrc(void *data, SplashColorPtr colorLine,
 	*q++ = col[2];
       }
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       for (x = 0, q = colorLine; x < imgData->width; ++x, ++p) {
 	col = &imgData->lookup[4 * *p];
@@ -3663,7 +3696,7 @@ GBool SplashOutputDev::maskedImageSrc(void *data, SplashColorPtr colorLine,
       imgData->colorMap->getRGBByteLine(p, colorLine, imgData->width,
 					imgData->ri);
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       imgData->colorMap->getCMYKByteLine(p, colorLine, imgData->width,
 					 imgData->ri);
@@ -3695,7 +3728,7 @@ void SplashOutputDev::drawMaskedImage(GfxState *state, Object *ref,
   SplashColor maskColor;
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   Guchar pix;
@@ -3810,7 +3843,7 @@ void SplashOutputDev::drawMaskedImage(GfxState *state, Object *ref,
 	  imgData.lookup[3*i+2] = colToByte(rgb.b);
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	imgData.lookup = (SplashColorPtr)gmallocn(n, 4);
 	for (i = 0; i < n; ++i) {
@@ -3862,7 +3895,7 @@ GBool SplashOutputDev::softMaskMatteImageSrc(void *data,
   SplashColorPtr q;
   GfxRGB rgb;
   GfxGray gray;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   Guchar alpha;
@@ -3910,7 +3943,7 @@ GBool SplashOutputDev::softMaskMatteImageSrc(void *data,
 	*q++ = 0;
       }
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       if (alpha) {
 	imgData->colorMap->getCMYK(p, &cmyk, imgData->ri);
@@ -3961,12 +3994,13 @@ void SplashOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
   GfxColor matteColor;
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   Guchar pix;
   int n, i;
 
+  (void) ref;
   setOverprintMask(state, colorMap->getColorSpace(),
 		   state->getFillOverprint(), state->getOverprintMode(),
 		   NULL);
@@ -4025,7 +4059,7 @@ void SplashOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
       matteImgData.matte[1] = colToByte(rgb.g);
       matteImgData.matte[2] = colToByte(rgb.b);
       break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     case splashModeCMYK8:
       colorMap->getColorSpace()->getCMYK(&matteColor, &cmyk,
 					 state->getRenderingIntent());
@@ -4140,7 +4174,7 @@ void SplashOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
 	  imgData.lookup[3*i+2] = colToByte(rgb.b);
 	}
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	imgData.lookup = (SplashColorPtr)gmallocn(n, 4);
 	for (i = 0; i < n; ++i) {
@@ -4385,7 +4419,7 @@ void SplashOutputDev::beginTransparencyGroup(GfxState *state, double *bbox,
 		blendingColorSpace->getNComps() == 3)) {
       //~ does this need to use BGR8?
       colorMode = splashModeRGB8;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
     } else if (blendingColorSpace->getMode() == csDeviceCMYK ||
 	       (blendingColorSpace->getMode() == csICCBased &&
 		blendingColorSpace->getNComps() == 4)) {
@@ -4463,6 +4497,8 @@ void SplashOutputDev::paintTransparencyGroup(GfxState *state, double *bbox) {
   GBool isolated;
   int xSrc, ySrc, xDest, yDest, w, h;
 
+  (void) state;
+  (void) bbox;
   xSrc = transpGroupStack->modXMin;
   ySrc = transpGroupStack->modYMin;
   xDest = transpGroupStack->tx + transpGroupStack->modXMin;
@@ -4504,12 +4540,14 @@ void SplashOutputDev::setSoftMask(GfxState *state, double *bbox,
   SplashColorPtr p;
   GfxGray gray;
   GfxRGB rgb;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   double backdrop, backdrop2, lum, lum2;
   int tx, ty, x, y;
 
+  (void) state;
+  (void) bbox;
   tx = transpGroupStack->tx;
   ty = transpGroupStack->ty;
   tBitmap = transpGroupStack->tBitmap;
@@ -4549,7 +4587,7 @@ void SplashOutputDev::setSoftMask(GfxState *state, double *bbox,
 	color[2] = colToByte(rgb.b);
 	tSplash->compositeBackground(color);
 	break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
       case splashModeCMYK8:
 	transpGroupStack->blendingColorSpace->getCMYK(
 		    backdropColor, &cmyk, state->getRenderingIntent());
@@ -4601,7 +4639,7 @@ void SplashOutputDev::setSoftMask(GfxState *state, double *bbox,
 	          (0.59 / 255.0) * color[1] +
 	          (0.11 / 255.0) * color[2];
 	    break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 	  case splashModeCMYK8:
 	    lum = (1 - color[3] / 255.0)
 	          - (0.3 / 255.0) * color[0]
@@ -4640,6 +4678,7 @@ void SplashOutputDev::setSoftMask(GfxState *state, double *bbox,
 }
 
 void SplashOutputDev::clearSoftMask(GfxState *state) {
+  (void) state;
   splash->setSoftMask(NULL);
 }
 
@@ -4676,7 +4715,7 @@ void SplashOutputDev::clearModRegion() {
 void SplashOutputDev::setFillColor(int r, int g, int b) {
   GfxRGB rgb;
   GfxGray gray;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
 
@@ -4696,7 +4735,7 @@ void SplashOutputDev::setFillColor(int r, int g, int b) {
   case splashModeBGR8:
     splash->setFillPattern(getColor(&rgb));
     break;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   case splashModeCMYK8:
     cmyk.c = gfxColorComp1 - rgb.r;
     cmyk.m = gfxColorComp1 - rgb.g;
@@ -4712,7 +4751,7 @@ SplashFont *SplashOutputDev::getFont(GString *name, SplashCoord *textMatA) {
   Ref ref;
   SplashOutFontFileID *id;
   GfxFontLoc *fontLoc;
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
   GString *fontBuf;
   FILE *extFontFile;
   char blk[4096];
@@ -4748,7 +4787,7 @@ SplashFont *SplashOutputDev::getFont(GString *name, SplashCoord *textMatA) {
     if (!(fontLoc = GfxFont::locateBase14Font(name))) {
       return NULL;
     }
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
     fontBuf = NULL;
     if (fontLoc->fontType == fontType1 ||
 	fontLoc->fontType == fontTrueType) {
@@ -4766,7 +4805,7 @@ SplashFont *SplashOutputDev::getFont(GString *name, SplashCoord *textMatA) {
 #endif
     if (fontLoc->fontType == fontType1) {
       fontFile = fontEngine->loadType1Font(id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					   fontBuf,
 #else
 					   fontLoc->path->getCString(),
@@ -4774,7 +4813,7 @@ SplashFont *SplashOutputDev::getFont(GString *name, SplashCoord *textMatA) {
 #endif
 					   winAnsiEncoding);
     } else if (fontLoc->fontType == fontTrueType) {
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
       if (!(ff = FoFiTrueType::make(fontBuf->getCString(),
 				    fontBuf->getLength(),
 				    fontLoc->fontNum))) {
@@ -4810,7 +4849,7 @@ SplashFont *SplashOutputDev::getFont(GString *name, SplashCoord *textMatA) {
       }
       delete ff;
       fontFile = fontEngine->loadTrueTypeFont(id,
-#if LOAD_FONTS_FROM_MEM
+#ifdef LOAD_FONTS_FROM_MEM
 					      fontBuf,
 #else
 					      fontLoc->path->getCString(),
diff --git a/xpdf/SplashOutputDev.h b/xpdf/SplashOutputDev.h
index 12e8831..9916821 100644
--- a/xpdf/SplashOutputDev.h
+++ b/xpdf/SplashOutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "SplashTypes.h"
 #include "config.h"
@@ -249,12 +245,12 @@ private:
   void setupScreenParams(double hDPI, double vDPI);
   SplashPattern *getColor(GfxGray gray);
   SplashPattern *getColor(GfxRGB *rgb);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   SplashPattern *getColor(GfxCMYK *cmyk);
 #endif
   void getColor(GfxGray gray, SplashColorPtr color);
   void getColor(GfxRGB *rgb, SplashColorPtr color);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   void getColor(GfxCMYK *cmyk, SplashColorPtr color);
 #endif
   void setOverprintMask(GfxState *state, GfxColorSpace *colorSpace,
diff --git a/xpdf/Stream-CCITT.h b/xpdf/Stream-CCITT.h
index f82150a..f19afaf 100644
--- a/xpdf/Stream-CCITT.h
+++ b/xpdf/Stream-CCITT.h
@@ -33,7 +33,7 @@ struct CCITTCode {
 #define twoDimVertL3 8
 
 // 1-7 bit codes
-static CCITTCode twoDimTab1[128] = {
+static CCITTCode const twoDimTab1[128] = {
   {-1, -1}, {-1, -1},		        // 000000x
   {7, twoDimVertL3},		        // 0000010
   {7, twoDimVertR3},		        // 0000011
@@ -106,7 +106,7 @@ static CCITTCode twoDimTab1[128] = {
 //------------------------------------------------------------------------
 
 // 11-12 bit codes (upper 7 bits are 0)
-static CCITTCode whiteTab1[32] = {
+static const CCITTCode whiteTab1[32] = {
   {-1, -1},					// 00000
   {12, ccittEOL},				// 00001
   {-1, -1}, {-1, -1},				// 0001x
@@ -129,7 +129,7 @@ static CCITTCode whiteTab1[32] = {
 };
 
 // 1-9 bit codes
-static CCITTCode whiteTab2[512] = {
+static CCITTCode const whiteTab2[512] = {
   {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1},	// 0000000xx
   {8, 29}, {8, 29},				// 00000010x
   {8, 30}, {8, 30},				// 00000011x
@@ -298,7 +298,7 @@ static CCITTCode whiteTab2[512] = {
 //------------------------------------------------------------------------
 
 // 10-13 bit codes (upper 6 bits are 0)
-static CCITTCode blackTab1[128] = {
+static CCITTCode const blackTab1[128] = {
   {-1, -1}, {-1, -1},					// 000000000000x
   {12, ccittEOL}, {12, ccittEOL},			// 000000000001x
   {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1},		// 00000000001xx
@@ -360,7 +360,7 @@ static CCITTCode blackTab1[128] = {
 };
 
 // 7-12 bit codes (upper 4 bits are 0)
-static CCITTCode blackTab2[192] = {
+static CCITTCode const blackTab2[192] = {
   {8, 13}, {8, 13}, {8, 13}, {8, 13},			// 00000100xxxx
     {8, 13}, {8, 13}, {8, 13}, {8, 13},
     {8, 13}, {8, 13}, {8, 13}, {8, 13},
@@ -440,7 +440,7 @@ static CCITTCode blackTab2[192] = {
 };
 
 // 2-6 bit codes
-static CCITTCode blackTab3[64] = {
+static CCITTCode const blackTab3[64] = {
   {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1},		// 0000xx
   {6, 9},						// 000100
   {6, 8},						// 000101
diff --git a/xpdf/Stream.cc b/xpdf/Stream.cc
index 4e9a2dc..a18c62b 100644
--- a/xpdf/Stream.cc
+++ b/xpdf/Stream.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -26,7 +22,7 @@
 #include "gmem.h"
 #include "gmempp.h"
 #include "gfile.h"
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 #include "config.h"
@@ -122,6 +118,8 @@ Guint Stream::discardChars(Guint n) {
 }
 
 GString *Stream::getPSFilter(int psLevel, const char *indent) {
+  (void) psLevel;
+  (void) indent;
   return new GString();
 }
 
@@ -339,6 +337,8 @@ void FilterStream::close() {
 }
 
 void FilterStream::setPos(GFileOffset pos, int dir) {
+  (void) pos;
+  (void) dir;
   error(errInternal, -1, "Called setPos() on FilterStream");
 }
 
@@ -673,7 +673,7 @@ private:
 
   FILE *f;
   int refCnt;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GMutex mutex;
 #endif
 };
@@ -681,23 +681,23 @@ private:
 SharedFile::SharedFile(FILE *fA) {
   f = fA;
   refCnt = 1;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gInitMutex(&mutex);
 #endif
 }
 
 SharedFile::~SharedFile() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gDestroyMutex(&mutex);
 #endif
 }
 
 SharedFile *SharedFile::copy() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&mutex);
 #endif
   ++refCnt;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&mutex);
 #endif
   return this;
@@ -706,11 +706,11 @@ SharedFile *SharedFile::copy() {
 void SharedFile::free() {
   int newCount;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&mutex);
 #endif
   newCount = --refCnt;
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&mutex);
 #endif
   if (newCount == 0) {
@@ -721,12 +721,12 @@ void SharedFile::free() {
 int SharedFile::readBlock(char *buf, GFileOffset pos, int size) {
   int n;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&mutex);
 #endif
   gfseek(f, pos, SEEK_SET);
   n = (int)fread(buf, 1, size, f);
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&mutex);
 #endif
   return n;
@@ -735,12 +735,12 @@ int SharedFile::readBlock(char *buf, GFileOffset pos, int size) {
 GFileOffset SharedFile::getSize() {
   GFileOffset size;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&mutex);
 #endif
   gfseek(f, 0, SEEK_END);
   size = gftell(f);
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&mutex);
 #endif
   return size;
@@ -889,9 +889,9 @@ Stream *MemStream::makeSubStream(GFileOffset startA, GBool limited,
   MemStream *subStr;
   Guint newStart, newLength;
 
-  if (startA < start) {
+  if ((Guint)startA < start) {
     newStart = start;
-  } else if (startA > start + length) {
+  } else if ((Guint)startA > start + length) {
     newStart = start + (int)length;
   } else {
     newStart = (int)startA;
@@ -974,6 +974,10 @@ Stream *EmbedStream::copy() {
 
 Stream *EmbedStream::makeSubStream(GFileOffset start, GBool limitedA,
 				   GFileOffset lengthA, Object *dictA) {
+  (void) start;
+  (void) limitedA;
+  (void) lengthA;
+  (void) dictA;
   error(errInternal, -1, "Called makeSubStream() on EmbedStream");
   return NULL;
 }
@@ -997,14 +1001,16 @@ int EmbedStream::getBlock(char *blk, int size) {
   if (size <= 0) {
     return 0;
   }
-  if (limited && length < (Guint)size) {
-    size = (int)length;
+  if (limited && (Guint)length < (Guint)size) {
+    size = length;
   }
   length -= size;
   return str->getBlock(blk, size);
 }
 
 void EmbedStream::setPos(GFileOffset pos, int dir) {
+  (void) pos;
+  (void) dir;
   error(errInternal, -1, "Called setPos() on EmbedStream");
 }
 
@@ -1014,6 +1020,7 @@ GFileOffset EmbedStream::getStart() {
 }
 
 void EmbedStream::moveStart(int delta) {
+  (void) delta;
   error(errInternal, -1, "Called moveStart() on EmbedStream");
 }
 
@@ -1110,6 +1117,7 @@ GString *ASCIIHexStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool ASCIIHexStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gFalse);
 }
 
@@ -1195,6 +1203,7 @@ GString *ASCII85Stream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool ASCII85Stream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gFalse);
 }
 
@@ -1426,6 +1435,7 @@ GString *LZWStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool LZWStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -1488,6 +1498,7 @@ GString *RunLengthStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool RunLengthStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -2071,7 +2082,7 @@ GBool CCITTFaxStream::readRow() {
 
 short CCITTFaxStream::getTwoDimCode() {
   int code;
-  CCITTCode *p;
+  const CCITTCode *p;
   int n;
 
   code = 0; // make gcc happy
@@ -2106,7 +2117,7 @@ short CCITTFaxStream::getTwoDimCode() {
 
 short CCITTFaxStream::getWhiteCode() {
   short code;
-  CCITTCode *p;
+  const CCITTCode *p;
   int n;
 
   code = 0; // make gcc happy
@@ -2165,7 +2176,7 @@ short CCITTFaxStream::getWhiteCode() {
 
 short CCITTFaxStream::getBlackCode() {
   short code;
-  CCITTCode *p;
+  const CCITTCode *p;
   int n;
 
   code = 0; // make gcc happy
@@ -2298,6 +2309,7 @@ GString *CCITTFaxStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool CCITTFaxStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -2305,7 +2317,7 @@ GBool CCITTFaxStream::isBinary(GBool last) {
 // DCTStream
 //------------------------------------------------------------------------
 
-#if HAVE_JPEGLIB
+#ifdef HAVE_JPEGLIB
 
 DCTStream::DCTStream(Stream *strA, GBool colorXformA):
     FilterStream(strA) {
@@ -2526,7 +2538,7 @@ void DCTStream::skipInputDataCbk(j_decompress_ptr d, long numBytes) {
 void DCTStream::termSourceCbk(j_decompress_ptr d) {
 }
 
-#else // HAVE_JPEGLIB
+#else /* HAVE_JPEGLIB */
 
 #define idctScaleA 1024
 #define idctScaleB 1138
@@ -2539,7 +2551,7 @@ void DCTStream::termSourceCbk(j_decompress_ptr d) {
 #define idctScaleI 2718
 #define idctScaleJ 2528
 
-static int idctScaleMat[64] = {
+static int const idctScaleMat[64] = {
   idctScaleA, idctScaleB, idctScaleC, idctScaleD, idctScaleA, idctScaleD, idctScaleC, idctScaleB,
   idctScaleB, idctScaleE, idctScaleF, idctScaleG, idctScaleB, idctScaleG, idctScaleF, idctScaleE,
   idctScaleC, idctScaleF, idctScaleH, idctScaleI, idctScaleC, idctScaleI, idctScaleH, idctScaleF,
@@ -2599,7 +2611,7 @@ static inline Guchar dctClip(int x) {
 }
 
 // zig zag decode map
-static int dctZigZag[64] = {
+static int const dctZigZag[64] = {
    0,
    1,  8,
   16,  9,  2,
@@ -3490,7 +3502,8 @@ void DCTStream::transformDataUnit(Gushort *quantTable,
 				  int dataIn[64], Guchar dataOut[64]) {
   int v0, v1, v2, v3, v4, v5, v6, v7;
   int t0, t1, t2, t3, t4, t5, t6, t7;
-  int *p, *scale;
+  int *p;
+  const int *scale;
   Gushort *q;
   int i;
 
@@ -4180,7 +4193,7 @@ int DCTStream::read16() {
   return (c1 << 8) + c2;
 }
 
-#endif // HAVE_JPEGLIB
+#endif /* HAVE_JPEGLIB */
 
 GString *DCTStream::getPSFilter(int psLevel, const char *indent) {
   GString *s;
@@ -4196,6 +4209,7 @@ GString *DCTStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool DCTStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -4203,11 +4217,11 @@ GBool DCTStream::isBinary(GBool last) {
 // FlateStream
 //------------------------------------------------------------------------
 
-int FlateStream::codeLenCodeMap[flateMaxCodeLenCodes] = {
+int const FlateStream::codeLenCodeMap[flateMaxCodeLenCodes] = {
   16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
 };
 
-FlateDecode FlateStream::lengthDecode[flateMaxLitCodes-257] = {
+FlateDecode const FlateStream::lengthDecode[flateMaxLitCodes-257] = {
   {0,   3},
   {0,   4},
   {0,   5},
@@ -4241,7 +4255,7 @@ FlateDecode FlateStream::lengthDecode[flateMaxLitCodes-257] = {
   {0, 258}
 };
 
-FlateDecode FlateStream::distDecode[flateMaxDistCodes] = {
+FlateDecode const FlateStream::distDecode[flateMaxDistCodes] = {
   { 0,     1},
   { 0,     2},
   { 0,     3},
@@ -4274,7 +4288,7 @@ FlateDecode FlateStream::distDecode[flateMaxDistCodes] = {
   {13, 24577}
 };
 
-static FlateCode flateFixedLitCodeTabCodes[512] = {
+static FlateCode const flateFixedLitCodeTabCodes[512] = {
   {7, 0x0100},
   {8, 0x0050},
   {8, 0x0010},
@@ -4789,11 +4803,11 @@ static FlateCode flateFixedLitCodeTabCodes[512] = {
   {9, 0x00ff}
 };
 
-FlateHuffmanTab FlateStream::fixedLitCodeTab = {
-  flateFixedLitCodeTabCodes, 9
+FlateHuffmanTab const FlateStream::fixedLitCodeTab = {
+  const_cast<FlateCode *>(flateFixedLitCodeTabCodes), 9
 };
 
-static FlateCode flateFixedDistCodeTabCodes[32] = {
+static FlateCode const flateFixedDistCodeTabCodes[32] = {
   {5, 0x0000},
   {5, 0x0010},
   {5, 0x0008},
@@ -4828,8 +4842,8 @@ static FlateCode flateFixedDistCodeTabCodes[32] = {
   {0, 0x0000}
 };
 
-FlateHuffmanTab FlateStream::fixedDistCodeTab = {
-  flateFixedDistCodeTabCodes, 5
+FlateHuffmanTab const FlateStream::fixedDistCodeTab = {
+  const_cast<FlateCode *>(flateFixedDistCodeTabCodes), 5
 };
 
 FlateStream::FlateStream(Stream *strA, int predictor, int columns,
@@ -4996,6 +5010,7 @@ GString *FlateStream::getPSFilter(int psLevel, const char *indent) {
 }
 
 GBool FlateStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -5241,7 +5256,7 @@ err:
 
 // Convert an array <lengths> of <n> lengths, in value order, into a
 // Huffman code lookup table.
-void FlateStream::compHuffmanCodes(int *lengths, int n, FlateHuffmanTab *tab) {
+void FlateStream::compHuffmanCodes(const int *lengths, int n, FlateHuffmanTab *tab) {
   int tabSize, len, code, code2, skip, val, i, t;
 
   // find max code length
@@ -5387,6 +5402,7 @@ int BufStream::lookChar(int idx) {
 }
 
 GBool BufStream::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -5429,6 +5445,7 @@ int FixedLengthEncoder::lookChar() {
 }
 
 GBool FixedLengthEncoder::isBinary(GBool last) {
+  (void) last;
   return str->isBinary(gTrue);
 }
 
@@ -5462,7 +5479,7 @@ void ASCIIHexEncoder::reset() {
 }
 
 GBool ASCIIHexEncoder::fillBuf() {
-  static const char *hex = "0123456789abcdef";
+  static const char hex[] = "0123456789abcdef";
   int c;
 
   if (eof) {
diff --git a/xpdf/Stream.h b/xpdf/Stream.h
index c25d46b..2a51a8e 100644
--- a/xpdf/Stream.h
+++ b/xpdf/Stream.h
@@ -11,12 +11,8 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
-#if HAVE_JPEGLIB
+#ifdef HAVE_JPEGLIB
 #include <jpeglib.h>
 #include <setjmp.h>
 #endif
@@ -137,7 +133,7 @@ public:
 
   // Get image parameters which are defined by the stream contents.
   virtual void getImageParams(int *bitsPerComponent,
-			      StreamColorSpaceMode *csMode) {}
+			      StreamColorSpaceMode *csMode) {(void)bitsPerComponent; (void) csMode;}
 
   // Return the next stream in the "stack".
   virtual Stream *getNextStream() { return NULL; }
@@ -591,7 +587,7 @@ private:
 // DCTStream
 //------------------------------------------------------------------------
 
-#if HAVE_JPEGLIB
+#ifdef HAVE_JPEGLIB
 
 class DCTStream;
 
@@ -608,7 +604,7 @@ struct DCTErrorMgr {
   jmp_buf setjmpBuf;
 };
 
-#else // HAVE_JPEGLIB
+#else /* HAVE_JPEGLIB */
 
 // DCT component info
 struct DCTCompInfo {
@@ -636,7 +632,7 @@ struct DCTHuffTable {
   Guchar sym[256];		// symbols
 };
 
-#endif // HAVE_JPEGLIB
+#endif /* HAVE_JPEGLIB */
 
 class DCTStream: public FilterStream {
 public:
@@ -656,7 +652,7 @@ public:
 
 private:
 
-#if HAVE_JPEGLIB
+#ifdef HAVE_JPEGLIB
 
   int colorXform;		// color transform: -1 = unspecified
 				//                   0 = none
@@ -680,7 +676,7 @@ private:
   static void skipInputDataCbk(j_decompress_ptr d, long numBytes);
   static void termSourceCbk(j_decompress_ptr d);
 
-#else // HAVE_JPEGLIB
+#else /* HAVE_JPEGLIB */
 
   GBool progressive;		// set if in progressive mode
   GBool interleaved;		// set if in interleaved mode
@@ -741,7 +737,7 @@ private:
   int readMarker();
   int read16();
 
-#endif // HAVE_JPEGLIB
+#endif /* HAVE_JPEGLIB */
 };
 
 //------------------------------------------------------------------------
@@ -796,8 +792,7 @@ private:
   int remain;			// number valid bytes in output buffer
   int codeBuf;			// input buffer
   int codeSize;			// number of bits in input buffer
-  int				// literal and distance code lengths
-    codeLengths[flateMaxLitCodes + flateMaxDistCodes];
+  int codeLengths[flateMaxLitCodes + flateMaxDistCodes]; // literal and distance code lengths
   FlateHuffmanTab litCodeTab;	// literal code table
   FlateHuffmanTab distCodeTab;	// distance code table
   GBool compressedBlock;	// set if reading a compressed block
@@ -805,22 +800,17 @@ private:
   GBool endOfBlock;		// set when end of block is reached
   GBool eof;			// set when end of stream is reached
 
-  static int			// code length code reordering
-    codeLenCodeMap[flateMaxCodeLenCodes];
-  static FlateDecode		// length decoding info
-    lengthDecode[flateMaxLitCodes-257];
-  static FlateDecode		// distance decoding info
-    distDecode[flateMaxDistCodes];
-  static FlateHuffmanTab	// fixed literal code table
-    fixedLitCodeTab;
-  static FlateHuffmanTab	// fixed distance code table
-    fixedDistCodeTab;
+  static int const codeLenCodeMap[flateMaxCodeLenCodes];			// code length code reordering
+  static FlateDecode const lengthDecode[flateMaxLitCodes-257];		// length decoding info
+  static FlateDecode const distDecode[flateMaxDistCodes];		// distance decoding info
+  static FlateHuffmanTab const fixedLitCodeTab;	// fixed literal code table
+  static FlateHuffmanTab const fixedDistCodeTab;	// fixed distance code table
 
   void readSome();
   GBool startBlock();
   void loadFixedCodes();
   GBool readDynamicCodes();
-  void compHuffmanCodes(int *lengths, int n, FlateHuffmanTab *tab);
+  void compHuffmanCodes(const int *lengths, int n, FlateHuffmanTab *tab);
   int getHuffmanCodeWord(FlateHuffmanTab *tab);
   int getCodeWord(int bits);
 };
@@ -839,10 +829,10 @@ public:
   virtual void reset() {}
   virtual int getChar() { return EOF; }
   virtual int lookChar() { return EOF; }
-  virtual int getBlock(char *blk, int size) { return 0; }
+  virtual int getBlock(char *blk, int size) { (void)blk; (void) size; return 0; }
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gFalse; }
+    { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gFalse; }
 };
 
 //------------------------------------------------------------------------
@@ -860,7 +850,7 @@ public:
   virtual int getChar();
   virtual int lookChar();
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
+    { (void) psLevel; (void) indent; return NULL; }
   virtual GBool isBinary(GBool last = gTrue);
 
   int lookChar(int idx);
@@ -886,7 +876,7 @@ public:
   virtual int getChar();
   virtual int lookChar();
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
+    { (void) psLevel; (void) indent; return NULL; }
   virtual GBool isBinary(GBool last = gTrue);
   virtual GBool isEncoder() { return gTrue; }
 
@@ -913,8 +903,8 @@ public:
   virtual int lookChar()
     { return (bufPtr >= bufEnd && !fillBuf()) ? EOF : (*bufPtr & 0xff); }
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gFalse; }
+    { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gFalse; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -945,8 +935,8 @@ public:
   virtual int lookChar()
     { return (bufPtr >= bufEnd && !fillBuf()) ? EOF : (*bufPtr & 0xff); }
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gFalse; }
+    { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gFalse; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -977,8 +967,8 @@ public:
   virtual int lookChar()
     { return (bufPtr >= bufEnd && !fillBuf()) ? EOF : (*bufPtr & 0xff); }
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gTrue; }
+    { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gTrue; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
@@ -1013,8 +1003,8 @@ public:
   virtual int getChar();
   virtual int lookChar();
   virtual GString *getPSFilter(int psLevel, const char *indent)
-    { return NULL; }
-  virtual GBool isBinary(GBool last = gTrue) { return gTrue; }
+    { (void) psLevel; (void) indent; return NULL; }
+  virtual GBool isBinary(GBool last = gTrue) { (void) last; return gTrue; }
   virtual GBool isEncoder() { return gTrue; }
 
 private:
diff --git a/xpdf/TextOutputDev.cc b/xpdf/TextOutputDev.cc
index 9c226af..9705503 100644
--- a/xpdf/TextOutputDev.cc
+++ b/xpdf/TextOutputDev.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -238,8 +234,8 @@ TextChar::TextChar(Unicode cA, int charPosA, int charLenA,
 }
 
 int TextChar::cmpX(const void *p1, const void *p2) {
-  const TextChar *ch1 = *(const TextChar **)p1;
-  const TextChar *ch2 = *(const TextChar **)p2;
+  const TextChar *ch1 = *(const TextChar *const *)p1;
+  const TextChar *ch2 = *(const TextChar *const *)p2;
 
   if (ch1->xMin < ch2->xMin) {
     return -1;
@@ -251,8 +247,8 @@ int TextChar::cmpX(const void *p1, const void *p2) {
 }
 
 int TextChar::cmpY(const void *p1, const void *p2) {
-  const TextChar *ch1 = *(const TextChar **)p1;
-  const TextChar *ch2 = *(const TextChar **)p2;
+  const TextChar *ch1 = *(const TextChar *const *)p1;
+  const TextChar *ch2 = *(const TextChar *const *)p2;
 
   if (ch1->yMin < ch2->yMin) {
     return -1;
@@ -669,8 +665,8 @@ TextWord::~TextWord() {
 }
 
 int TextWord::cmpYX(const void *p1, const void *p2) {
-  const TextWord *word1 = *(const TextWord **)p1;
-  const TextWord *word2 = *(const TextWord **)p2;
+  const TextWord *word1 = *(const TextWord *const *)p1;
+  const TextWord *word2 = *(const TextWord *const *)p2;
   double cmp;
 
   if ((cmp = word1->yMin - word2->yMin) == 0) {
@@ -680,8 +676,8 @@ int TextWord::cmpYX(const void *p1, const void *p2) {
 }
 
 int TextWord::cmpCharPos(const void *p1, const void *p2) {
-  const TextWord *word1 = *(const TextWord **)p1;
-  const TextWord *word2 = *(const TextWord **)p2;
+  const TextWord *word1 = *(const TextWord *const *)p1;
+  const TextWord *word2 = *(const TextWord *const *)p2;
 
   return word1->charPos[0] - word2->charPos[0];
 }
@@ -831,8 +827,8 @@ double TextLine::getBaseline() {
 }
 
 int TextLine::cmpX(const void *p1, const void *p2) {
-  const TextLine *line1 = *(const TextLine **)p1;
-  const TextLine *line2 = *(const TextLine **)p2;
+  const TextLine *line1 = *(const TextLine *const *)p1;
+  const TextLine *line2 = *(const TextLine *const *)p2;
 
   if (line1->xMin < line2->xMin) {
     return -1;
@@ -904,8 +900,8 @@ int TextColumn::getRotation() {
 }
 
 int TextColumn::cmpX(const void *p1, const void *p2) {
-  const TextColumn *col1 = *(const TextColumn **)p1;
-  const TextColumn *col2 = *(const TextColumn **)p2;
+  const TextColumn *col1 = *(const TextColumn *const *)p1;
+  const TextColumn *col2 = *(const TextColumn *const *)p2;
 
   if (col1->xMin < col2->xMin) {
     return -1;
@@ -917,8 +913,8 @@ int TextColumn::cmpX(const void *p1, const void *p2) {
 }
 
 int TextColumn::cmpY(const void *p1, const void *p2) {
-  const TextColumn *col1 = *(const TextColumn **)p1;
-  const TextColumn *col2 = *(const TextColumn **)p2;
+  const TextColumn *col1 = *(const TextColumn *const *)p1;
+  const TextColumn *col2 = *(const TextColumn *const *)p2;
 
   if (col1->yMin < col2->yMin) {
     return -1;
@@ -930,8 +926,8 @@ int TextColumn::cmpY(const void *p1, const void *p2) {
 }
 
 int TextColumn::cmpPX(const void *p1, const void *p2) {
-  const TextColumn *col1 = *(const TextColumn **)p1;
-  const TextColumn *col2 = *(const TextColumn **)p2;
+  const TextColumn *col1 = *(const TextColumn *const *)p1;
+  const TextColumn *col2 = *(const TextColumn *const *)p2;
 
   if (col1->px < col2->px) {
     return -1;
@@ -1373,6 +1369,7 @@ void TextPage::incCharCount(int nChars) {
 }
 
 void TextPage::beginActualText(GfxState *state, Unicode *u, int uLen) {
+  (void) state;
   if (actualText) {
     gfree(actualText);
   }
@@ -5048,6 +5045,7 @@ void TextOutputDev::generateBOM() {
 }
 
 void TextOutputDev::startPage(int pageNum, GfxState *state) {
+  (void) pageNum;
   text->startPage(state);
 }
 
@@ -5066,15 +5064,20 @@ void TextOutputDev::updateFont(GfxState *state) {
 }
 
 void TextOutputDev::beginString(GfxState *state, GString *s) {
+  (void) state;
+  (void) s;
 }
 
 void TextOutputDev::endString(GfxState *state) {
+  (void) state;
 }
 
 void TextOutputDev::drawChar(GfxState *state, double x, double y,
 			     double dx, double dy,
 			     double originX, double originY,
 			     CharCode c, int nBytes, Unicode *u, int uLen) {
+  (void) originX;
+  (void) originY;
   text->addChar(state, x, y, dx, dy, c, nBytes, u, uLen);
 }
 
diff --git a/xpdf/TextOutputDev.h b/xpdf/TextOutputDev.h
index 0884ace..8452b66 100644
--- a/xpdf/TextOutputDev.h
+++ b/xpdf/TextOutputDev.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include <stdio.h>
 #include "gtypes.h"
 #include "GfxFont.h"
diff --git a/xpdf/TextString.cc b/xpdf/TextString.cc
index 4701fed..726ea20 100644
--- a/xpdf/TextString.cc
+++ b/xpdf/TextString.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include "gmem.h"
 #include "gmempp.h"
diff --git a/xpdf/TextString.h b/xpdf/TextString.h
index c5e7e61..c61aa77 100644
--- a/xpdf/TextString.h
+++ b/xpdf/TextString.h
@@ -15,10 +15,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "CharTypes.h"
 
 class GString;
diff --git a/xpdf/TileCache.cc b/xpdf/TileCache.cc
index ff002ed..56afba2 100644
--- a/xpdf/TileCache.cc
+++ b/xpdf/TileCache.cc
@@ -8,20 +8,11 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmem.h"
 #include "gmempp.h"
 #include "GList.h"
 #include "GMutex.h"
-#ifdef _WIN32
-#  include <windows.h>
-#else
-#  include <pthread.h>
-#  include <unistd.h>
-#endif
+#include <unistd.h>
 #include "Object.h"
 #include "PDFDoc.h"
 #include "SplashBitmap.h"
@@ -146,6 +137,7 @@ static void gSignalCondition(GCondition *c) {
 }
 
 static void gClearCondition(GCondition *c) {
+  (void) c;
 }
 
 static void gWaitCondition(GCondition *c, GMutex *m) {
diff --git a/xpdf/TileCache.h b/xpdf/TileCache.h
index bea58c4..1c3f83c 100644
--- a/xpdf/TileCache.h
+++ b/xpdf/TileCache.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "SplashTypes.h"
 
diff --git a/xpdf/TileCompositor.cc b/xpdf/TileCompositor.cc
index 431c639..35787d3 100644
--- a/xpdf/TileCompositor.cc
+++ b/xpdf/TileCompositor.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <string.h>
 #include <math.h>
 #include "gmempp.h"
diff --git a/xpdf/TileCompositor.h b/xpdf/TileCompositor.h
index aa06c9d..9efec4d 100644
--- a/xpdf/TileCompositor.h
+++ b/xpdf/TileCompositor.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "SplashTypes.h"
 
 class GList;
diff --git a/xpdf/TileMap.cc b/xpdf/TileMap.cc
index 6db6773..4424130 100644
--- a/xpdf/TileMap.cc
+++ b/xpdf/TileMap.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include "gmem.h"
 #include "gmempp.h"
 #include "GList.h"
diff --git a/xpdf/TileMap.h b/xpdf/TileMap.h
index 222877c..6a2dcb3 100644
--- a/xpdf/TileMap.h
+++ b/xpdf/TileMap.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 class GList;
diff --git a/xpdf/UnicodeMap.cc b/xpdf/UnicodeMap.cc
index 833d6fc..54afcb8 100644
--- a/xpdf/UnicodeMap.cc
+++ b/xpdf/UnicodeMap.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <string.h>
 #include "gmem.h"
@@ -123,11 +119,11 @@ UnicodeMap::UnicodeMap(GString *encodingNameA) {
 }
 
 UnicodeMap::UnicodeMap(const char *encodingNameA, GBool unicodeOutA,
-		       UnicodeMapRange *rangesA, int lenA) {
+		       const UnicodeMapRange *rangesA, int lenA) {
   encodingName = new GString(encodingNameA);
   unicodeOut = unicodeOutA;
   kind = unicodeMapResident;
-  ranges = rangesA;
+  ranges = const_cast<UnicodeMapRange *>(rangesA);
   len = lenA;
   eMaps = NULL;
   eMapsLen = 0;
@@ -156,7 +152,7 @@ UnicodeMap::~UnicodeMap() {
 }
 
 void UnicodeMap::incRefCnt() {
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gAtomicIncrement(&refCnt);
 #else
   ++refCnt;
@@ -166,7 +162,7 @@ void UnicodeMap::incRefCnt() {
 void UnicodeMap::decRefCnt() {
   GBool done;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   done = gAtomicDecrement(&refCnt) == 0;
 #else
   done = --refCnt == 0;
diff --git a/xpdf/UnicodeMap.h b/xpdf/UnicodeMap.h
index a15d628..3c663d0 100644
--- a/xpdf/UnicodeMap.h
+++ b/xpdf/UnicodeMap.h
@@ -13,14 +13,10 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "CharTypes.h"
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -54,7 +50,7 @@ public:
 
   // Create a resident UnicodeMap.
   UnicodeMap(const char *encodingNameA, GBool unicodeOutA,
-	     UnicodeMapRange *rangesA, int lenA);
+	     const UnicodeMapRange *rangesA, int lenA);
 
   // Create a resident UnicodeMap that uses a function instead of a
   // list of ranges.
@@ -94,7 +90,7 @@ private:
   int len;			// (user, resident)
   UnicodeMapExt *eMaps;		// (user)
   int eMapsLen;			// (user)
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GAtomicCounter refCnt;
 #else
   int refCnt;
diff --git a/xpdf/UnicodeMapTables.h b/xpdf/UnicodeMapTables.h
index 60ac55d..9ce5884 100644
--- a/xpdf/UnicodeMapTables.h
+++ b/xpdf/UnicodeMapTables.h
@@ -6,7 +6,7 @@
 //
 //========================================================================
 
-static UnicodeMapRange latin1UnicodeMapRanges[] = {
+static UnicodeMapRange const latin1UnicodeMapRanges[] = {
   { 0x000a, 0x000a, 0x0a, 1 },
   { 0x000c, 0x000d, 0x0c, 1 },
   { 0x0020, 0x007e, 0x20, 1 },
@@ -71,7 +71,7 @@ static UnicodeMapRange latin1UnicodeMapRanges[] = {
 };
 #define latin1UnicodeMapLen (sizeof(latin1UnicodeMapRanges) / sizeof(UnicodeMapRange))
 
-static UnicodeMapRange ascii7UnicodeMapRanges[] = {
+static UnicodeMapRange const ascii7UnicodeMapRanges[] = {
   { 0x000a, 0x000a, 0x0a, 1 },
   { 0x000c, 0x000d, 0x0c, 1 },
   { 0x0020, 0x005f, 0x20, 1 },
@@ -206,7 +206,7 @@ static UnicodeMapRange ascii7UnicodeMapRanges[] = {
 };
 #define ascii7UnicodeMapLen (sizeof(ascii7UnicodeMapRanges) / sizeof(UnicodeMapRange))
 
-static UnicodeMapRange symbolUnicodeMapRanges[] = {
+static UnicodeMapRange const symbolUnicodeMapRanges[] = {
   { 0x0020, 0x0021, 0x20, 1 },
   { 0x0023, 0x0023, 0x23, 1 },
   { 0x0025, 0x0026, 0x25, 1 },
@@ -331,7 +331,7 @@ static UnicodeMapRange symbolUnicodeMapRanges[] = {
 };
 #define symbolUnicodeMapLen (sizeof(symbolUnicodeMapRanges) / sizeof(UnicodeMapRange))
 
-static UnicodeMapRange zapfDingbatsUnicodeMapRanges[] = {
+static UnicodeMapRange const zapfDingbatsUnicodeMapRanges[] = {
   { 0x0020, 0x0020, 0x20, 1 },
   { 0x2192, 0x2192, 0xd5, 1 },
   { 0x2194, 0x2195, 0xd6, 1 },
diff --git a/xpdf/UnicodeRemapping.cc b/xpdf/UnicodeRemapping.cc
index e4f09e1..15a5417 100644
--- a/xpdf/UnicodeRemapping.cc
+++ b/xpdf/UnicodeRemapping.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdio.h>
 #include <string.h>
 #include "gmem.h"
@@ -33,7 +29,7 @@ struct UnicodeRemappingString {
 
 //------------------------------------------------------------------------
 
-static int hexCharVals[256] = {
+static int const hexCharVals[256] = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0x
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 1x
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 2x
diff --git a/xpdf/UnicodeRemapping.h b/xpdf/UnicodeRemapping.h
index 950c93a..43e6dda 100644
--- a/xpdf/UnicodeRemapping.h
+++ b/xpdf/UnicodeRemapping.h
@@ -13,10 +13,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "CharTypes.h"
 
 struct UnicodeRemappingString;
diff --git a/xpdf/UnicodeTypeTable.cc b/xpdf/UnicodeTypeTable.cc
index 328d247..9b8c40a 100644
--- a/xpdf/UnicodeTypeTable.cc
+++ b/xpdf/UnicodeTypeTable.cc
@@ -21,7 +21,7 @@ struct UnicodeCaseTableVector {
   Unicode codes[256];
 };
 
-static UnicodeMapTableEntry typeTable[256] = {
+static UnicodeMapTableEntry const typeTable[256] = {
   { "NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN...NNNNN.....##########.NNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN.N....NNNNLNNNNN..##NLNNN#LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL", 'X' },
   { NULL, 'L' },
   { "LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNNLLLLLLLNNNNNNNNNNNNNNLLNNNNNNNNNNNNNNLLLLLNNNNNNNNNLNNNNNNNNNNNNNNNNN", 'X' },
@@ -280,7 +280,7 @@ static UnicodeMapTableEntry typeTable[256] = {
   { "NNN...NNNNN.....##########.NNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL.....NNN..NNNNNNNNNNNNNNNNNNNNNNNLL", 'X' }
 };
 
-static UnicodeCaseTableVector caseTable00 = {{
+static UnicodeCaseTableVector const caseTable00 = {{
   0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
   0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
   0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
@@ -314,7 +314,7 @@ static UnicodeCaseTableVector caseTable00 = {{
   0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
   0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
 }};
-static UnicodeCaseTableVector caseTable01 = {{
+static UnicodeCaseTableVector const caseTable01 = {{
   0x0101, 0x0101, 0x0103, 0x0103, 0x0105, 0x0105, 0x0107, 0x0107,
   0x0109, 0x0109, 0x010b, 0x010b, 0x010d, 0x010d, 0x010f, 0x010f,
   0x0111, 0x0111, 0x0113, 0x0113, 0x0115, 0x0115, 0x0117, 0x0117,
@@ -348,7 +348,7 @@ static UnicodeCaseTableVector caseTable01 = {{
   0x01f0, 0x01f3, 0x01f3, 0x01f3, 0x01f5, 0x01f5, 0x0195, 0x01bf,
   0x01f9, 0x01f9, 0x01fb, 0x01fb, 0x01fd, 0x01fd, 0x01ff, 0x01ff
 }};
-static UnicodeCaseTableVector caseTable02 = {{
+static UnicodeCaseTableVector const caseTable02 = {{
   0x0201, 0x0201, 0x0203, 0x0203, 0x0205, 0x0205, 0x0207, 0x0207,
   0x0209, 0x0209, 0x020b, 0x020b, 0x020d, 0x020d, 0x020f, 0x020f,
   0x0211, 0x0211, 0x0213, 0x0213, 0x0215, 0x0215, 0x0217, 0x0217,
@@ -382,7 +382,7 @@ static UnicodeCaseTableVector caseTable02 = {{
   0x02f0, 0x02f1, 0x02f2, 0x02f3, 0x02f4, 0x02f5, 0x02f6, 0x02f7,
   0x02f8, 0x02f9, 0x02fa, 0x02fb, 0x02fc, 0x02fd, 0x02fe, 0x02ff
 }};
-static UnicodeCaseTableVector caseTable03 = {{
+static UnicodeCaseTableVector const caseTable03 = {{
   0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0305, 0x0306, 0x0307,
   0x0308, 0x0309, 0x030a, 0x030b, 0x030c, 0x030d, 0x030e, 0x030f,
   0x0310, 0x0311, 0x0312, 0x0313, 0x0314, 0x0315, 0x0316, 0x0317,
@@ -416,7 +416,7 @@ static UnicodeCaseTableVector caseTable03 = {{
   0x03ba, 0x03c1, 0x03f2, 0x03f3, 0x03b8, 0x03b5, 0x03f6, 0x03f8,
   0x03f8, 0x03f2, 0x03fb, 0x03fb, 0x03fc, 0x03fd, 0x03fe, 0x03ff
 }};
-static UnicodeCaseTableVector caseTable04 = {{
+static UnicodeCaseTableVector const caseTable04 = {{
   0x0450, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
   0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x045d, 0x045e, 0x045f,
   0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
@@ -450,7 +450,7 @@ static UnicodeCaseTableVector caseTable04 = {{
   0x04f1, 0x04f1, 0x04f3, 0x04f3, 0x04f5, 0x04f5, 0x04f6, 0x04f7,
   0x04f9, 0x04f9, 0x04fa, 0x04fb, 0x04fc, 0x04fd, 0x04fe, 0x04ff
 }};
-static UnicodeCaseTableVector caseTable05 = {{
+static UnicodeCaseTableVector const caseTable05 = {{
   0x0501, 0x0501, 0x0503, 0x0503, 0x0505, 0x0505, 0x0507, 0x0507,
   0x0509, 0x0509, 0x050b, 0x050b, 0x050d, 0x050d, 0x050f, 0x050f,
   0x0510, 0x0511, 0x0512, 0x0513, 0x0514, 0x0515, 0x0516, 0x0517,
@@ -484,7 +484,7 @@ static UnicodeCaseTableVector caseTable05 = {{
   0x05f0, 0x05f1, 0x05f2, 0x05f3, 0x05f4, 0x05f5, 0x05f6, 0x05f7,
   0x05f8, 0x05f9, 0x05fa, 0x05fb, 0x05fc, 0x05fd, 0x05fe, 0x05ff
 }};
-static UnicodeCaseTableVector caseTable1e = {{
+static UnicodeCaseTableVector const caseTable1e = {{
   0x1e01, 0x1e01, 0x1e03, 0x1e03, 0x1e05, 0x1e05, 0x1e07, 0x1e07,
   0x1e09, 0x1e09, 0x1e0b, 0x1e0b, 0x1e0d, 0x1e0d, 0x1e0f, 0x1e0f,
   0x1e11, 0x1e11, 0x1e13, 0x1e13, 0x1e15, 0x1e15, 0x1e17, 0x1e17,
@@ -518,7 +518,7 @@ static UnicodeCaseTableVector caseTable1e = {{
   0x1ef1, 0x1ef1, 0x1ef3, 0x1ef3, 0x1ef5, 0x1ef5, 0x1ef7, 0x1ef7,
   0x1ef9, 0x1ef9, 0x1efa, 0x1efb, 0x1efc, 0x1efd, 0x1efe, 0x1eff
 }};
-static UnicodeCaseTableVector caseTable1f = {{
+static UnicodeCaseTableVector const caseTable1f = {{
   0x1f00, 0x1f01, 0x1f02, 0x1f03, 0x1f04, 0x1f05, 0x1f06, 0x1f07,
   0x1f00, 0x1f01, 0x1f02, 0x1f03, 0x1f04, 0x1f05, 0x1f06, 0x1f07,
   0x1f10, 0x1f11, 0x1f12, 0x1f13, 0x1f14, 0x1f15, 0x1f16, 0x1f17,
@@ -552,7 +552,7 @@ static UnicodeCaseTableVector caseTable1f = {{
   0x1ff0, 0x1ff1, 0x1ff2, 0x1ff3, 0x1ff4, 0x1ff5, 0x1ff6, 0x1ff7,
   0x1f78, 0x1f79, 0x1f7c, 0x1f7d, 0x1ff3, 0x1ffd, 0x1ffe, 0x1fff
 }};
-static UnicodeCaseTableVector caseTable21 = {{
+static UnicodeCaseTableVector const caseTable21 = {{
   0x2100, 0x2101, 0x2102, 0x2103, 0x2104, 0x2105, 0x2106, 0x2107,
   0x2108, 0x2109, 0x210a, 0x210b, 0x210c, 0x210d, 0x210e, 0x210f,
   0x2110, 0x2111, 0x2112, 0x2113, 0x2114, 0x2115, 0x2116, 0x2117,
@@ -586,7 +586,7 @@ static UnicodeCaseTableVector caseTable21 = {{
   0x21f0, 0x21f1, 0x21f2, 0x21f3, 0x21f4, 0x21f5, 0x21f6, 0x21f7,
   0x21f8, 0x21f9, 0x21fa, 0x21fb, 0x21fc, 0x21fd, 0x21fe, 0x21ff
 }};
-static UnicodeCaseTableVector caseTable24 = {{
+static UnicodeCaseTableVector const caseTable24 = {{
   0x2400, 0x2401, 0x2402, 0x2403, 0x2404, 0x2405, 0x2406, 0x2407,
   0x2408, 0x2409, 0x240a, 0x240b, 0x240c, 0x240d, 0x240e, 0x240f,
   0x2410, 0x2411, 0x2412, 0x2413, 0x2414, 0x2415, 0x2416, 0x2417,
@@ -620,7 +620,7 @@ static UnicodeCaseTableVector caseTable24 = {{
   0x24f0, 0x24f1, 0x24f2, 0x24f3, 0x24f4, 0x24f5, 0x24f6, 0x24f7,
   0x24f8, 0x24f9, 0x24fa, 0x24fb, 0x24fc, 0x24fd, 0x24fe, 0x24ff
 }};
-static UnicodeCaseTableVector caseTableff = {{
+static UnicodeCaseTableVector const caseTableff = {{
   0xff00, 0xff01, 0xff02, 0xff03, 0xff04, 0xff05, 0xff06, 0xff07,
   0xff08, 0xff09, 0xff0a, 0xff0b, 0xff0c, 0xff0d, 0xff0e, 0xff0f,
   0xff10, 0xff11, 0xff12, 0xff13, 0xff14, 0xff15, 0xff16, 0xff17,
@@ -654,7 +654,7 @@ static UnicodeCaseTableVector caseTableff = {{
   0xfff0, 0xfff1, 0xfff2, 0xfff3, 0xfff4, 0xfff5, 0xfff6, 0xfff7,
   0xfff8, 0xfff9, 0xfffa, 0xfffb, 0xfffc, 0xfffd, 0xfffe, 0xffff
 }};
-static UnicodeCaseTableVector *caseTable[256] = {
+static const UnicodeCaseTableVector *const caseTable[256] = {
   &caseTable00,
   &caseTable01,
   &caseTable02,
diff --git a/xpdf/XFAForm.cc b/xpdf/XFAForm.cc
index 2f534a8..f2af684 100644
--- a/xpdf/XFAForm.cc
+++ b/xpdf/XFAForm.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include "gmem.h"
 #include "gmempp.h"
@@ -37,7 +33,7 @@
 // 5 bars + 5 spaces -- each can be wide (1) or narrow (0)
 // (there are always exactly 3 wide elements;
 // the last space is always narrow)
-static Guchar code3Of9Data[128][10] = {
+static Guchar const code3Of9Data[128][10] = {
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // 0x00
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
@@ -169,7 +165,7 @@ static Guchar code3Of9Data[128][10] = {
 };
 
 // 3 bars + 3 spaces -- each can be 1, 2, 3, or 4 units wide
-static Guchar code128Data[107][6] = {
+static Guchar const code128Data[107][6] = {
   { 2, 1, 2, 2, 2, 2 },
   { 2, 2, 2, 1, 2, 2 },
   { 2, 2, 2, 2, 2, 1 },
@@ -655,6 +651,8 @@ void XFAForm::scanField(ZxElement *elem, GString *name, GString *fullName,
 			Catalog *catalog) {
   double xSubOffset, ySubOffset, columnWidth, rowHeight;
 
+  (void) catalog;
+  (void) inPageSet;
   if (curPageNum == 0) {
     curPageNum = 1;
   }
@@ -700,6 +698,7 @@ void XFAForm::scanNonField(ZxElement *elem, GString *name, GString *fullName,
   double xSubOffset, ySubOffset;
   int savedPageNum;
 
+  (void) colSpan;
   newTableInfo = tableInfo;
 
   if (elem->isElement("subform")) {
@@ -1085,6 +1084,7 @@ void XFAFormField::draw(int pageNumA, Gfx *gfx, GBool printing,
   double xfaX, xfaY, xfaW, xfaH, pdfX, pdfY, pdfW, pdfH;
   int rot3, i;
 
+  (void) printing;
   if (pageNumA != pageNum) {
     return;
   }
@@ -1437,6 +1437,7 @@ void XFAFormField::drawTextEdit(GfxFontDict *fontDict,
   XFAHorizAlign hAlign;
   XFAVertAlign vAlign;
 
+  (void) rot;
   if (!(value = getFieldValue("text"))) {
     return;
   }
@@ -1555,6 +1556,8 @@ void XFAFormField::drawCheckButton(GfxFontDict *fontDict,
   GString *value;
   double x, y;
 
+  (void) fontDict;
+  (void) rot;
   // get the "on" value for this check button
   itemType = "integer";
   onValue = "1";
@@ -1620,6 +1623,7 @@ void XFAFormField::drawBarCode(GfxFontDict *fontDict,
   char *p;
   int i, j, c;
 
+  (void) rot;
   //--- get field value
   if (!(value = getFieldValue("text"))) {
     return;
diff --git a/xpdf/XFAForm.h b/xpdf/XFAForm.h
index 8e0b363..ed335e9 100644
--- a/xpdf/XFAForm.h
+++ b/xpdf/XFAForm.h
@@ -11,10 +11,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "Form.h"
 
 class GHash;
diff --git a/xpdf/XRef.cc b/xpdf/XRef.cc
index d6b43cd..6b0b886 100644
--- a/xpdf/XRef.cc
+++ b/xpdf/XRef.cc
@@ -8,10 +8,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
@@ -322,7 +318,7 @@ XRef::XRef(BaseStream *strA, GBool repair) {
     cache[i].num = -1;
   }
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gInitMutex(&objStrsMutex);
   gInitMutex(&cacheMutex);
 #endif
@@ -404,7 +400,7 @@ XRef::~XRef() {
       delete objStrs[i];
     }
   }
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gDestroyMutex(&objStrsMutex);
   gDestroyMutex(&cacheMutex);
 #endif
@@ -1041,12 +1037,12 @@ Object *XRef::fetch(int num, int gen, Object *obj, int recursion) {
   }
 
   // check the cache
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&cacheMutex);
 #endif
   if (cache[0].num == num && cache[0].gen == gen) {
     cache[0].obj.copy(obj);
-#if MULTITHREADED
+#ifdef MULTITHREADED
     gUnlockMutex(&cacheMutex);
 #endif
     return obj;
@@ -1059,13 +1055,13 @@ Object *XRef::fetch(int num, int gen, Object *obj, int recursion) {
       }
       cache[0] = tmp;
       cache[0].obj.copy(obj);
-#if MULTITHREADED
+#ifdef MULTITHREADED
       gUnlockMutex(&cacheMutex);
 #endif
       return obj;
     }
   }
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&cacheMutex);
 #endif
 
@@ -1123,7 +1119,7 @@ Object *XRef::fetch(int num, int gen, Object *obj, int recursion) {
 
   // put the new object in the cache, throwing away the oldest object
   // currently in the cache
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&cacheMutex);
 #endif
   if (cache[xrefCacheSize - 1].num >= 0) {
@@ -1135,7 +1131,7 @@ Object *XRef::fetch(int num, int gen, Object *obj, int recursion) {
   cache[0].num = num;
   cache[0].gen = gen;
   obj->copy(&cache[0].obj);
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&cacheMutex);
 #endif
 
@@ -1149,7 +1145,7 @@ GBool XRef::getObjectStreamObject(int objStrNum, int objIdx,
 				  int objNum, Object *obj) {
   ObjectStream *objStr;
 
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gLockMutex(&objStrsMutex);
 #endif
   if (!(objStr = getObjectStream(objStrNum))) {
@@ -1157,7 +1153,7 @@ GBool XRef::getObjectStreamObject(int objStrNum, int objIdx,
   }
   cleanObjectStreamCache();
   objStr->getObject(objIdx, objNum, obj);
-#if MULTITHREADED
+#ifdef MULTITHREADED
   gUnlockMutex(&objStrsMutex);
 #endif
   return gTrue;
diff --git a/xpdf/XRef.h b/xpdf/XRef.h
index 9e63dcf..4c1c2e6 100644
--- a/xpdf/XRef.h
+++ b/xpdf/XRef.h
@@ -11,14 +11,10 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 #include "gfile.h"
 #include "Object.h"
-#if MULTITHREADED
+#ifdef MULTITHREADED
 #include "GMutex.h"
 #endif
 
@@ -149,7 +145,7 @@ private:
   Guint				// time of last use for each obj stream
     objStrLastUse[objStrCacheSize];
   Guint objStrTime;		// current time for the obj stream cache
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GMutex objStrsMutex;
 #endif
   GBool encrypted;		// true if file is encrypted
@@ -161,7 +157,7 @@ private:
   CryptAlgorithm encAlgorithm;	// encryption algorithm
   XRefCacheEntry		// cache of recently accessed objects
     cache[xrefCacheSize];
-#if MULTITHREADED
+#ifdef MULTITHREADED
   GMutex cacheMutex;
 #endif
 
diff --git a/xpdf/Zoox.cc b/xpdf/Zoox.cc
index ba6e114..7be8156 100644
--- a/xpdf/Zoox.cc
+++ b/xpdf/Zoox.cc
@@ -6,10 +6,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -25,7 +21,7 @@
 
 //------------------------------------------------------------------------
 
-static char nameStartChar[256] = {
+static char const nameStartChar[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20
@@ -44,7 +40,7 @@ static char nameStartChar[256] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // f0
 };
 
-static char nameChar[256] = {
+static char const nameChar[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, // 20
diff --git a/xpdf/Zoox.h b/xpdf/Zoox.h
index 49f9f6b..79a2352 100644
--- a/xpdf/Zoox.h
+++ b/xpdf/Zoox.h
@@ -9,10 +9,6 @@
 
 #include <aconf.h>
 
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
 #include "gtypes.h"
 
 class GString;
@@ -42,7 +38,7 @@ public:
   virtual bool isComment() { return false; }
   virtual bool isPI() { return false; }
   virtual bool isElement() { return false; }
-  virtual bool isElement(const char *type) { return false; }
+  virtual bool isElement(const char *type) { (void) type; return false; }
   virtual bool isCharData() { return false; }
   virtual ZxNode *getFirstChild() { return firstChild; }
   virtual ZxNode *getNextChild() { return next; }
diff --git a/xpdf/pdfdetach.cc b/xpdf/pdfdetach.cc
index 34fd439..d9c0985 100644
--- a/xpdf/pdfdetach.cc
+++ b/xpdf/pdfdetach.cc
@@ -19,18 +19,18 @@
 #include "Error.h"
 #include "config.h"
 
-static GBool doList = gFalse;
-static int saveNum = 0;
-static GBool saveAll = gFalse;
-static char savePath[1024] = "";
-static char textEncName[128] = "";
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
-
-static ArgDesc argDesc[] = {
+static GBool doList;
+static int saveNum;
+static GBool saveAll;
+static char savePath[1024];
+static char textEncName[128];
+static char ownerPassword[33];
+static char userPassword[33];
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
+
+static ArgDesc const argDesc[] = {
   {"-list",   argFlag,     &doList,        0,
    "list all embedded files"},
   {"-save",   argInt,      &saveNum,       0,
@@ -57,7 +57,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 int main(int argc, char *argv[]) {
@@ -75,6 +75,17 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  doList = gFalse;
+  saveNum = 0;
+  saveAll = gFalse;
+  savePath[0] = '\0';
+  textEncName[0] = '\0';
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
diff --git a/xpdf/pdffonts.cc b/xpdf/pdffonts.cc
index 7df38cc..7dac701 100644
--- a/xpdf/pdffonts.cc
+++ b/xpdf/pdffonts.cc
@@ -28,7 +28,7 @@
 #include "config.h"
 
 // NB: this must match the definition of GfxFontType in GfxFont.h.
-static const char *fontTypeNames[] = {
+static const char *const fontTypeNames[] = {
   "unknown",
   "Type 1",
   "Type 1C",
@@ -48,17 +48,17 @@ static void scanFonts(Dict *resDict, PDFDoc *doc);
 static void scanFont(GfxFont *font, PDFDoc *doc);
 static GBool checkObject(Object *in, Object *out);
 
-static int firstPage = 1;
-static int lastPage = 0;
-static GBool showFontLoc = gFalse;
-static GBool showFontLocPS = gFalse;
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
-
-static ArgDesc argDesc[] = {
+static int firstPage;
+static int lastPage;
+static GBool showFontLoc;
+static GBool showFontLocPS;
+static char ownerPassword[33];
+static char userPassword[33];
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
+
+static ArgDesc const argDesc[] = {
   {"-f",      argInt,      &firstPage,     0,
    "first page to examine"},
   {"-l",      argInt,      &lastPage,      0,
@@ -83,7 +83,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 static PDFDoc *doc;
@@ -109,6 +109,16 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  showFontLoc = gFalse;
+  showFontLocPS = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
diff --git a/xpdf/pdfimages.cc b/xpdf/pdfimages.cc
index 24b7c0d..3ca8cb7 100644
--- a/xpdf/pdfimages.cc
+++ b/xpdf/pdfimages.cc
@@ -28,19 +28,19 @@
 #include "Error.h"
 #include "config.h"
 
-static int firstPage = 1;
-static int lastPage = 0;
-static GBool dumpJPEG = gFalse;
-static GBool dumpRaw = gFalse;
-static GBool list = gFalse;
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
-
-static ArgDesc argDesc[] = {
+static int firstPage;
+static int lastPage;
+static GBool dumpJPEG;
+static GBool dumpRaw;
+static GBool list;
+static char ownerPassword[33];
+static char userPassword[33];
+static GBool quiet;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
+
+static ArgDesc const argDesc[] = {
   {"-f",      argInt,      &firstPage,     0,
    "first page to convert"},
   {"-l",      argInt,      &lastPage,      0,
@@ -69,7 +69,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 int main(int argc, char *argv[]) {
@@ -83,6 +83,18 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  dumpJPEG = gFalse;
+  dumpRaw = gFalse;
+  list = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  quiet = gFalse;
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
@@ -126,6 +138,7 @@ int main(int argc, char *argv[]) {
     goto err1;
   }
 
+#if 0
   // check for copy permission
   if (!doc->okToCopy()) {
     error(errNotAllowed, -1,
@@ -133,6 +146,7 @@ int main(int argc, char *argv[]) {
     exitCode = 3;
     goto err1;
   }
+#endif
 
   // get page range
   if (firstPage < 1)
diff --git a/xpdf/pdfinfo.cc b/xpdf/pdfinfo.cc
index f5f593b..3117379 100644
--- a/xpdf/pdfinfo.cc
+++ b/xpdf/pdfinfo.cc
@@ -45,19 +45,19 @@ static GString *parseInfoDate(GString *s);
 static GString *parseXMPDate(GString *s);
 static void printBox(const char *text, PDFRectangle *box);
 
-static int firstPage = 1;
-static int lastPage = 0;
-static GBool printBoxes = gFalse;
-static GBool printMetadata = gFalse;
-static GBool rawDates = gFalse;
-static char textEncName[128] = "";
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
-
-static ArgDesc argDesc[] = {
+static int firstPage;
+static int lastPage;
+static GBool printBoxes;
+static GBool printMetadata;
+static GBool rawDates;
+static char textEncName[128];
+static char ownerPassword[33];
+static char userPassword[33];
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
+
+static ArgDesc const argDesc[] = {
   {"-f",      argInt,      &firstPage,        0,
    "first page to convert"},
   {"-l",      argInt,      &lastPage,         0,
@@ -86,7 +86,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 int main(int argc, char *argv[]) {
@@ -109,6 +109,17 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  printBoxes = gFalse;
+  printMetadata = gFalse;
+  rawDates = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
@@ -424,10 +435,10 @@ static GString *parseInfoDate(GString *s) {
     return NULL;
   }
   switch (n) {
-  case 1: mon = 1;
-  case 2: day = 1;
-  case 3: hour = 0;
-  case 4: min = 0;
+  case 1: mon = 1; /* fall through */
+  case 2: day = 1; /* fall through */
+  case 3: hour = 0; /* fall through */
+  case 4: min = 0; /* fall through */
   case 5: sec = 0;
   }
   tmStruct.tm_year = year - 1900;
diff --git a/xpdf/pdftohtml.cc b/xpdf/pdftohtml.cc
index b458202..61d0b18 100644
--- a/xpdf/pdftohtml.cc
+++ b/xpdf/pdftohtml.cc
@@ -27,20 +27,20 @@ static GBool createIndex(char *htmlDir);
 
 //------------------------------------------------------------------------
 
-static int firstPage = 1;
-static int lastPage = 0;
-static double zoom = 1;
-static int resolution = 150;
-static GBool skipInvisible = gFalse;
-static GBool allInvisible = gFalse;
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
+static int firstPage;
+static int lastPage;
+static double zoom;
+static int resolution;
+static GBool skipInvisible;
+static GBool allInvisible;
+static char ownerPassword[33];
+static char userPassword[33];
+static GBool quiet;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
 
-static ArgDesc argDesc[] = {
+static ArgDesc const argDesc[] = {
   {"-f",       argInt,      &firstPage,     0,
    "first page to convert"},
   {"-l",       argInt,      &lastPage,      0,
@@ -71,7 +71,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",       argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 //------------------------------------------------------------------------
@@ -93,6 +93,19 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  zoom = 1;
+  resolution = 150;
+  skipInvisible = gFalse;
+  allInvisible = gFalse;
+  quiet = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
@@ -138,6 +151,7 @@ int main(int argc, char *argv[]) {
     goto err1;
   }
 
+#if 0
   // check for copy permission
   if (!doc->okToCopy()) {
     error(errNotAllowed, -1,
@@ -145,6 +159,7 @@ int main(int argc, char *argv[]) {
     exitCode = 3;
     goto err1;
   }
+#endif
 
   // get page range
   if (firstPage < 1) {
diff --git a/xpdf/pdftopng.cc b/xpdf/pdftopng.cc
index 720066d..46f76e6 100644
--- a/xpdf/pdftopng.cc
+++ b/xpdf/pdftopng.cc
@@ -26,23 +26,23 @@
 #include "SplashOutputDev.h"
 #include "config.h"
 
-static int firstPage = 1;
-static int lastPage = 0;
-static double resolution = 150;
-static GBool mono = gFalse;
-static GBool gray = gFalse;
-static GBool pngAlpha = gFalse;
-static char enableFreeTypeStr[16] = "";
-static char antialiasStr[16] = "";
-static char vectorAntialiasStr[16] = "";
-static char ownerPassword[33] = "";
-static char userPassword[33] = "";
+static int firstPage;
+static int lastPage;
+static double resolution;
+static GBool mono;
+static GBool gray;
+static GBool pngAlpha;
+static char enableFreeTypeStr[16];
+static char antialiasStr[16];
+static char vectorAntialiasStr[16];
+static char ownerPassword[33];
+static char userPassword[33];
 static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
 
-static ArgDesc argDesc[] = {
+static ArgDesc const argDesc[] = {
   {"-f",      argInt,      &firstPage,     0,
    "first page to print"},
   {"-l",      argInt,      &lastPage,      0,
@@ -55,7 +55,7 @@ static ArgDesc argDesc[] = {
    "generate a grayscale PNG file"},
   {"-alpha",  argFlag,     &pngAlpha,      0,
    "include an alpha channel in the PNG file"},
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   {"-freetype",   argString,      enableFreeTypeStr, sizeof(enableFreeTypeStr),
    "enable FreeType font rasterizer: yes, no"},
 #endif
@@ -81,7 +81,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 static void setupPNG(png_structp *png, png_infop *pngInfo, FILE *f,
@@ -107,6 +107,19 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  resolution = 150;
+  mono = gFalse;
+  gray = gFalse;
+  pngAlpha = gFalse;
+  quiet = gFalse;
+  ownerPassword[0] = '\0';
+  userPassword[0] = '\0';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
diff --git a/xpdf/pdftoppm.cc b/xpdf/pdftoppm.cc
index e01ac5c..207d076 100644
--- a/xpdf/pdftoppm.cc
+++ b/xpdf/pdftoppm.cc
@@ -28,25 +28,25 @@
 #include "SplashOutputDev.h"
 #include "config.h"
 
-static int firstPage = 1;
-static int lastPage = 0;
-static double resolution = 150;
+static int firstPage;
+static int lastPage;
+static double resolution;
 static GBool mono = gFalse;
 static GBool gray = gFalse;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
 static GBool cmyk = gFalse;
 #endif
-static char enableFreeTypeStr[16] = "";
-static char antialiasStr[16] = "";
-static char vectorAntialiasStr[16] = "";
-static char ownerPassword[33] = "";
-static char userPassword[33] = "";
+static char enableFreeTypeStr[16];
+static char antialiasStr[16];
+static char vectorAntialiasStr[16];
+static char ownerPassword[33];
+static char userPassword[33];
 static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
 
-static ArgDesc argDesc[] = {
+static ArgDesc const argDesc[] = {
   {"-f",      argInt,      &firstPage,     0,
    "first page to print"},
   {"-l",      argInt,      &lastPage,      0,
@@ -57,11 +57,11 @@ static ArgDesc argDesc[] = {
    "generate a monochrome PBM file"},
   {"-gray",   argFlag,     &gray,          0,
    "generate a grayscale PGM file"},
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   {"-cmyk",   argFlag,     &cmyk,          0,
    "generate a CMYK PAM file"},
 #endif
-#if HAVE_FREETYPE_H
+#ifdef HAVE_FREETYPE
   {"-freetype",   argString,      enableFreeTypeStr, sizeof(enableFreeTypeStr),
    "enable FreeType font rasterizer: yes, no"},
 #endif
@@ -87,7 +87,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",      argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 int main(int argc, char *argv[]) {
@@ -120,13 +120,31 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  resolution = 150;
+  mono = gFalse;
+  gray = gFalse;
+#ifdef SPLASH_CMYK
+  cmyk = gFalse;
+#endif
+  enableFreeTypeStr[0] = '\0';
+  antialiasStr[0] = '\0';
+  vectorAntialiasStr[0] = '\0';
+  quiet = gFalse;
+  ownerPassword[0] = '\0';
+  userPassword[0] = '\0';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+  
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
   n = 0;
   n += mono ? 1 : 0;
   n += gray ? 1 : 0;
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   n += cmyk ? 1 : 0;
 #endif
   if (n > 1) {
@@ -199,7 +217,7 @@ int main(int argc, char *argv[]) {
     ext = "pbm";
   } else if (gray) {
     ext = "pgm";
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   } else if (cmyk) {
     ext = "pam";
 #endif
@@ -215,11 +233,11 @@ int main(int argc, char *argv[]) {
   } else if (gray) {
     paperColor[0] = 0xff;
     splashOut = new SplashOutputDev(splashModeMono8, 1, gFalse, paperColor);
-#if SPLASH_CMYK
+#ifdef SPLASH_CMYK
   } else if (cmyk) {
     paperColor[0] = paperColor[1] = paperColor[2] = paperColor[3] = 0;
     splashOut = new SplashOutputDev(splashModeCMYK8, 1, gFalse, paperColor);
-#endif // SPLASH_CMYK
+#endif /* SPLASH_CMYK */
   } else {
     paperColor[0] = paperColor[1] = paperColor[2] = 0xff;
     splashOut = new SplashOutputDev(splashModeRGB8, 1, gFalse, paperColor);
diff --git a/xpdf/pdftops.cc b/xpdf/pdftops.cc
index 8e75dd8..4e2eb86 100644
--- a/xpdf/pdftops.cc
+++ b/xpdf/pdftops.cc
@@ -32,44 +32,44 @@
 #include "Error.h"
 #include "config.h"
 
-static int firstPage = 1;
-static int lastPage = 0;
-static GBool level1 = gFalse;
-static GBool level1Sep = gFalse;
-static GBool level2 = gFalse;
-static GBool level2Gray = gFalse;
-static GBool level2Sep = gFalse;
-static GBool level3 = gFalse;
-static GBool level3Gray = gFalse;
-static GBool level3Sep = gFalse;
-static GBool doEPS = gFalse;
-static GBool doForm = gFalse;
-#if OPI_SUPPORT
+static int firstPage;
+static int lastPage;
+static GBool level1;
+static GBool level1Sep;
+static GBool level2;
+static GBool level2Gray;
+static GBool level2Sep;
+static GBool level3;
+static GBool level3Gray;
+static GBool level3Sep;
+static GBool doEPS;
+static GBool doForm;
+#ifdef OPI_SUPPORT
 static GBool doOPI = gFalse;
 #endif
-static GBool noEmbedT1Fonts = gFalse;
-static GBool noEmbedTTFonts = gFalse;
-static GBool noEmbedCIDPSFonts = gFalse;
-static GBool noEmbedCIDTTFonts = gFalse;
-static GBool preload = gFalse;
-static char paperSize[15] = "";
-static int paperWidth = 0;
-static int paperHeight = 0;
-static GBool noCrop = gFalse;
-static GBool expand = gFalse;
-static GBool noShrink = gFalse;
-static GBool noCenter = gFalse;
-static GBool pageCrop = gFalse;
-static GBool userUnit = gFalse;
-static GBool duplex = gFalse;
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
+static GBool noEmbedT1Fonts;
+static GBool noEmbedTTFonts;
+static GBool noEmbedCIDPSFonts;
+static GBool noEmbedCIDTTFonts;
+static GBool preload;
+static char paperSize[15];
+static int paperWidth;
+static int paperHeight;
+static GBool noCrop;
+static GBool expand;
+static GBool noShrink;
+static GBool noCenter;
+static GBool pageCrop;
+static GBool userUnit;
+static GBool duplex;
+static char ownerPassword[33];
+static char userPassword[33];
+static GBool quiet;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
 
-static ArgDesc argDesc[] = {
+static ArgDesc const argDesc[] = {
   {"-f",          argInt,      &firstPage,      0,
    "first page to print"},
   {"-l",          argInt,      &lastPage,       0,
@@ -94,7 +94,7 @@ static ArgDesc argDesc[] = {
    "generate Encapsulated PostScript (EPS)"},
   {"-form",       argFlag,     &doForm,         0,
    "generate a PostScript form"},
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   {"-opi",        argFlag,     &doOPI,          0,
    "generate OPI comments"},
 #endif
@@ -146,7 +146,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",          argFlag,     &printHelp,      0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0 }
 };
 
 int main(int argc, char *argv[]) {
@@ -178,6 +178,43 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  level1 = gFalse;
+  level1Sep = gFalse;
+  level2 = gFalse;
+  level2Gray = gFalse;
+  level2Sep = gFalse;
+  level3 = gFalse;
+  level3Gray = gFalse;
+  level3Sep = gFalse;
+  doEPS = gFalse;
+  doForm = gFalse;
+#ifdef OPI_SUPPORT
+  doOPI = gFalse;
+#endif
+  noEmbedT1Fonts = gFalse;
+  noEmbedTTFonts = gFalse;
+  noEmbedCIDPSFonts = gFalse;
+  noEmbedCIDTTFonts = gFalse;
+  preload = gFalse;
+  paperSize[0] = '\0';
+  paperWidth = 0;
+  paperHeight = 0;
+  noCrop = gFalse;
+  expand = gFalse;
+  noShrink = gFalse;
+  noCenter = gFalse;
+  pageCrop = gFalse;
+  userUnit = gFalse;
+  duplex = gFalse;
+  quiet = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
@@ -232,7 +269,7 @@ int main(int argc, char *argv[]) {
 
   // read config file
   globalParams = new GlobalParams(cfgFileName);
-#if HAVE_SPLASH
+#ifdef HAVE_SPLASH
   globalParams->setupBaseFonts(NULL);
 #endif
   if (paperSize[0]) {
@@ -286,7 +323,7 @@ int main(int argc, char *argv[]) {
   if (preload) {
     globalParams->setPSPreload(preload);
   }
-#if OPI_SUPPORT
+#ifdef OPI_SUPPORT
   if (doOPI) {
     globalParams->setPSOPI(doOPI);
   }
diff --git a/xpdf/pdftotext.cc b/xpdf/pdftotext.cc
index 0496c64..0ebee1e 100644
--- a/xpdf/pdftotext.cc
+++ b/xpdf/pdftotext.cc
@@ -35,29 +35,29 @@
 #include "Error.h"
 #include "config.h"
 
-static int firstPage = 1;
-static int lastPage = 0;
-static GBool physLayout = gFalse;
-static GBool simpleLayout = gFalse;
-static GBool tableLayout = gFalse;
-static GBool linePrinter = gFalse;
-static GBool rawOrder = gFalse;
-static double fixedPitch = 0;
-static double fixedLineSpacing = 0;
-static GBool clipText = gFalse;
-static GBool discardDiag = gFalse;
-static char textEncName[128] = "";
-static char textEOL[16] = "";
-static GBool noPageBreaks = gFalse;
-static GBool insertBOM = gFalse;
-static char ownerPassword[33] = "\001";
-static char userPassword[33] = "\001";
-static GBool quiet = gFalse;
-static char cfgFileName[256] = "";
-static GBool printVersion = gFalse;
-static GBool printHelp = gFalse;
+static int firstPage;
+static int lastPage;
+static GBool physLayout;
+static GBool simpleLayout;
+static GBool tableLayout;
+static GBool linePrinter;
+static GBool rawOrder;
+static double fixedPitch;
+static double fixedLineSpacing;
+static GBool clipText;
+static GBool discardDiag;
+static char textEncName[128];
+static char textEOL[16];
+static GBool noPageBreaks;
+static GBool insertBOM;
+static char ownerPassword[33];
+static char userPassword[33];
+static GBool quiet;
+static char cfgFileName[256];
+static GBool printVersion;
+static GBool printHelp;
 
-static ArgDesc argDesc[] = {
+static ArgDesc const argDesc[] = {
   {"-f",       argInt,      &firstPage,     0,
    "first page to convert"},
   {"-l",       argInt,      &lastPage,      0,
@@ -106,7 +106,7 @@ static ArgDesc argDesc[] = {
    "print usage information"},
   {"-?",       argFlag,     &printHelp,     0,
    "print usage information"},
-  {NULL}
+  {NULL, argFlag, 0, 0, 0}
 };
 
 int main(int argc, char *argv[]) {
@@ -138,6 +138,28 @@ int main(int argc, char *argv[]) {
 
   exitCode = 99;
 
+  firstPage = 1;
+  lastPage = 0;
+  physLayout = gFalse;
+  simpleLayout = gFalse;
+  tableLayout = gFalse;
+  linePrinter = gFalse;
+  rawOrder = gFalse;
+  fixedPitch = 0;
+  fixedLineSpacing = 0;
+  clipText = gFalse;
+  discardDiag = gFalse;
+  textEncName[0] = '\0';
+  textEOL[0] = '\0';
+  noPageBreaks = gFalse;
+  insertBOM = gFalse;
+  quiet = gFalse;
+  ownerPassword[0] = '\001';
+  userPassword[0] = '\001';
+  cfgFileName[0] = '\0';
+  printVersion = gFalse;
+  printHelp = gFalse;
+
   // parse args
   fixCommandLine(&argc, &argv);
   ok = parseArgs(argDesc, &argc, argv);
@@ -197,6 +219,7 @@ int main(int argc, char *argv[]) {
     goto err2;
   }
 
+#if 0
   // check for copy permission
   if (!doc->okToCopy()) {
     error(errNotAllowed, -1,
@@ -204,6 +227,7 @@ int main(int argc, char *argv[]) {
     exitCode = 3;
     goto err2;
   }
+#endif
 
   // construct text file name
   if (argc == 3) {
