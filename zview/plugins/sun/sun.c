#include "plugin.h"
#include "zvplugin.h"
#include "exports.h"

/*
 * NOTES:
 * 	Each line of the image is rounded out to a multiple of 16 bits.
 *   This corresponds to the rounding convention used by the memory pixrect
 *   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
 *	The ras_encoding field (always set to 0 by Sun's supported software)
 *   was renamed to ras_length in release 2.0.  As a result, rasterfiles
 *   of type 0 generated by the old software claim to have 0 length; for
 *   compatibility, code reading rasterfiles must be prepared to compute the
 *   true length from the width, height, and depth fields.
 */

/*
> From:    Pat McGee
> Subject: Re: Format for byte encoded rasterfiles (1)
> 
> The format is composed of many sequences of variable length records.
> Each record may be 1, 2, or 3 bytes long.
> 
>  o  If the first byte is not 0x80, the record is one byte long, and 
>     contains a pixel value.  Output 1 pixel of that value.
>  o  If the first byte is 0x80 and the second byte is zero, the record
>     is two bytes long.  Output 1 pixel with value 0x80.
>  o  If the first byte is 0x80, and the second byte is not zero, the 
>     record is three bytes long.  The second byte is a count and the 
>     third byte is a value.  Output (count+1) pixels of that value.
> 
> A run is not terminated at the end of a scan line.  So, if there are 
> three lines of red in a picture 100 pixels wide, the first run will 
> be 0x80 0xff 0x<red>, and the second will be 0x80 0x2b 0x<red>.
*/

struct rasterfile {
	uint32_t	ras_magic;		/* magic number */
	uint32_t	ras_width;		/* width (pixels) of image */
	uint32_t	ras_height;		/* height (pixels) of image */
	uint32_t	ras_depth;		/* depth (1, 8, or 24 bits) of pixel */
	uint32_t	ras_length;		/* length (bytes) of image */
	uint32_t	ras_type;		/* type of file; see RT_* below */
	uint32_t	ras_maptype;	/* type of colormap; see RMT_* below */
	uint32_t	ras_maplength;	/* length (bytes) of following map */
	/* color map follows for ras_maplength bytes, followed by image */
};
#define	RAS_MAGIC			0x59a66a95UL
#define RAS_MAGIC_SWAPPED	0x956aa659UL


/* Sun supported ras_type's */
#define RT_OLD		0	/* Raw pixrect image in 68000 byte order */
#define RT_STANDARD	1	/* Raw pixrect image in 68000 byte order */
#define RT_BYTE_ENCODED	2	/* Run-length compression of bytes */
#define RT_FORMAT_RGB	3	/* XRGB or RGB instead of XBGR or BGR */
#define RT_FORMAT_TIFF	4	/* tiff <-> standard rasterfile */
#define RT_FORMAT_IFF	5	/* iff (TAAC format) <-> standard rasterfile */
#define RT_EXPERIMENTAL 0xffffU	/* Reserved for testing */

/* Sun registered ras_maptype's */
#define RMT_RAW		2
/* Sun supported ras_maptype's */
#define RMT_NONE		0	/* ras_maplength is expected to be 0 */
#define RMT_EQUAL_RGB	1	/* red[ras_maplength/3],green[],blue[] */

#ifdef PLUGIN_SLB

long __CDECL get_option(zv_int_t which)
{
	switch (which)
	{
	case OPTION_CAPABILITIES:
		return CAN_DECODE | CAN_ENCODE;
	case OPTION_EXTENSIONS:
		return (long) (EXTENSIONS);

	case INFO_NAME:
		return (long)NAME;
	case INFO_VERSION:
		return VERSION;
	case INFO_DATETIME:
		return (long)DATE;
	case INFO_AUTHOR:
		return (long)AUTHOR;
#ifdef MISC_INFO
	case INFO_MISC:
		return (long)MISC_INFO;
#endif
	case INFO_COMPILER:
		return (long)(COMPILER_VERSION_STRING);
	}
	return -ENOSYS;
}
#endif


static void decode_ras(uint8_t *src, uint8_t *dst, size_t dstlen)
{
	uint8_t cmd;
	int count;
	uint8_t *end;
	
	end = dst + dstlen;
	do
	{
		cmd = *src++;
		if (cmd == 0x80)
		{
			count = *src++;
			if (count == 0)
			{
				*dst++ = 0x80;
			} else
			{
				uint8_t value;
				
				value = *src++;
				do
				{
					*dst++ = value;
				} while (--count >= 0);
			}
		} else
		{
			*dst++ = cmd;
		}
	} while (dst < end);
}


static uint32_t swap32(uint32_t d)
{
	return ((d >> 24) & 0xffL) | ((d << 8) & 0xff0000L) | ((d >> 8) & 0xff00L) | ((d << 24) & 0xff000000L);
}


/*==================================================================================*
 * boolean __CDECL reader_init:														*
 *		Open the file "name", fit the "info" struct. ( see zview.h) and make others	*
 *		things needed by the decoder.												*
 *----------------------------------------------------------------------------------*
 * input:																			*
 *		name		->	The file to open.											*
 *		info		->	The IMGINFO struct. to fit.									*
 *----------------------------------------------------------------------------------*
 * return:	 																		*
 *      TRUE if all ok else FALSE.													*
 *==================================================================================*/
boolean __CDECL reader_init(const char *name, IMGINFO info)
{
	uint8_t *bmap;
	int16_t handle;
	int big_endian;
	size_t file_size;
	size_t bytes_per_row;
	size_t ras_length;
	struct rasterfile header;

	handle = (int16_t) Fopen(name, FO_READ);
	if (handle < 0)
	{
		RETURN_ERROR(EC_Fopen);
	}
	file_size = Fseek(0, handle, SEEK_END);
	Fseek(0, handle, SEEK_SET);
	
	if (Fread(handle, sizeof(header), &header) != sizeof(header))
	{
		Fclose(handle);
		RETURN_ERROR(EC_Fread);
	}
	if (header.ras_magic == RAS_MAGIC)
	{
		big_endian = TRUE;
	} else if (header.ras_magic == RAS_MAGIC_SWAPPED)
	{
		big_endian = FALSE;
	} else
	{
		Fclose(handle);
		RETURN_ERROR(EC_FileId);
	}
	
	if (!big_endian)
	{
		header.ras_width = swap32(header.ras_width);
		header.ras_height = swap32(header.ras_height);
		header.ras_depth = swap32(header.ras_depth);
		header.ras_length = swap32(header.ras_length);
		header.ras_type = swap32(header.ras_type);
		header.ras_maptype = swap32(header.ras_maptype);
		header.ras_maplength = swap32(header.ras_maplength);
	}
	file_size -= sizeof(header);

	info->width = header.ras_width;
	info->height = header.ras_height;
	info->planes = header.ras_depth;
	
	switch (info->planes)
	{
	case 1:
		info->colors = 1L << 1;
		bytes_per_row = ((size_t)info->width + 7) / 8;
		info->components = 1;
		info->indexed_color = FALSE;
		break;
	case 4:
		info->colors = 1L << 4;
		bytes_per_row = ((size_t)info->width + 1) / 2;
		info->components = 1;
		info->indexed_color = TRUE;
		break;
	case 8:
		info->colors = 1L << 8;
		bytes_per_row = (size_t)info->width;
		info->components = 1;
		info->indexed_color = TRUE;
		break;
	case 24:
		info->colors = 1L << 24;
		bytes_per_row = (size_t)info->width * 3;
		info->components = 3;
		info->indexed_color = FALSE;
		break;
	case 32:
		info->colors = 1L << 24;
		bytes_per_row = (size_t)info->width * 4;
		info->components = 3;
		info->indexed_color = FALSE;
		break;
	default:
		Fclose(handle);
		RETURN_ERROR(EC_PixelDepth);
	}

	/* Each line of the image is rounded out to a multiple of 16 bits */
	if (bytes_per_row & 1)
		bytes_per_row++;

	ras_length = bytes_per_row * info->height;
	if (header.ras_maptype == RMT_NONE)
	{
		int i;

		if (info->planes == 4)
		{
			for (i = 0; i < 16; i++)
			{
				info->palette[i].red =
				info->palette[i].green =
				info->palette[i].blue = i * 17;
			}
		} else if (info->planes == 8)
		{
			for (i = 0; i < 256; i++)
			{
				info->palette[i].red =
				info->palette[i].green =
				info->palette[i].blue = i;
			}
		}
	} else if (header.ras_maptype == RMT_EQUAL_RGB && header.ras_maplength <= 256 * 3)
	{
		int i;
		uint8_t palette[256 * 3];
		int len = (int)(header.ras_maplength / 3);
		
		if ((size_t) Fread(handle, header.ras_maplength, palette) != header.ras_maplength)
		{
			RETURN_ERROR(EC_Fread);
		}
		for (i = 0; i < len; i++)
		{
			info->palette[i].red = palette[i];
			info->palette[i].green = palette[i + len];
			info->palette[i].blue = palette[i + 2 * len];
		}
		for (; i < 256; i++)
		{
			info->palette[i].red =
			info->palette[i].green =
			info->palette[i].blue = i;
		}
		file_size -= header.ras_maplength;
	} else
	{
		RETURN_ERROR(EC_ColorMapType);
	}
	
	bmap = malloc(ras_length);
	if (bmap == NULL)
	{
		Fclose(handle);
		RETURN_ERROR(EC_Malloc);
	}
	switch ((unsigned int)header.ras_type)
	{
	case RT_BYTE_ENCODED:
		{
			uint8_t *temp;
	
			temp = malloc(file_size);
			if (temp == NULL)
			{
				free(bmap);
				Fclose(handle);
				RETURN_ERROR(EC_Malloc);
			}
			if ((size_t) Fread(handle, file_size, temp) != file_size)
			{
				free(temp);
				free(bmap);
				Fclose(handle);
				RETURN_ERROR(EC_Fread);
			}
			decode_ras(temp, bmap, ras_length);
			free(temp);
			strcpy(info->compression, "RLE");
		}
		break;
	case RT_OLD:
	case RT_STANDARD:
	case RT_FORMAT_RGB:
		if ((size_t)Fread(handle, ras_length, bmap) != ras_length)
		{
			free(bmap);
			Fclose(handle);
			RETURN_ERROR(EC_Fread);
		}
		strcpy(info->compression, "None");
		break;
	default:
		free(bmap);
		Fclose(handle);
		RETURN_ERROR(EC_CompType);
	}
	Fclose(handle);
	
	info->real_width = info->width;
	info->real_height = info->height;
	info->memory_alloc = TT_RAM;
	info->page = 1;						/* required - more than 1 = animation */
	info->orientation = UP_TO_DOWN;
	info->num_comments = 0;				/* required - disable exif tab */
	info->_priv_var = 0;				/* y position in bmap */
	info->_priv_var_more = header.ras_type;
	info->_priv_ptr = bmap;

	strcpy(info->info, "Sun Raster");
	if (big_endian)
		strcat(info->info, ", Motorola");
	else
		strcat(info->info, ", Intel");
	switch ((unsigned int)header.ras_type)
	{
	case RT_OLD:
		strcat(info->info, " (Old)");
		break;
	case RT_STANDARD:
		strcat(info->info, " (Standard)");
		break;
	case RT_BYTE_ENCODED:
		strcat(info->info, " (Byte encoded)");
		break;
	case RT_FORMAT_RGB:
		strcat(info->info, " (Format RGB)");
		break;
	case RT_FORMAT_TIFF:
		strcat(info->info, " (Format TIFF)");
		break;
	case RT_FORMAT_IFF:
		strcat(info->info, " (Format IFF)");
		break;
	case RT_EXPERIMENTAL:
		strcat(info->info, " (Experimental)");
		break;
	}

	RETURN_SUCCESS();
}


/*==================================================================================*
 * boolean __CDECL reader_read:														*
 *		This function fits the buffer with image data								*
 *----------------------------------------------------------------------------------*
 * input:																			*
 *		buffer		->	The destination buffer.										*
 *		info		->	The IMGINFO struct. to fit.									*
 *----------------------------------------------------------------------------------*
 * return:	 																		*
 *      TRUE if all ok else FALSE.													*
 *==================================================================================*/
boolean __CDECL reader_read(IMGINFO info, uint8_t *buffer)
{
	uint8_t *bmap = (uint8_t *)info->_priv_ptr;
	int x;

	bmap += info->_priv_var;
	x = info->width;

	switch (info->planes)
	{
	case 1:
		{
			int16_t byte;
			
			x = (x + 7) >> 3;
			info->_priv_var += x;
			/* Each line of the image is rounded out to a multiple of 16 bits */
			if (x & 1)
				info->_priv_var += 1;
			do
			{
				byte = *bmap++;
				*buffer++ = (byte >> 7) & 1;
				*buffer++ = (byte >> 6) & 1;
				*buffer++ = (byte >> 5) & 1;
				*buffer++ = (byte >> 4) & 1;
				*buffer++ = (byte >> 3) & 1;
				*buffer++ = (byte >> 2) & 1;
				*buffer++ = (byte >> 1) & 1;
				*buffer++ = (byte >> 0) & 1;
			} while (--x > 0);
		}
		break;

	case 4:
		{
			int16_t byte;
			
			x = (x + 1) >> 1;
			info->_priv_var += x;
			/* Each line of the image is rounded out to a multiple of 16 bits */
			if (x & 1)
				info->_priv_var += 1;
			do
			{
				byte = *bmap++;
				*buffer++ = byte >> 4;
				*buffer++ = byte & 15;
			} while (--x > 0);
		}
		break;

	case 8:
		{
			info->_priv_var += x;
			/* Each line of the image is rounded out to a multiple of 16 bits */
			if (x & 1)
				info->_priv_var += 1;
			do
			{
				*buffer++ = *bmap++;
			} while (--x > 0);
		}
		break;

	case 24:
		{
			int ras_type = (int)info->_priv_var_more;
			
			info->_priv_var += x * 3;
			/* Each line of the image is rounded out to a multiple of 16 bits */
			if (x & 1)
				info->_priv_var += 1;
			if (ras_type == RT_FORMAT_RGB)
			{
				/* RGB */
				do
				{
					*buffer++ = *bmap++;
					*buffer++ = *bmap++;
					*buffer++ = *bmap++;
				} while (--x > 0);
			} else
			{
				/* BGR */
				do
				{
					*buffer++ = bmap[2];
					*buffer++ = bmap[1];
					*buffer++ = bmap[0];
					bmap += 3;
				} while (--x > 0);
			}
		}
		break;

	case 32:
		{
			int ras_type = (int)info->_priv_var_more;
			
			info->_priv_var += x * 4;
			/* Each line of the image is rounded out to a multiple of 16 bits, but this cannot be odd */
			if (ras_type == RT_FORMAT_RGB)
			{
				/* xRGB */
				do
				{
					bmap++;
					*buffer++ = *bmap++;
					*buffer++ = *bmap++;
					*buffer++ = *bmap++;
				} while (--x > 0);
			} else
			{
				/* BGRx */
				do
				{
					*buffer++ = bmap[2];
					*buffer++ = bmap[1];
					*buffer++ = bmap[0];
					bmap += 4;
				} while (--x > 0);
			}
		}
		break;
	}	

	RETURN_SUCCESS();
}


/*==================================================================================*
 * boolean __CDECL reader_quit:														*
 *		This function makes the last job like close the file handler and free the	*
 *		allocated memory.															*
 *----------------------------------------------------------------------------------*
 * input:																			*
 *		info		->	The IMGINFO struct. to fit.									*
 *----------------------------------------------------------------------------------*
 * return:	 																		*
 *      --																			*
 *==================================================================================*/
void __CDECL reader_quit(IMGINFO info)
{
	free(info->_priv_ptr);
	info->_priv_ptr = 0;
}


/*==================================================================================*
 * boolean __CDECL reader_get_txt													*
 *		This function , like other function must be always present.					*
 *		It fills txtdata struct. with the text present in the picture ( if any).	*
 *----------------------------------------------------------------------------------*
 * input:																			*
 *		txtdata		->	The destination text buffer.								*
 *		info		->	The IMGINFO struct. to fit.									*
 *----------------------------------------------------------------------------------*
 * return:	 																		*
 *      --																			*
 *==================================================================================*/
void __CDECL reader_get_txt(IMGINFO info, txt_data *txtdata)
{
	(void)info;
	(void)txtdata;
}


boolean __CDECL encoder_init(const char *name, IMGINFO info)
{
	int16_t handle;
	struct rasterfile header;
	size_t line_size;

	if ((handle = (int16_t) Fcreate(name, 0)) < 0)
	{
		RETURN_ERROR(EC_Fcreate);
	}

	line_size = (size_t)info->width * 3;
	/* Each line of the image is rounded out to a multiple of 16 bits */
	if (line_size & 1)
		line_size++;
	
	header.ras_magic = RAS_MAGIC;
	header.ras_width = info->width;
	header.ras_height = info->height;
	header.ras_depth = 24;
	header.ras_length = line_size * info->height;
	header.ras_type = RT_FORMAT_RGB;
	header.ras_maptype = RMT_NONE;
	header.ras_maplength = 0;
	if (Fwrite(handle, sizeof(header), &header) != sizeof(header))
	{
		Fclose(handle);
		RETURN_ERROR(EC_Fwrite);
	}
	
	info->planes = 24;
	info->components = 3;
	info->colors = 1L << 24;
	info->orientation = UP_TO_DOWN;
	info->memory_alloc = TT_RAM;
	info->indexed_color = FALSE;
	info->page = 1;

	info->_priv_var = handle;

	return TRUE;
}


boolean __CDECL encoder_write(IMGINFO info, uint8_t *buffer)
{
	int16_t handle = (int16_t)info->_priv_var;
	size_t line_size;

	line_size = (size_t)info->width * 3;
	/* Each line of the image is rounded out to a multiple of 16 bits */
	if (line_size & 1)
		buffer[line_size++] = '\0';
	if ((size_t)Fwrite(handle, line_size, buffer) != line_size)
	{
		RETURN_ERROR(EC_Fwrite);
	}
	RETURN_SUCCESS();
}


void __CDECL encoder_quit(IMGINFO info)
{
	int16_t handle = (int16_t)info->_priv_var;

	if (handle > 0)
	{
		Fclose(handle);
		info->_priv_var = 0;
	}
}
